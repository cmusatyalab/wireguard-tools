/*!
* MDB5
* Version: PRO 7.0.0
*
*
* Copyright: Material Design for Bootstrap
* https://mdbootstrap.com/
*
* Read the license: https://mdbootstrap.com/general/license/
*
*
* Documentation: https://mdbootstrap.com/docs/standard/
*
* Support: https://mdbootstrap.com/support/
*
* Contact: contact@mdbootstrap.com
*
*/
var lr = Object.defineProperty;
var cr = (i, t, e) => t in i ? lr(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var mi = (i, t, e) => (cr(i, typeof t != "symbol" ? t + "" : t, e), e);
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
function dt() {
}
const hr = function() {
  let i = 0;
  return function() {
    return i++;
  };
}();
function L(i) {
  return i === null || typeof i > "u";
}
function B(i) {
  if (Array.isArray && Array.isArray(i))
    return !0;
  const t = Object.prototype.toString.call(i);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function O(i) {
  return i !== null && Object.prototype.toString.call(i) === "[object Object]";
}
const j = (i) => (typeof i == "number" || i instanceof Number) && isFinite(+i);
function et(i, t) {
  return j(i) ? i : t;
}
function A(i, t) {
  return typeof i > "u" ? t : i;
}
const dr = (i, t) => typeof i == "string" && i.endsWith("%") ? parseFloat(i) / 100 : i / t, $s = (i, t) => typeof i == "string" && i.endsWith("%") ? parseFloat(i) / 100 * t : +i;
function z(i, t, e) {
  if (i && typeof i.call == "function")
    return i.apply(e, t);
}
function F(i, t, e, n) {
  let s, o, r;
  if (B(i))
    if (o = i.length, n)
      for (s = o - 1; s >= 0; s--)
        t.call(e, i[s], s);
    else
      for (s = 0; s < o; s++)
        t.call(e, i[s], s);
  else if (O(i))
    for (r = Object.keys(i), o = r.length, s = 0; s < o; s++)
      t.call(e, i[r[s]], r[s]);
}
function $e(i, t) {
  let e, n, s, o;
  if (!i || !t || i.length !== t.length)
    return !1;
  for (e = 0, n = i.length; e < n; ++e)
    if (s = i[e], o = t[e], s.datasetIndex !== o.datasetIndex || s.index !== o.index)
      return !1;
  return !0;
}
function Ye(i) {
  if (B(i))
    return i.map(Ye);
  if (O(i)) {
    const t = /* @__PURE__ */ Object.create(null), e = Object.keys(i), n = e.length;
    let s = 0;
    for (; s < n; ++s)
      t[e[s]] = Ye(i[e[s]]);
    return t;
  }
  return i;
}
function Ys(i) {
  return ["__proto__", "prototype", "constructor"].indexOf(i) === -1;
}
function ur(i, t, e, n) {
  if (!Ys(i))
    return;
  const s = t[i], o = e[i];
  O(s) && O(o) ? de(s, o, n) : t[i] = Ye(o);
}
function de(i, t, e) {
  const n = B(t) ? t : [t], s = n.length;
  if (!O(i))
    return i;
  e = e || {};
  const o = e.merger || ur;
  for (let r = 0; r < s; ++r) {
    if (t = n[r], !O(t))
      continue;
    const a = Object.keys(t);
    for (let l = 0, c = a.length; l < c; ++l)
      o(a[l], i, t, e);
  }
  return i;
}
function re(i, t) {
  return de(i, t, { merger: fr });
}
function fr(i, t, e) {
  if (!Ys(i))
    return;
  const n = t[i], s = e[i];
  O(n) && O(s) ? re(n, s) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = Ye(s));
}
const yn = {
  "": (i) => i,
  x: (i) => i.x,
  y: (i) => i.y
};
function kt(i, t) {
  return (yn[t] || (yn[t] = gr(t)))(i);
}
function gr(i) {
  const t = pr(i);
  return (e) => {
    for (const n of t) {
      if (n === "")
        break;
      e = e && e[n];
    }
    return e;
  };
}
function pr(i) {
  const t = i.split("."), e = [];
  let n = "";
  for (const s of t)
    n += s, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (e.push(n), n = "");
  return e;
}
function Ji(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
const nt = (i) => typeof i < "u", wt = (i) => typeof i == "function", vn = (i, t) => {
  if (i.size !== t.size)
    return !1;
  for (const e of i)
    if (!t.has(e))
      return !1;
  return !0;
};
function mr(i) {
  return i.type === "mouseup" || i.type === "click" || i.type === "contextmenu";
}
const V = Math.PI, N = 2 * V, br = N + V, Ue = Number.POSITIVE_INFINITY, _r = V / 180, W = V / 2, Gt = V / 4, kn = V * 2 / 3, it = Math.log10, ht = Math.sign;
function wn(i) {
  const t = Math.round(i);
  i = ae(i, t, i / 1e3) ? t : i;
  const e = Math.pow(10, Math.floor(it(i))), n = i / e;
  return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * e;
}
function xr(i) {
  const t = [], e = Math.sqrt(i);
  let n;
  for (n = 1; n < e; n++)
    i % n === 0 && (t.push(n), t.push(i / n));
  return e === (e | 0) && t.push(e), t.sort((s, o) => s - o).pop(), t;
}
function Yt(i) {
  return !isNaN(parseFloat(i)) && isFinite(i);
}
function ae(i, t, e) {
  return Math.abs(i - t) < e;
}
function yr(i, t) {
  const e = Math.round(i);
  return e - t <= i && e + t >= i;
}
function Us(i, t, e) {
  let n, s, o;
  for (n = 0, s = i.length; n < s; n++)
    o = i[n][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));
}
function st(i) {
  return i * (V / 180);
}
function tn(i) {
  return i * (180 / V);
}
function Sn(i) {
  if (!j(i))
    return;
  let t = 1, e = 0;
  for (; Math.round(i * t) / t !== i; )
    t *= 10, e++;
  return e;
}
function Xs(i, t) {
  const e = t.x - i.x, n = t.y - i.y, s = Math.sqrt(e * e + n * n);
  let o = Math.atan2(n, e);
  return o < -0.5 * V && (o += N), {
    angle: o,
    distance: s
  };
}
function zi(i, t) {
  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));
}
function vr(i, t) {
  return (i - t + br) % N - V;
}
function J(i) {
  return (i % N + N) % N;
}
function ue(i, t, e, n) {
  const s = J(i), o = J(t), r = J(e), a = J(o - s), l = J(r - s), c = J(s - o), h = J(s - r);
  return s === o || s === r || n && o === r || a > l && c < h;
}
function X(i, t, e) {
  return Math.max(t, Math.min(e, i));
}
function kr(i) {
  return X(i, -32768, 32767);
}
function pt(i, t, e, n = 1e-6) {
  return i >= Math.min(t, e) - n && i <= Math.max(t, e) + n;
}
function en(i, t, e) {
  e = e || ((r) => i[r] < t);
  let n = i.length - 1, s = 0, o;
  for (; n - s > 1; )
    o = s + n >> 1, e(o) ? s = o : n = o;
  return { lo: s, hi: n };
}
const mt = (i, t, e, n) => en(i, e, n ? (s) => i[s][t] <= e : (s) => i[s][t] < e), wr = (i, t, e) => en(i, e, (n) => i[n][t] >= e);
function Sr(i, t, e) {
  let n = 0, s = i.length;
  for (; n < s && i[n] < t; )
    n++;
  for (; s > n && i[s - 1] > e; )
    s--;
  return n > 0 || s < i.length ? i.slice(n, s) : i;
}
const Ks = ["push", "pop", "shift", "splice", "unshift"];
function Mr(i, t) {
  if (i._chartjs) {
    i._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(i, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [t]
    }
  }), Ks.forEach((e) => {
    const n = "_onData" + Ji(e), s = i[e];
    Object.defineProperty(i, e, {
      configurable: !0,
      enumerable: !1,
      value(...o) {
        const r = s.apply(this, o);
        return i._chartjs.listeners.forEach((a) => {
          typeof a[n] == "function" && a[n](...o);
        }), r;
      }
    });
  });
}
function Mn(i, t) {
  const e = i._chartjs;
  if (!e)
    return;
  const n = e.listeners, s = n.indexOf(t);
  s !== -1 && n.splice(s, 1), !(n.length > 0) && (Ks.forEach((o) => {
    delete i[o];
  }), delete i._chartjs);
}
function qs(i) {
  const t = /* @__PURE__ */ new Set();
  let e, n;
  for (e = 0, n = i.length; e < n; ++e)
    t.add(i[e]);
  return t.size === n ? i : Array.from(t);
}
const Gs = function() {
  return typeof window > "u" ? function(i) {
    return i();
  } : window.requestAnimationFrame;
}();
function Qs(i, t, e) {
  const n = e || ((r) => Array.prototype.slice.call(r));
  let s = !1, o = [];
  return function(...r) {
    o = n(r), s || (s = !0, Gs.call(window, () => {
      s = !1, i.apply(t, o);
    }));
  };
}
function Cr(i, t) {
  let e;
  return function(...n) {
    return t ? (clearTimeout(e), e = setTimeout(i, t, n)) : i.apply(this, n), t;
  };
}
const nn = (i) => i === "start" ? "left" : i === "end" ? "right" : "center", K = (i, t, e) => i === "start" ? t : i === "end" ? e : (t + e) / 2, Er = (i, t, e, n) => i === (n ? "left" : "right") ? e : i === "center" ? (t + e) / 2 : t;
function Zs(i, t, e) {
  const n = t.length;
  let s = 0, o = n;
  if (i._sorted) {
    const { iScale: r, _parsed: a } = i, l = r.axis, { min: c, max: h, minDefined: d, maxDefined: u } = r.getUserBounds();
    d && (s = X(
      Math.min(
        mt(a, r.axis, c).lo,
        e ? n : mt(t, l, r.getPixelForValue(c)).lo
      ),
      0,
      n - 1
    )), u ? o = X(
      Math.max(
        mt(a, r.axis, h, !0).hi + 1,
        e ? 0 : mt(t, l, r.getPixelForValue(h), !0).hi + 1
      ),
      s,
      n
    ) - s : o = n - s;
  }
  return { start: s, count: o };
}
function Js(i) {
  const { xScale: t, yScale: e, _scaleRanges: n } = i, s = {
    xmin: t.min,
    xmax: t.max,
    ymin: e.min,
    ymax: e.max
  };
  if (!n)
    return i._scaleRanges = s, !0;
  const o = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== e.min || n.ymax !== e.max;
  return Object.assign(n, s), o;
}
const De = (i) => i === 0 || i === 1, Cn = (i, t, e) => -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * N / e)), En = (i, t, e) => Math.pow(2, -10 * i) * Math.sin((i - t) * N / e) + 1, le = {
  linear: (i) => i,
  easeInQuad: (i) => i * i,
  easeOutQuad: (i) => -i * (i - 2),
  easeInOutQuad: (i) => (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1),
  easeInCubic: (i) => i * i * i,
  easeOutCubic: (i) => (i -= 1) * i * i + 1,
  easeInOutCubic: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2),
  easeInQuart: (i) => i * i * i * i,
  easeOutQuart: (i) => -((i -= 1) * i * i * i - 1),
  easeInOutQuart: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2),
  easeInQuint: (i) => i * i * i * i * i,
  easeOutQuint: (i) => (i -= 1) * i * i * i * i + 1,
  easeInOutQuint: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2),
  easeInSine: (i) => -Math.cos(i * W) + 1,
  easeOutSine: (i) => Math.sin(i * W),
  easeInOutSine: (i) => -0.5 * (Math.cos(V * i) - 1),
  easeInExpo: (i) => i === 0 ? 0 : Math.pow(2, 10 * (i - 1)),
  easeOutExpo: (i) => i === 1 ? 1 : -Math.pow(2, -10 * i) + 1,
  easeInOutExpo: (i) => De(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2),
  easeInCirc: (i) => i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1),
  easeOutCirc: (i) => Math.sqrt(1 - (i -= 1) * i),
  easeInOutCirc: (i) => (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1),
  easeInElastic: (i) => De(i) ? i : Cn(i, 0.075, 0.3),
  easeOutElastic: (i) => De(i) ? i : En(i, 0.075, 0.3),
  easeInOutElastic(i) {
    return De(i) ? i : i < 0.5 ? 0.5 * Cn(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * En(i * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(i) {
    return i * i * ((1.70158 + 1) * i - 1.70158);
  },
  easeOutBack(i) {
    return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;
  },
  easeInOutBack(i) {
    let t = 1.70158;
    return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);
  },
  easeInBounce: (i) => 1 - le.easeOutBounce(1 - i),
  easeOutBounce(i) {
    return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
  },
  easeInOutBounce: (i) => i < 0.5 ? le.easeInBounce(i * 2) * 0.5 : le.easeOutBounce(i * 2 - 1) * 0.5 + 0.5
};
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
function _e(i) {
  return i + 0.5 | 0;
}
const xt = (i, t, e) => Math.max(Math.min(i, e), t);
function ie(i) {
  return xt(_e(i * 2.55), 0, 255);
}
function vt(i) {
  return xt(_e(i * 255), 0, 255);
}
function gt(i) {
  return xt(_e(i / 2.55) / 100, 0, 1);
}
function An(i) {
  return xt(_e(i * 100), 0, 100);
}
const tt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Bi = [..."0123456789ABCDEF"], Ar = (i) => Bi[i & 15], Or = (i) => Bi[(i & 240) >> 4] + Bi[i & 15], Pe = (i) => (i & 240) >> 4 === (i & 15), Dr = (i) => Pe(i.r) && Pe(i.g) && Pe(i.b) && Pe(i.a);
function Pr(i) {
  var t = i.length, e;
  return i[0] === "#" && (t === 4 || t === 5 ? e = {
    r: 255 & tt[i[1]] * 17,
    g: 255 & tt[i[2]] * 17,
    b: 255 & tt[i[3]] * 17,
    a: t === 5 ? tt[i[4]] * 17 : 255
  } : (t === 7 || t === 9) && (e = {
    r: tt[i[1]] << 4 | tt[i[2]],
    g: tt[i[3]] << 4 | tt[i[4]],
    b: tt[i[5]] << 4 | tt[i[6]],
    a: t === 9 ? tt[i[7]] << 4 | tt[i[8]] : 255
  })), e;
}
const Tr = (i, t) => i < 255 ? t(i) : "";
function Lr(i) {
  var t = Dr(i) ? Ar : Or;
  return i ? "#" + t(i.r) + t(i.g) + t(i.b) + Tr(i.a, t) : void 0;
}
const Ir = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function to(i, t, e) {
  const n = t * Math.min(e, 1 - e), s = (o, r = (o + i / 30) % 12) => e - n * Math.max(Math.min(r - 3, 9 - r, 1), -1);
  return [s(0), s(8), s(4)];
}
function Rr(i, t, e) {
  const n = (s, o = (s + i / 60) % 6) => e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);
  return [n(5), n(3), n(1)];
}
function Fr(i, t, e) {
  const n = to(i, 1, 0.5);
  let s;
  for (t + e > 1 && (s = 1 / (t + e), t *= s, e *= s), s = 0; s < 3; s++)
    n[s] *= 1 - t - e, n[s] += t;
  return n;
}
function Nr(i, t, e, n, s) {
  return i === s ? (t - e) / n + (t < e ? 6 : 0) : t === s ? (e - i) / n + 2 : (i - t) / n + 4;
}
function sn(i) {
  const e = i.r / 255, n = i.g / 255, s = i.b / 255, o = Math.max(e, n, s), r = Math.min(e, n, s), a = (o + r) / 2;
  let l, c, h;
  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = Nr(e, n, s, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function on(i, t, e, n) {
  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, n)).map(vt);
}
function rn(i, t, e) {
  return on(to, i, t, e);
}
function zr(i, t, e) {
  return on(Fr, i, t, e);
}
function Br(i, t, e) {
  return on(Rr, i, t, e);
}
function eo(i) {
  return (i % 360 + 360) % 360;
}
function Vr(i) {
  const t = Ir.exec(i);
  let e = 255, n;
  if (!t)
    return;
  t[5] !== n && (e = t[6] ? ie(+t[5]) : vt(+t[5]));
  const s = eo(+t[2]), o = +t[3] / 100, r = +t[4] / 100;
  return t[1] === "hwb" ? n = zr(s, o, r) : t[1] === "hsv" ? n = Br(s, o, r) : n = rn(s, o, r), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: e
  };
}
function Wr(i, t) {
  var e = sn(i);
  e[0] = eo(e[0] + t), e = rn(e), i.r = e[0], i.g = e[1], i.b = e[2];
}
function Hr(i) {
  if (!i)
    return;
  const t = sn(i), e = t[0], n = An(t[1]), s = An(t[2]);
  return i.a < 255 ? `hsla(${e}, ${n}%, ${s}%, ${gt(i.a)})` : `hsl(${e}, ${n}%, ${s}%)`;
}
const On = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Dn = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function jr() {
  const i = {}, t = Object.keys(Dn), e = Object.keys(On);
  let n, s, o, r, a;
  for (n = 0; n < t.length; n++) {
    for (r = a = t[n], s = 0; s < e.length; s++)
      o = e[s], a = a.replace(o, On[o]);
    o = parseInt(Dn[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];
  }
  return i;
}
let Te;
function $r(i) {
  Te || (Te = jr(), Te.transparent = [0, 0, 0, 0]);
  const t = Te[i.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const Yr = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function Ur(i) {
  const t = Yr.exec(i);
  let e = 255, n, s, o;
  if (t) {
    if (t[7] !== n) {
      const r = +t[7];
      e = t[8] ? ie(r) : xt(r * 255, 0, 255);
    }
    return n = +t[1], s = +t[3], o = +t[5], n = 255 & (t[2] ? ie(n) : xt(n, 0, 255)), s = 255 & (t[4] ? ie(s) : xt(s, 0, 255)), o = 255 & (t[6] ? ie(o) : xt(o, 0, 255)), {
      r: n,
      g: s,
      b: o,
      a: e
    };
  }
}
function Xr(i) {
  return i && (i.a < 255 ? `rgba(${i.r}, ${i.g}, ${i.b}, ${gt(i.a)})` : `rgb(${i.r}, ${i.g}, ${i.b})`);
}
const bi = (i) => i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055, Vt = (i) => i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
function Kr(i, t, e) {
  const n = Vt(gt(i.r)), s = Vt(gt(i.g)), o = Vt(gt(i.b));
  return {
    r: vt(bi(n + e * (Vt(gt(t.r)) - n))),
    g: vt(bi(s + e * (Vt(gt(t.g)) - s))),
    b: vt(bi(o + e * (Vt(gt(t.b)) - o))),
    a: i.a + e * (t.a - i.a)
  };
}
function Le(i, t, e) {
  if (i) {
    let n = sn(i);
    n[t] = Math.max(0, Math.min(n[t] + n[t] * e, t === 0 ? 360 : 1)), n = rn(n), i.r = n[0], i.g = n[1], i.b = n[2];
  }
}
function io(i, t) {
  return i && Object.assign(t || {}, i);
}
function Pn(i) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(i) ? i.length >= 3 && (t = { r: i[0], g: i[1], b: i[2], a: 255 }, i.length > 3 && (t.a = vt(i[3]))) : (t = io(i, { r: 0, g: 0, b: 0, a: 1 }), t.a = vt(t.a)), t;
}
function qr(i) {
  return i.charAt(0) === "r" ? Ur(i) : Vr(i);
}
class Xe {
  constructor(t) {
    if (t instanceof Xe)
      return t;
    const e = typeof t;
    let n;
    e === "object" ? n = Pn(t) : e === "string" && (n = Pr(t) || $r(t) || qr(t)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = io(this._rgb);
    return t && (t.a = gt(t.a)), t;
  }
  set rgb(t) {
    this._rgb = Pn(t);
  }
  rgbString() {
    return this._valid ? Xr(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? Lr(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? Hr(this._rgb) : void 0;
  }
  mix(t, e) {
    if (t) {
      const n = this.rgb, s = t.rgb;
      let o;
      const r = e === o ? 0.5 : e, a = 2 * r - 1, l = n.a - s.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      o = 1 - c, n.r = 255 & c * n.r + o * s.r + 0.5, n.g = 255 & c * n.g + o * s.g + 0.5, n.b = 255 & c * n.b + o * s.b + 0.5, n.a = r * n.a + (1 - r) * s.a, this.rgb = n;
    }
    return this;
  }
  interpolate(t, e) {
    return t && (this._rgb = Kr(this._rgb, t._rgb, e)), this;
  }
  clone() {
    return new Xe(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = vt(t), this;
  }
  clearer(t) {
    const e = this._rgb;
    return e.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, e = _e(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = e, this;
  }
  opaquer(t) {
    const e = this._rgb;
    return e.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Le(this._rgb, 2, t), this;
  }
  darken(t) {
    return Le(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Le(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Le(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return Wr(this._rgb, t), this;
  }
}
function no(i) {
  return new Xe(i);
}
function so(i) {
  if (i && typeof i == "object") {
    const t = i.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function Tn(i) {
  return so(i) ? i : no(i);
}
function _i(i) {
  return so(i) ? i : no(i).saturate(0.5).darken(0.1).hexString();
}
const Lt = /* @__PURE__ */ Object.create(null), Vi = /* @__PURE__ */ Object.create(null);
function ce(i, t) {
  if (!t)
    return i;
  const e = t.split(".");
  for (let n = 0, s = e.length; n < s; ++n) {
    const o = e[n];
    i = i[o] || (i[o] = /* @__PURE__ */ Object.create(null));
  }
  return i;
}
function xi(i, t, e) {
  return typeof t == "string" ? de(ce(i, t), e) : de(ce(i, ""), t);
}
class Gr {
  constructor(t) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (e) => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (e, n) => _i(n.backgroundColor), this.hoverBorderColor = (e, n) => _i(n.borderColor), this.hoverColor = (e, n) => _i(n.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);
  }
  set(t, e) {
    return xi(this, t, e);
  }
  get(t) {
    return ce(this, t);
  }
  describe(t, e) {
    return xi(Vi, t, e);
  }
  override(t, e) {
    return xi(Lt, t, e);
  }
  route(t, e, n, s) {
    const o = ce(this, t), r = ce(this, n), a = "_" + e;
    Object.defineProperties(o, {
      [a]: {
        value: o[e],
        writable: !0
      },
      [e]: {
        enumerable: !0,
        get() {
          const l = this[a], c = r[s];
          return O(l) ? Object.assign({}, c, l) : A(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
}
var T = new Gr({
  _scriptable: (i) => !i.startsWith("on"),
  _indexable: (i) => i !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
});
function Qr(i) {
  return !i || L(i.size) || L(i.family) ? null : (i.style ? i.style + " " : "") + (i.weight ? i.weight + " " : "") + i.size + "px " + i.family;
}
function Ke(i, t, e, n, s) {
  let o = t[s];
  return o || (o = t[s] = i.measureText(s).width, e.push(s)), o > n && (n = o), n;
}
function Zr(i, t, e, n) {
  n = n || {};
  let s = n.data = n.data || {}, o = n.garbageCollect = n.garbageCollect || [];
  n.font !== t && (s = n.data = {}, o = n.garbageCollect = [], n.font = t), i.save(), i.font = t;
  let r = 0;
  const a = e.length;
  let l, c, h, d, u;
  for (l = 0; l < a; l++)
    if (d = e[l], d != null && B(d) !== !0)
      r = Ke(i, s, o, r, d);
    else if (B(d))
      for (c = 0, h = d.length; c < h; c++)
        u = d[c], u != null && !B(u) && (r = Ke(i, s, o, r, u));
  i.restore();
  const f = o.length / 2;
  if (f > e.length) {
    for (l = 0; l < f; l++)
      delete s[o[l]];
    o.splice(0, f);
  }
  return r;
}
function Et(i, t, e) {
  const n = i.currentDevicePixelRatio, s = e !== 0 ? Math.max(e / 2, 0.5) : 0;
  return Math.round((t - s) * n) / n + s;
}
function Ln(i, t) {
  t = t || i.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore();
}
function Wi(i, t, e, n) {
  oo(i, t, e, n, null);
}
function oo(i, t, e, n, s) {
  let o, r, a, l, c, h;
  const d = t.pointStyle, u = t.rotation, f = t.radius;
  let g = (u || 0) * _r;
  if (d && typeof d == "object" && (o = d.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
    i.save(), i.translate(e, n), i.rotate(g), i.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), i.restore();
    return;
  }
  if (!(isNaN(f) || f <= 0)) {
    switch (i.beginPath(), d) {
      default:
        s ? i.ellipse(e, n, s / 2, f, 0, 0, N) : i.arc(e, n, f, 0, N), i.closePath();
        break;
      case "triangle":
        i.moveTo(e + Math.sin(g) * f, n - Math.cos(g) * f), g += kn, i.lineTo(e + Math.sin(g) * f, n - Math.cos(g) * f), g += kn, i.lineTo(e + Math.sin(g) * f, n - Math.cos(g) * f), i.closePath();
        break;
      case "rectRounded":
        c = f * 0.516, l = f - c, r = Math.cos(g + Gt) * l, a = Math.sin(g + Gt) * l, i.arc(e - r, n - a, c, g - V, g - W), i.arc(e + a, n - r, c, g - W, g), i.arc(e + r, n + a, c, g, g + W), i.arc(e - a, n + r, c, g + W, g + V), i.closePath();
        break;
      case "rect":
        if (!u) {
          l = Math.SQRT1_2 * f, h = s ? s / 2 : l, i.rect(e - h, n - l, 2 * h, 2 * l);
          break;
        }
        g += Gt;
      case "rectRot":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, n - a), i.lineTo(e + a, n - r), i.lineTo(e + r, n + a), i.lineTo(e - a, n + r), i.closePath();
        break;
      case "crossRot":
        g += Gt;
      case "cross":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, n - a), i.lineTo(e + r, n + a), i.moveTo(e + a, n - r), i.lineTo(e - a, n + r);
        break;
      case "star":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, n - a), i.lineTo(e + r, n + a), i.moveTo(e + a, n - r), i.lineTo(e - a, n + r), g += Gt, r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, n - a), i.lineTo(e + r, n + a), i.moveTo(e + a, n - r), i.lineTo(e - a, n + r);
        break;
      case "line":
        r = s ? s / 2 : Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, n - a), i.lineTo(e + r, n + a);
        break;
      case "dash":
        i.moveTo(e, n), i.lineTo(e + Math.cos(g) * f, n + Math.sin(g) * f);
        break;
    }
    i.fill(), t.borderWidth > 0 && i.stroke();
  }
}
function fe(i, t, e) {
  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;
}
function ii(i, t) {
  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();
}
function ni(i) {
  i.restore();
}
function Jr(i, t, e, n, s) {
  if (!t)
    return i.lineTo(e.x, e.y);
  if (s === "middle") {
    const o = (t.x + e.x) / 2;
    i.lineTo(o, t.y), i.lineTo(o, e.y);
  } else
    s === "after" != !!n ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);
  i.lineTo(e.x, e.y);
}
function ta(i, t, e, n) {
  if (!t)
    return i.lineTo(e.x, e.y);
  i.bezierCurveTo(
    n ? t.cp1x : t.cp2x,
    n ? t.cp1y : t.cp2y,
    n ? e.cp2x : e.cp1x,
    n ? e.cp2y : e.cp1y,
    e.x,
    e.y
  );
}
function It(i, t, e, n, s, o = {}) {
  const r = B(t) ? t : [t], a = o.strokeWidth > 0 && o.strokeColor !== "";
  let l, c;
  for (i.save(), i.font = s.string, ea(i, o), l = 0; l < r.length; ++l)
    c = r[l], a && (o.strokeColor && (i.strokeStyle = o.strokeColor), L(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, n, o.maxWidth)), i.fillText(c, e, n, o.maxWidth), ia(i, e, n, c, o), n += s.lineHeight;
  i.restore();
}
function ea(i, t) {
  t.translation && i.translate(t.translation[0], t.translation[1]), L(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);
}
function ia(i, t, e, n, s) {
  if (s.strikethrough || s.underline) {
    const o = i.measureText(n), r = t - o.actualBoundingBoxLeft, a = t + o.actualBoundingBoxRight, l = e - o.actualBoundingBoxAscent, c = e + o.actualBoundingBoxDescent, h = s.strikethrough ? (l + c) / 2 : c;
    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = s.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();
  }
}
function ge(i, t) {
  const { x: e, y: n, w: s, h: o, radius: r } = t;
  i.arc(e + r.topLeft, n + r.topLeft, r.topLeft, -W, V, !0), i.lineTo(e, n + o - r.bottomLeft), i.arc(e + r.bottomLeft, n + o - r.bottomLeft, r.bottomLeft, V, W, !0), i.lineTo(e + s - r.bottomRight, n + o), i.arc(e + s - r.bottomRight, n + o - r.bottomRight, r.bottomRight, W, 0, !0), i.lineTo(e + s, n + r.topRight), i.arc(e + s - r.topRight, n + r.topRight, r.topRight, 0, -W, !0), i.lineTo(e + r.topLeft, n);
}
const na = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/), sa = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function oa(i, t) {
  const e = ("" + i).match(na);
  if (!e || e[1] === "normal")
    return t * 1.2;
  switch (i = +e[2], e[3]) {
    case "px":
      return i;
    case "%":
      i /= 100;
      break;
  }
  return t * i;
}
const ra = (i) => +i || 0;
function an(i, t) {
  const e = {}, n = O(t), s = n ? Object.keys(t) : t, o = O(i) ? n ? (r) => A(i[r], i[t[r]]) : (r) => i[r] : () => i;
  for (const r of s)
    e[r] = ra(o(r));
  return e;
}
function ro(i) {
  return an(i, { top: "y", right: "x", bottom: "y", left: "x" });
}
function Pt(i) {
  return an(i, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function G(i) {
  const t = ro(i);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function U(i, t) {
  i = i || {}, t = t || T.font;
  let e = A(i.size, t.size);
  typeof e == "string" && (e = parseInt(e, 10));
  let n = A(i.style, t.style);
  n && !("" + n).match(sa) && (console.warn('Invalid font style specified: "' + n + '"'), n = "");
  const s = {
    family: A(i.family, t.family),
    lineHeight: oa(A(i.lineHeight, t.lineHeight), e),
    size: e,
    style: n,
    weight: A(i.weight, t.weight),
    string: ""
  };
  return s.string = Qr(s), s;
}
function ne(i, t, e, n) {
  let s = !0, o, r, a;
  for (o = 0, r = i.length; o < r; ++o)
    if (a = i[o], a !== void 0 && (t !== void 0 && typeof a == "function" && (a = a(t), s = !1), e !== void 0 && B(a) && (a = a[e % a.length], s = !1), a !== void 0))
      return n && !s && (n.cacheable = !1), a;
}
function aa(i, t, e) {
  const { min: n, max: s } = i, o = $s(t, (s - n) / 2), r = (a, l) => e && a === 0 ? 0 : a + l;
  return {
    min: r(n, -Math.abs(o)),
    max: r(s, o)
  };
}
function St(i, t) {
  return Object.assign(Object.create(i), t);
}
function ln(i, t = [""], e = i, n, s = () => i[0]) {
  nt(n) || (n = ho("_fallback", i));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: i,
    _rootScopes: e,
    _fallback: n,
    _getTarget: s,
    override: (r) => ln([r, ...i], t, e, n)
  };
  return new Proxy(o, {
    deleteProperty(r, a) {
      return delete r[a], delete r._keys, delete i[0][a], !0;
    },
    get(r, a) {
      return lo(
        r,
        a,
        () => pa(a, t, i, r)
      );
    },
    getOwnPropertyDescriptor(r, a) {
      return Reflect.getOwnPropertyDescriptor(r._scopes[0], a);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(i[0]);
    },
    has(r, a) {
      return Rn(r).includes(a);
    },
    ownKeys(r) {
      return Rn(r);
    },
    set(r, a, l) {
      const c = r._storage || (r._storage = s());
      return r[a] = c[a] = l, delete r._keys, !0;
    }
  });
}
function Ut(i, t, e, n) {
  const s = {
    _cacheable: !1,
    _proxy: i,
    _context: t,
    _subProxy: e,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: ao(i, n),
    setContext: (o) => Ut(i, o, e, n),
    override: (o) => Ut(i.override(o), t, e, n)
  };
  return new Proxy(s, {
    deleteProperty(o, r) {
      return delete o[r], delete i[r], !0;
    },
    get(o, r, a) {
      return lo(
        o,
        r,
        () => ca(o, r, a)
      );
    },
    getOwnPropertyDescriptor(o, r) {
      return o._descriptors.allKeys ? Reflect.has(i, r) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(i);
    },
    has(o, r) {
      return Reflect.has(i, r);
    },
    ownKeys() {
      return Reflect.ownKeys(i);
    },
    set(o, r, a) {
      return i[r] = a, delete o[r], !0;
    }
  });
}
function ao(i, t = { scriptable: !0, indexable: !0 }) {
  const { _scriptable: e = t.scriptable, _indexable: n = t.indexable, _allKeys: s = t.allKeys } = i;
  return {
    allKeys: s,
    scriptable: e,
    indexable: n,
    isScriptable: wt(e) ? e : () => e,
    isIndexable: wt(n) ? n : () => n
  };
}
const la = (i, t) => i ? i + Ji(t) : t, cn = (i, t) => O(t) && i !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function lo(i, t, e) {
  if (Object.prototype.hasOwnProperty.call(i, t))
    return i[t];
  const n = e();
  return i[t] = n, n;
}
function ca(i, t, e) {
  const { _proxy: n, _context: s, _subProxy: o, _descriptors: r } = i;
  let a = n[t];
  return wt(a) && r.isScriptable(t) && (a = ha(t, a, i, e)), B(a) && a.length && (a = da(t, a, i, r.isIndexable)), cn(t, a) && (a = Ut(a, s, o && o[t], r)), a;
}
function ha(i, t, e, n) {
  const { _proxy: s, _context: o, _subProxy: r, _stack: a } = e;
  if (a.has(i))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + i);
  return a.add(i), t = t(o, r || n), a.delete(i), cn(i, t) && (t = hn(s._scopes, s, i, t)), t;
}
function da(i, t, e, n) {
  const { _proxy: s, _context: o, _subProxy: r, _descriptors: a } = e;
  if (nt(o.index) && n(i))
    t = t[o.index % t.length];
  else if (O(t[0])) {
    const l = t, c = s._scopes.filter((h) => h !== l);
    t = [];
    for (const h of l) {
      const d = hn(c, s, i, h);
      t.push(Ut(d, o, r && r[i], a));
    }
  }
  return t;
}
function co(i, t, e) {
  return wt(i) ? i(t, e) : i;
}
const ua = (i, t) => i === !0 ? t : typeof i == "string" ? kt(t, i) : void 0;
function fa(i, t, e, n, s) {
  for (const o of t) {
    const r = ua(e, o);
    if (r) {
      i.add(r);
      const a = co(r._fallback, e, s);
      if (nt(a) && a !== e && a !== n)
        return a;
    } else if (r === !1 && nt(n) && e !== n)
      return null;
  }
  return !1;
}
function hn(i, t, e, n) {
  const s = t._rootScopes, o = co(t._fallback, e, n), r = [...i, ...s], a = /* @__PURE__ */ new Set();
  a.add(n);
  let l = In(a, r, e, o || e, n);
  return l === null || nt(o) && o !== e && (l = In(a, r, o, l, n), l === null) ? !1 : ln(
    Array.from(a),
    [""],
    s,
    o,
    () => ga(t, e, n)
  );
}
function In(i, t, e, n, s) {
  for (; e; )
    e = fa(i, t, e, n, s);
  return e;
}
function ga(i, t, e) {
  const n = i._getTarget();
  t in n || (n[t] = {});
  const s = n[t];
  return B(s) && O(e) ? e : s;
}
function pa(i, t, e, n) {
  let s;
  for (const o of t)
    if (s = ho(la(o, i), e), nt(s))
      return cn(i, s) ? hn(e, n, i, s) : s;
}
function ho(i, t) {
  for (const e of t) {
    if (!e)
      continue;
    const n = e[i];
    if (nt(n))
      return n;
  }
}
function Rn(i) {
  let t = i._keys;
  return t || (t = i._keys = ma(i._scopes)), t;
}
function ma(i) {
  const t = /* @__PURE__ */ new Set();
  for (const e of i)
    for (const n of Object.keys(e).filter((s) => !s.startsWith("_")))
      t.add(n);
  return Array.from(t);
}
function uo(i, t, e, n) {
  const { iScale: s } = i, { key: o = "r" } = this._parsing, r = new Array(n);
  let a, l, c, h;
  for (a = 0, l = n; a < l; ++a)
    c = a + e, h = t[c], r[a] = {
      r: s.parse(kt(h, o), c)
    };
  return r;
}
const ba = Number.EPSILON || 1e-14, Xt = (i, t) => t < i.length && !i[t].skip && i[t], fo = (i) => i === "x" ? "y" : "x";
function _a(i, t, e, n) {
  const s = i.skip ? t : i, o = t, r = e.skip ? t : e, a = zi(o, s), l = zi(r, o);
  let c = a / (a + l), h = l / (a + l);
  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;
  const d = n * c, u = n * h;
  return {
    previous: {
      x: o.x - d * (r.x - s.x),
      y: o.y - d * (r.y - s.y)
    },
    next: {
      x: o.x + u * (r.x - s.x),
      y: o.y + u * (r.y - s.y)
    }
  };
}
function xa(i, t, e) {
  const n = i.length;
  let s, o, r, a, l, c = Xt(i, 0);
  for (let h = 0; h < n - 1; ++h)
    if (l = c, c = Xt(i, h + 1), !(!l || !c)) {
      if (ae(t[h], 0, ba)) {
        e[h] = e[h + 1] = 0;
        continue;
      }
      s = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(s, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = s * r * t[h], e[h + 1] = o * r * t[h]);
    }
}
function ya(i, t, e = "x") {
  const n = fo(e), s = i.length;
  let o, r, a, l = Xt(i, 0);
  for (let c = 0; c < s; ++c) {
    if (r = a, a = l, l = Xt(i, c + 1), !a)
      continue;
    const h = a[e], d = a[n];
    r && (o = (h - r[e]) / 3, a[`cp1${e}`] = h - o, a[`cp1${n}`] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[`cp2${e}`] = h + o, a[`cp2${n}`] = d + o * t[c]);
  }
}
function va(i, t = "x") {
  const e = fo(t), n = i.length, s = Array(n).fill(0), o = Array(n);
  let r, a, l, c = Xt(i, 0);
  for (r = 0; r < n; ++r)
    if (a = l, l = c, c = Xt(i, r + 1), !!l) {
      if (c) {
        const h = c[t] - l[t];
        s[r] = h !== 0 ? (c[e] - l[e]) / h : 0;
      }
      o[r] = a ? c ? ht(s[r - 1]) !== ht(s[r]) ? 0 : (s[r - 1] + s[r]) / 2 : s[r - 1] : s[r];
    }
  xa(i, s, o), ya(i, o, t);
}
function Ie(i, t, e) {
  return Math.max(Math.min(i, e), t);
}
function ka(i, t) {
  let e, n, s, o, r, a = fe(i[0], t);
  for (e = 0, n = i.length; e < n; ++e)
    r = o, o = a, a = e < n - 1 && fe(i[e + 1], t), o && (s = i[e], r && (s.cp1x = Ie(s.cp1x, t.left, t.right), s.cp1y = Ie(s.cp1y, t.top, t.bottom)), a && (s.cp2x = Ie(s.cp2x, t.left, t.right), s.cp2y = Ie(s.cp2y, t.top, t.bottom)));
}
function wa(i, t, e, n, s) {
  let o, r, a, l;
  if (t.spanGaps && (i = i.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    va(i, s);
  else {
    let c = n ? i[i.length - 1] : i[0];
    for (o = 0, r = i.length; o < r; ++o)
      a = i[o], l = _a(
        c,
        a,
        i[Math.min(o + 1, r - (n ? 0 : 1)) % r],
        t.tension
      ), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  t.capBezierPoints && ka(i, e);
}
function go() {
  return typeof window < "u" && typeof document < "u";
}
function dn(i) {
  let t = i.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function qe(i, t, e) {
  let n;
  return typeof i == "string" ? (n = parseInt(i, 10), i.indexOf("%") !== -1 && (n = n / 100 * t.parentNode[e])) : n = i, n;
}
const si = (i) => window.getComputedStyle(i, null);
function Sa(i, t) {
  return si(i).getPropertyValue(t);
}
const Ma = ["top", "right", "bottom", "left"];
function Tt(i, t, e) {
  const n = {};
  e = e ? "-" + e : "";
  for (let s = 0; s < 4; s++) {
    const o = Ma[s];
    n[o] = parseFloat(i[t + "-" + o + e]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const Ca = (i, t, e) => (i > 0 || t > 0) && (!e || !e.shadowRoot);
function Ea(i, t) {
  const e = i.touches, n = e && e.length ? e[0] : i, { offsetX: s, offsetY: o } = n;
  let r = !1, a, l;
  if (Ca(s, o, i.target))
    a = s, l = o;
  else {
    const c = t.getBoundingClientRect();
    a = n.clientX - c.left, l = n.clientY - c.top, r = !0;
  }
  return { x: a, y: l, box: r };
}
function Ot(i, t) {
  if ("native" in i)
    return i;
  const { canvas: e, currentDevicePixelRatio: n } = t, s = si(e), o = s.boxSizing === "border-box", r = Tt(s, "padding"), a = Tt(s, "border", "width"), { x: l, y: c, box: h } = Ea(i, e), d = r.left + (h && a.left), u = r.top + (h && a.top);
  let { width: f, height: g } = t;
  return o && (f -= r.width + a.width, g -= r.height + a.height), {
    x: Math.round((l - d) / f * e.width / n),
    y: Math.round((c - u) / g * e.height / n)
  };
}
function Aa(i, t, e) {
  let n, s;
  if (t === void 0 || e === void 0) {
    const o = dn(i);
    if (!o)
      t = i.clientWidth, e = i.clientHeight;
    else {
      const r = o.getBoundingClientRect(), a = si(o), l = Tt(a, "border", "width"), c = Tt(a, "padding");
      t = r.width - c.width - l.width, e = r.height - c.height - l.height, n = qe(a.maxWidth, o, "clientWidth"), s = qe(a.maxHeight, o, "clientHeight");
    }
  }
  return {
    width: t,
    height: e,
    maxWidth: n || Ue,
    maxHeight: s || Ue
  };
}
const yi = (i) => Math.round(i * 10) / 10;
function Oa(i, t, e, n) {
  const s = si(i), o = Tt(s, "margin"), r = qe(s.maxWidth, i, "clientWidth") || Ue, a = qe(s.maxHeight, i, "clientHeight") || Ue, l = Aa(i, t, e);
  let { width: c, height: h } = l;
  if (s.boxSizing === "content-box") {
    const d = Tt(s, "border", "width"), u = Tt(s, "padding");
    c -= u.width + d.width, h -= u.height + d.height;
  }
  return c = Math.max(0, c - o.width), h = Math.max(0, n ? Math.floor(c / n) : h - o.height), c = yi(Math.min(c, r, l.maxWidth)), h = yi(Math.min(h, a, l.maxHeight)), c && !h && (h = yi(c / 2)), {
    width: c,
    height: h
  };
}
function Fn(i, t, e) {
  const n = t || 1, s = Math.floor(i.height * n), o = Math.floor(i.width * n);
  i.height = s / n, i.width = o / n;
  const r = i.canvas;
  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = `${i.height}px`, r.style.width = `${i.width}px`), i.currentDevicePixelRatio !== n || r.height !== s || r.width !== o ? (i.currentDevicePixelRatio = n, r.height = s, r.width = o, i.ctx.setTransform(n, 0, 0, n, 0, 0), !0) : !1;
}
const Da = function() {
  let i = !1;
  try {
    const t = {
      get passive() {
        return i = !0, !1;
      }
    };
    window.addEventListener("test", null, t), window.removeEventListener("test", null, t);
  } catch {
  }
  return i;
}();
function Nn(i, t) {
  const e = Sa(i, t), n = e && e.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function Dt(i, t, e, n) {
  return {
    x: i.x + e * (t.x - i.x),
    y: i.y + e * (t.y - i.y)
  };
}
function Pa(i, t, e, n) {
  return {
    x: i.x + e * (t.x - i.x),
    y: n === "middle" ? e < 0.5 ? i.y : t.y : n === "after" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y
  };
}
function Ta(i, t, e, n) {
  const s = { x: i.cp2x, y: i.cp2y }, o = { x: t.cp1x, y: t.cp1y }, r = Dt(i, s, e), a = Dt(s, o, e), l = Dt(o, t, e), c = Dt(r, a, e), h = Dt(a, l, e);
  return Dt(c, h, e);
}
const zn = /* @__PURE__ */ new Map();
function La(i, t) {
  t = t || {};
  const e = i + JSON.stringify(t);
  let n = zn.get(e);
  return n || (n = new Intl.NumberFormat(i, t), zn.set(e, n)), n;
}
function xe(i, t, e) {
  return La(t, e).format(i);
}
const Ia = function(i, t) {
  return {
    x(e) {
      return i + i + t - e;
    },
    setWidth(e) {
      t = e;
    },
    textAlign(e) {
      return e === "center" ? e : e === "right" ? "left" : "right";
    },
    xPlus(e, n) {
      return e - n;
    },
    leftForLtr(e, n) {
      return e - n;
    }
  };
}, Ra = function() {
  return {
    x(i) {
      return i;
    },
    setWidth(i) {
    },
    textAlign(i) {
      return i;
    },
    xPlus(i, t) {
      return i + t;
    },
    leftForLtr(i, t) {
      return i;
    }
  };
};
function jt(i, t, e) {
  return i ? Ia(t, e) : Ra();
}
function po(i, t) {
  let e, n;
  (t === "ltr" || t === "rtl") && (e = i.canvas.style, n = [
    e.getPropertyValue("direction"),
    e.getPropertyPriority("direction")
  ], e.setProperty("direction", t, "important"), i.prevTextDirection = n);
}
function mo(i, t) {
  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty("direction", t[0], t[1]));
}
function bo(i) {
  return i === "angle" ? {
    between: ue,
    compare: vr,
    normalize: J
  } : {
    between: pt,
    compare: (t, e) => t - e,
    normalize: (t) => t
  };
}
function Bn({ start: i, end: t, count: e, loop: n, style: s }) {
  return {
    start: i % e,
    end: t % e,
    loop: n && (t - i + 1) % e === 0,
    style: s
  };
}
function Fa(i, t, e) {
  const { property: n, start: s, end: o } = e, { between: r, normalize: a } = bo(n), l = t.length;
  let { start: c, end: h, loop: d } = i, u, f;
  if (d) {
    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][n]), s, o); ++u)
      c--, h--;
    c %= l, h %= l;
  }
  return h < c && (h += l), { start: c, end: h, loop: d, style: i.style };
}
function _o(i, t, e) {
  if (!e)
    return [i];
  const { property: n, start: s, end: o } = e, r = t.length, { compare: a, between: l, normalize: c } = bo(n), { start: h, end: d, loop: u, style: f } = Fa(i, t, e), g = [];
  let p = !1, m = null, b, _, v;
  const y = () => l(s, v, b) && a(s, v) !== 0, x = () => a(o, b) === 0 || l(o, v, b), k = () => p || y(), w = () => !p || x();
  for (let M = h, S = h; M <= d; ++M)
    _ = t[M % r], !_.skip && (b = c(_[n]), b !== v && (p = l(b, s, o), m === null && k() && (m = a(b, s) === 0 ? M : S), m !== null && w() && (g.push(Bn({ start: m, end: M, loop: u, count: r, style: f })), m = null), S = M, v = b));
  return m !== null && g.push(Bn({ start: m, end: d, loop: u, count: r, style: f })), g;
}
function xo(i, t) {
  const e = [], n = i.segments;
  for (let s = 0; s < n.length; s++) {
    const o = _o(n[s], i.points, t);
    o.length && e.push(...o);
  }
  return e;
}
function Na(i, t, e, n) {
  let s = 0, o = t - 1;
  if (e && !n)
    for (; s < t && !i[s].skip; )
      s++;
  for (; s < t && i[s].skip; )
    s++;
  for (s %= t, e && (o += s); o > s && i[o % t].skip; )
    o--;
  return o %= t, { start: s, end: o };
}
function za(i, t, e, n) {
  const s = i.length, o = [];
  let r = t, a = i[t], l;
  for (l = t + 1; l <= e; ++l) {
    const c = i[l % s];
    c.skip || c.stop ? a.skip || (n = !1, o.push({ start: t % s, end: (l - 1) % s, loop: n }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;
  }
  return r !== null && o.push({ start: t % s, end: r % s, loop: n }), o;
}
function Ba(i, t) {
  const e = i.points, n = i.options.spanGaps, s = e.length;
  if (!s)
    return [];
  const o = !!i._loop, { start: r, end: a } = Na(e, s, o, n);
  if (n === !0)
    return Vn(i, [{ start: r, end: a, loop: o }], e, t);
  const l = a < r ? a + s : a, c = !!i._fullLoop && r === 0 && a === s - 1;
  return Vn(i, za(e, r, l, c), e, t);
}
function Vn(i, t, e, n) {
  return !n || !n.setContext || !e ? t : Va(i, t, e, n);
}
function Va(i, t, e, n) {
  const s = i._chart.getContext(), o = Wn(i.options), { _datasetIndex: r, options: { spanGaps: a } } = i, l = e.length, c = [];
  let h = o, d = t[0].start, u = d;
  function f(g, p, m, b) {
    const _ = a ? -1 : 1;
    if (g !== p) {
      for (g += l; e[g % l].skip; )
        g -= _;
      for (; e[p % l].skip; )
        p += _;
      g % l !== p % l && (c.push({ start: g % l, end: p % l, loop: m, style: b }), h = b, d = p % l);
    }
  }
  for (const g of t) {
    d = a ? d : g.start;
    let p = e[d % l], m;
    for (u = d + 1; u <= g.end; u++) {
      const b = e[u % l];
      m = Wn(n.setContext(St(s, {
        type: "segment",
        p0: p,
        p1: b,
        p0DataIndex: (u - 1) % l,
        p1DataIndex: u % l,
        datasetIndex: r
      }))), Wa(m, h) && f(d, u - 1, g.loop, h), p = b, h = m;
    }
    d < u - 1 && f(d, u - 1, g.loop, h);
  }
  return c;
}
function Wn(i) {
  return {
    backgroundColor: i.backgroundColor,
    borderCapStyle: i.borderCapStyle,
    borderDash: i.borderDash,
    borderDashOffset: i.borderDashOffset,
    borderJoinStyle: i.borderJoinStyle,
    borderWidth: i.borderWidth,
    borderColor: i.borderColor
  };
}
function Wa(i, t) {
  return t && JSON.stringify(i) !== JSON.stringify(t);
}
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
class Ha {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, e, n, s) {
    const o = e.listeners[s], r = e.duration;
    o.forEach((a) => a({
      chart: t,
      initial: e.initial,
      numSteps: r,
      currentStep: Math.min(n - e.start, r)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Gs.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let e = 0;
    this._charts.forEach((n, s) => {
      if (!n.running || !n.items.length)
        return;
      const o = n.items;
      let r = o.length - 1, a = !1, l;
      for (; r >= 0; --r)
        l = o[r], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());
      a && (s.draw(), this._notify(s, n, t, "progress")), o.length || (n.running = !1, this._notify(s, n, t, "complete"), n.initial = !1), e += o.length;
    }), this._lastDate = t, e === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const e = this._charts;
    let n = e.get(t);
    return n || (n = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, e.set(t, n)), n;
  }
  listen(t, e, n) {
    this._getAnims(t).listeners[e].push(n);
  }
  add(t, e) {
    !e || !e.length || this._getAnims(t).items.push(...e);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const e = this._charts.get(t);
    e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((n, s) => Math.max(n, s._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const e = this._charts.get(t);
    return !(!e || !e.running || !e.items.length);
  }
  stop(t) {
    const e = this._charts.get(t);
    if (!e || !e.items.length)
      return;
    const n = e.items;
    let s = n.length - 1;
    for (; s >= 0; --s)
      n[s].cancel();
    e.items = [], this._notify(t, e, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var ut = new Ha();
const Hn = "transparent", ja = {
  boolean(i, t, e) {
    return e > 0.5 ? t : i;
  },
  color(i, t, e) {
    const n = Tn(i || Hn), s = n.valid && Tn(t || Hn);
    return s && s.valid ? s.mix(n, e).hexString() : t;
  },
  number(i, t, e) {
    return i + (t - i) * e;
  }
};
class $a {
  constructor(t, e, n, s) {
    const o = e[n];
    s = ne([t.to, s, o, t.from]);
    const r = ne([t.from, o, s]);
    this._active = !0, this._fn = t.fn || ja[t.type || typeof r], this._easing = le[t.easing] || le.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = n, this._from = r, this._to = s, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, e, n) {
    if (this._active) {
      this._notify(!1);
      const s = this._target[this._prop], o = n - this._start, r = this._duration - o;
      this._start = n, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = ne([t.to, e, s, t.from]), this._from = ne([t.from, s, e]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const e = t - this._start, n = this._duration, s = this._prop, o = this._from, r = this._loop, a = this._to;
    let l;
    if (this._active = o !== a && (r || e < n), !this._active) {
      this._target[s] = a, this._notify(!0);
      return;
    }
    if (e < 0) {
      this._target[s] = o;
      return;
    }
    l = e / n % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(o, a, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((e, n) => {
      t.push({ res: e, rej: n });
    });
  }
  _notify(t) {
    const e = t ? "res" : "rej", n = this._promises || [];
    for (let s = 0; s < n.length; s++)
      n[s][e]();
  }
}
const Ya = ["x", "y", "borderWidth", "radius", "tension"], Ua = ["color", "borderColor", "backgroundColor"];
T.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
const Xa = Object.keys(T.animation);
T.describe("animation", {
  _fallback: !1,
  _indexable: !1,
  _scriptable: (i) => i !== "onProgress" && i !== "onComplete" && i !== "fn"
});
T.set("animations", {
  colors: {
    type: "color",
    properties: Ua
  },
  numbers: {
    type: "number",
    properties: Ya
  }
});
T.describe("animations", {
  _fallback: "animation"
});
T.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (i) => i | 0
      }
    }
  }
});
class yo {
  constructor(t, e) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);
  }
  configure(t) {
    if (!O(t))
      return;
    const e = this._properties;
    Object.getOwnPropertyNames(t).forEach((n) => {
      const s = t[n];
      if (!O(s))
        return;
      const o = {};
      for (const r of Xa)
        o[r] = s[r];
      (B(s.properties) && s.properties || [n]).forEach((r) => {
        (r === n || !e.has(r)) && e.set(r, o);
      });
    });
  }
  _animateOptions(t, e) {
    const n = e.options, s = qa(t, n);
    if (!s)
      return [];
    const o = this._createAnimations(s, n);
    return n.$shared && Ka(t.options.$animations, n).then(() => {
      t.options = n;
    }, () => {
    }), o;
  }
  _createAnimations(t, e) {
    const n = this._properties, s = [], o = t.$animations || (t.$animations = {}), r = Object.keys(e), a = Date.now();
    let l;
    for (l = r.length - 1; l >= 0; --l) {
      const c = r[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        s.push(...this._animateOptions(t, e));
        continue;
      }
      const h = e[c];
      let d = o[c];
      const u = n.get(c);
      if (d)
        if (u && d.active()) {
          d.update(u, h, a);
          continue;
        } else
          d.cancel();
      if (!u || !u.duration) {
        t[c] = h;
        continue;
      }
      o[c] = d = new $a(u, t, c, h), s.push(d);
    }
    return s;
  }
  update(t, e) {
    if (this._properties.size === 0) {
      Object.assign(t, e);
      return;
    }
    const n = this._createAnimations(t, e);
    if (n.length)
      return ut.add(this._chart, n), !0;
  }
}
function Ka(i, t) {
  const e = [], n = Object.keys(t);
  for (let s = 0; s < n.length; s++) {
    const o = i[n[s]];
    o && o.active() && e.push(o.wait());
  }
  return Promise.all(e);
}
function qa(i, t) {
  if (!t)
    return;
  let e = i.options;
  if (!e) {
    i.options = t;
    return;
  }
  return e.$shared && (i.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e;
}
function jn(i, t) {
  const e = i && i.options || {}, n = e.reverse, s = e.min === void 0 ? t : 0, o = e.max === void 0 ? t : 0;
  return {
    start: n ? o : s,
    end: n ? s : o
  };
}
function Ga(i, t, e) {
  if (e === !1)
    return !1;
  const n = jn(i, e), s = jn(t, e);
  return {
    top: s.end,
    right: n.end,
    bottom: s.start,
    left: n.start
  };
}
function Qa(i) {
  let t, e, n, s;
  return O(i) ? (t = i.top, e = i.right, n = i.bottom, s = i.left) : t = e = n = s = i, {
    top: t,
    right: e,
    bottom: n,
    left: s,
    disabled: i === !1
  };
}
function vo(i, t) {
  const e = [], n = i._getSortedDatasetMetas(t);
  let s, o;
  for (s = 0, o = n.length; s < o; ++s)
    e.push(n[s].index);
  return e;
}
function $n(i, t, e, n = {}) {
  const s = i.keys, o = n.mode === "single";
  let r, a, l, c;
  if (t !== null) {
    for (r = 0, a = s.length; r < a; ++r) {
      if (l = +s[r], l === e) {
        if (n.all)
          continue;
        break;
      }
      c = i.values[l], j(c) && (o || t === 0 || ht(t) === ht(c)) && (t += c);
    }
    return t;
  }
}
function Za(i) {
  const t = Object.keys(i), e = new Array(t.length);
  let n, s, o;
  for (n = 0, s = t.length; n < s; ++n)
    o = t[n], e[n] = {
      x: o,
      y: i[o]
    };
  return e;
}
function Yn(i, t) {
  const e = i && i.options.stacked;
  return e || e === void 0 && t.stack !== void 0;
}
function Ja(i, t, e) {
  return `${i.id}.${t.id}.${e.stack || e.type}`;
}
function tl(i) {
  const { min: t, max: e, minDefined: n, maxDefined: s } = i.getUserBounds();
  return {
    min: n ? t : Number.NEGATIVE_INFINITY,
    max: s ? e : Number.POSITIVE_INFINITY
  };
}
function el(i, t, e) {
  const n = i[t] || (i[t] = {});
  return n[e] || (n[e] = {});
}
function Un(i, t, e, n) {
  for (const s of t.getMatchingVisibleMetas(n).reverse()) {
    const o = i[s.index];
    if (e && o > 0 || !e && o < 0)
      return s.index;
  }
  return null;
}
function Xn(i, t) {
  const { chart: e, _cachedMeta: n } = i, s = e._stacks || (e._stacks = {}), { iScale: o, vScale: r, index: a } = n, l = o.axis, c = r.axis, h = Ja(o, r, n), d = t.length;
  let u;
  for (let f = 0; f < d; ++f) {
    const g = t[f], { [l]: p, [c]: m } = g, b = g._stacks || (g._stacks = {});
    u = b[c] = el(s, h, p), u[a] = m, u._top = Un(u, r, !0, n.type), u._bottom = Un(u, r, !1, n.type);
  }
}
function vi(i, t) {
  const e = i.scales;
  return Object.keys(e).filter((n) => e[n].axis === t).shift();
}
function il(i, t) {
  return St(
    i,
    {
      active: !1,
      dataset: void 0,
      datasetIndex: t,
      index: t,
      mode: "default",
      type: "dataset"
    }
  );
}
function nl(i, t, e) {
  return St(i, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: e,
    index: t,
    mode: "default",
    type: "data"
  });
}
function Qt(i, t) {
  const e = i.controller.index, n = i.vScale && i.vScale.axis;
  if (n) {
    t = t || i._parsed;
    for (const s of t) {
      const o = s._stacks;
      if (!o || o[n] === void 0 || o[n][e] === void 0)
        return;
      delete o[n][e];
    }
  }
}
const ki = (i) => i === "reset" || i === "none", Kn = (i, t) => t ? i : Object.assign({}, i), sl = (i, t, e) => i && !t.hidden && t._stacked && { keys: vo(e, !0), values: null };
class ot {
  constructor(t, e) {
    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Yn(t.vScale, t), this.addElements();
  }
  updateIndex(t) {
    this.index !== t && Qt(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, e = this._cachedMeta, n = this.getDataset(), s = (d, u, f, g) => d === "x" ? u : d === "r" ? g : f, o = e.xAxisID = A(n.xAxisID, vi(t, "x")), r = e.yAxisID = A(n.yAxisID, vi(t, "y")), a = e.rAxisID = A(n.rAxisID, vi(t, "r")), l = e.indexAxis, c = e.iAxisID = s(l, o, r, a), h = e.vAxisID = s(l, r, o, a);
    e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const e = this._cachedMeta;
    return t === e.iScale ? e.vScale : e.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Mn(this._data, this), t._stacked && Qt(t);
  }
  _dataCheck() {
    const t = this.getDataset(), e = t.data || (t.data = []), n = this._data;
    if (O(e))
      this._data = Za(e);
    else if (n !== e) {
      if (n) {
        Mn(n, this);
        const s = this._cachedMeta;
        Qt(s), s._parsed = [];
      }
      e && Object.isExtensible(e) && Mr(e, this), this._syncList = [], this._data = e;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const e = this._cachedMeta, n = this.getDataset();
    let s = !1;
    this._dataCheck();
    const o = e._stacked;
    e._stacked = Yn(e.vScale, e), e.stack !== n.stack && (s = !0, Qt(e), e.stack = n.stack), this._resyncElements(t), (s || o !== e._stacked) && Xn(this, e._parsed);
  }
  configure() {
    const t = this.chart.config, e = t.datasetScopeKeys(this._type), n = t.getOptionScopes(this.getDataset(), e, !0);
    this.options = t.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, e) {
    const { _cachedMeta: n, _data: s } = this, { iScale: o, _stacked: r } = n, a = o.axis;
    let l = t === 0 && e === s.length ? !0 : n._sorted, c = t > 0 && n._parsed[t - 1], h, d, u;
    if (this._parsing === !1)
      n._parsed = s, n._sorted = !0, u = s;
    else {
      B(s[t]) ? u = this.parseArrayData(n, s, t, e) : O(s[t]) ? u = this.parseObjectData(n, s, t, e) : u = this.parsePrimitiveData(n, s, t, e);
      const f = () => d[a] === null || c && d[a] < c[a];
      for (h = 0; h < e; ++h)
        n._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);
      n._sorted = l;
    }
    r && Xn(this, u);
  }
  parsePrimitiveData(t, e, n, s) {
    const { iScale: o, vScale: r } = t, a = o.axis, l = r.axis, c = o.getLabels(), h = o === r, d = new Array(s);
    let u, f, g;
    for (u = 0, f = s; u < f; ++u)
      g = u + n, d[u] = {
        [a]: h || o.parse(c[g], g),
        [l]: r.parse(e[g], g)
      };
    return d;
  }
  parseArrayData(t, e, n, s) {
    const { xScale: o, yScale: r } = t, a = new Array(s);
    let l, c, h, d;
    for (l = 0, c = s; l < c; ++l)
      h = l + n, d = e[h], a[l] = {
        x: o.parse(d[0], h),
        y: r.parse(d[1], h)
      };
    return a;
  }
  parseObjectData(t, e, n, s) {
    const { xScale: o, yScale: r } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(s);
    let h, d, u, f;
    for (h = 0, d = s; h < d; ++h)
      u = h + n, f = e[u], c[h] = {
        x: o.parse(kt(f, a), u),
        y: r.parse(kt(f, l), u)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, e, n) {
    const s = this.chart, o = this._cachedMeta, r = e[t.axis], a = {
      keys: vo(s, !0),
      values: e._stacks[t.axis]
    };
    return $n(a, r, o.index, { mode: n });
  }
  updateRangeFromParsed(t, e, n, s) {
    const o = n[e.axis];
    let r = o === null ? NaN : o;
    const a = s && n._stacks[e.axis];
    s && a && (s.values = a, r = $n(s, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);
  }
  getMinMax(t, e) {
    const n = this._cachedMeta, s = n._parsed, o = n._sorted && t === n.iScale, r = s.length, a = this._getOtherScale(t), l = sl(e, n, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h, max: d } = tl(a);
    let u, f;
    function g() {
      f = s[u];
      const p = f[a.axis];
      return !j(f[t.axis]) || h > p || d < p;
    }
    for (u = 0; u < r && !(!g() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u)
      ;
    if (o) {
      for (u = r - 1; u >= 0; --u)
        if (!g()) {
          this.updateRangeFromParsed(c, t, f, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const e = this._cachedMeta._parsed, n = [];
    let s, o, r;
    for (s = 0, o = e.length; s < o; ++s)
      r = e[s][t.axis], j(r) && n.push(r);
    return n;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, n = e.iScale, s = e.vScale, o = this.getParsed(t);
    return {
      label: n ? "" + n.getLabelForValue(o[n.axis]) : "",
      value: s ? "" + s.getLabelForValue(o[s.axis]) : ""
    };
  }
  _update(t) {
    const e = this._cachedMeta;
    this.update(t || "default"), e._clip = Qa(A(this.options.clip, Ga(e.xScale, e.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, e = this.chart, n = this._cachedMeta, s = n.data || [], o = e.chartArea, r = [], a = this._drawStart || 0, l = this._drawCount || s.length - a, c = this.options.drawActiveElementsOnTop;
    let h;
    for (n.dataset && n.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {
      const d = s[h];
      d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));
    }
    for (h = 0; h < r.length; ++h)
      r[h].draw(t, o);
  }
  getStyle(t, e) {
    const n = e ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n);
  }
  getContext(t, e, n) {
    const s = this.getDataset();
    let o;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const r = this._cachedMeta.data[t];
      o = r.$context || (r.$context = nl(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = s.data[t], o.index = o.dataIndex = t;
    } else
      o = this.$context || (this.$context = il(this.chart.getContext(), this.index)), o.dataset = s, o.index = o.datasetIndex = this.index;
    return o.active = !!e, o.mode = n, o;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, e) {
    return this._resolveElementOptions(this.dataElementType.id, e, t);
  }
  _resolveElementOptions(t, e = "default", n) {
    const s = e === "active", o = this._cachedDataOpts, r = t + "-" + e, a = o[r], l = this.enableOptionSharing && nt(n);
    if (a)
      return Kn(a, l);
    const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), d = s ? [`${t}Hover`, "hover", t, ""] : [t, ""], u = c.getOptionScopes(this.getDataset(), h), f = Object.keys(T.elements[t]), g = () => this.getContext(n, s), p = c.resolveNamedOptions(u, f, g, d);
    return p.$shared && (p.$shared = l, o[r] = Object.freeze(Kn(p, l))), p;
  }
  _resolveAnimations(t, e, n) {
    const s = this.chart, o = this._cachedDataOpts, r = `animation-${e}`, a = o[r];
    if (a)
      return a;
    let l;
    if (s.options.animation !== !1) {
      const h = this.chart.config, d = h.datasetAnimationScopeKeys(this._type, e), u = h.getOptionScopes(this.getDataset(), d);
      l = h.createResolver(u, this.getContext(t, n, e));
    }
    const c = new yo(s, l && l.animations);
    return l && l._cacheable && (o[r] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, e) {
    return !e || ki(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, e) {
    const n = this.resolveDataElementOptions(t, e), s = this._sharedOptions, o = this.getSharedOptions(n), r = this.includeOptions(e, o) || o !== s;
    return this.updateSharedOptions(o, e, n), { sharedOptions: o, includeOptions: r };
  }
  updateElement(t, e, n, s) {
    ki(s) ? Object.assign(t, n) : this._resolveAnimations(e, s).update(t, n);
  }
  updateSharedOptions(t, e, n) {
    t && !ki(e) && this._resolveAnimations(void 0, e).update(t, n);
  }
  _setStyle(t, e, n, s) {
    t.active = s;
    const o = this.getStyle(e, s);
    this._resolveAnimations(e, n, s).update(t, {
      options: !s && this.getSharedOptions(o) || o
    });
  }
  removeHoverStyle(t, e, n) {
    this._setStyle(t, n, "active", !1);
  }
  setHoverStyle(t, e, n) {
    this._setStyle(t, n, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const e = this._data, n = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const s = n.length, o = e.length, r = Math.min(o, s);
    r && this.parse(0, r), o > s ? this._insertElements(s, o - s, t) : o < s && this._removeElements(o, s - o);
  }
  _insertElements(t, e, n = !0) {
    const s = this._cachedMeta, o = s.data, r = t + e;
    let a;
    const l = (c) => {
      for (c.length += e, a = c.length - 1; a >= r; a--)
        c[a] = c[a - e];
    };
    for (l(o), a = t; a < r; ++a)
      o[a] = new this.dataElementType();
    this._parsing && l(s._parsed), this.parse(t, e), n && this.updateElements(o, t, e, "reset");
  }
  updateElements(t, e, n, s) {
  }
  _removeElements(t, e) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const s = n._parsed.splice(t, e);
      n._stacked && Qt(n, s);
    }
    n.data.splice(t, e);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [e, n, s] = t;
      this[e](n, s);
    }
    this.chart._dataChanges.push([this.index, ...t]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - t, t]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(t, e) {
    e && this._sync(["_removeElements", t, e]);
    const n = arguments.length - 2;
    n && this._sync(["_insertElements", t, n]);
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
}
ot.defaults = {};
ot.prototype.datasetElementType = null;
ot.prototype.dataElementType = null;
function ol(i, t) {
  if (!i._cache.$bar) {
    const e = i.getMatchingVisibleMetas(t);
    let n = [];
    for (let s = 0, o = e.length; s < o; s++)
      n = n.concat(e[s].controller.getAllParsedValues(i));
    i._cache.$bar = qs(n.sort((s, o) => s - o));
  }
  return i._cache.$bar;
}
function rl(i) {
  const t = i.iScale, e = ol(t, i.type);
  let n = t._length, s, o, r, a;
  const l = () => {
    r === 32767 || r === -32768 || (nt(a) && (n = Math.min(n, Math.abs(r - a) || n)), a = r);
  };
  for (s = 0, o = e.length; s < o; ++s)
    r = t.getPixelForValue(e[s]), l();
  for (a = void 0, s = 0, o = t.ticks.length; s < o; ++s)
    r = t.getPixelForTick(s), l();
  return n;
}
function al(i, t, e, n) {
  const s = e.barThickness;
  let o, r;
  return L(s) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = s * n, r = 1), {
    chunk: o / n,
    ratio: r,
    start: t.pixels[i] - o / 2
  };
}
function ll(i, t, e, n) {
  const s = t.pixels, o = s[i];
  let r = i > 0 ? s[i - 1] : null, a = i < s.length - 1 ? s[i + 1] : null;
  const l = e.categoryPercentage;
  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);
  const c = o - (o - Math.min(r, a)) / 2 * l;
  return {
    chunk: Math.abs(a - r) / 2 * l / n,
    ratio: e.barPercentage,
    start: c
  };
}
function cl(i, t, e, n) {
  const s = e.parse(i[0], n), o = e.parse(i[1], n), r = Math.min(s, o), a = Math.max(s, o);
  let l = r, c = a;
  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {
    barStart: l,
    barEnd: c,
    start: s,
    end: o,
    min: r,
    max: a
  };
}
function ko(i, t, e, n) {
  return B(i) ? cl(i, t, e, n) : t[e.axis] = e.parse(i, n), t;
}
function qn(i, t, e, n) {
  const s = i.iScale, o = i.vScale, r = s.getLabels(), a = s === o, l = [];
  let c, h, d, u;
  for (c = e, h = e + n; c < h; ++c)
    u = t[c], d = {}, d[s.axis] = a || s.parse(r[c], c), l.push(ko(u, d, o, c));
  return l;
}
function wi(i) {
  return i && i.barStart !== void 0 && i.barEnd !== void 0;
}
function hl(i, t, e) {
  return i !== 0 ? ht(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);
}
function dl(i) {
  let t, e, n, s, o;
  return i.horizontal ? (t = i.base > i.x, e = "left", n = "right") : (t = i.base < i.y, e = "bottom", n = "top"), t ? (s = "end", o = "start") : (s = "start", o = "end"), { start: e, end: n, reverse: t, top: s, bottom: o };
}
function ul(i, t, e, n) {
  let s = t.borderSkipped;
  const o = {};
  if (!s) {
    i.borderSkipped = o;
    return;
  }
  if (s === !0) {
    i.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 };
    return;
  }
  const { start: r, end: a, reverse: l, top: c, bottom: h } = dl(i);
  s === "middle" && e && (i.enableBorderRadius = !0, (e._top || 0) === n ? s = c : (e._bottom || 0) === n ? s = h : (o[Gn(h, r, a, l)] = !0, s = c)), o[Gn(s, r, a, l)] = !0, i.borderSkipped = o;
}
function Gn(i, t, e, n) {
  return n ? (i = fl(i, t, e), i = Qn(i, e, t)) : i = Qn(i, t, e), i;
}
function fl(i, t, e) {
  return i === t ? e : i === e ? t : i;
}
function Qn(i, t, e) {
  return i === "start" ? t : i === "end" ? e : i;
}
function gl(i, { inflateAmount: t }, e) {
  i.inflateAmount = t === "auto" ? e === 1 ? 0.33 : 0 : t;
}
class ye extends ot {
  parsePrimitiveData(t, e, n, s) {
    return qn(t, e, n, s);
  }
  parseArrayData(t, e, n, s) {
    return qn(t, e, n, s);
  }
  parseObjectData(t, e, n, s) {
    const { iScale: o, vScale: r } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? a : l, h = r.axis === "x" ? a : l, d = [];
    let u, f, g, p;
    for (u = n, f = n + s; u < f; ++u)
      p = e[u], g = {}, g[o.axis] = o.parse(kt(p, c), u), d.push(ko(kt(p, h), g, r, u));
    return d;
  }
  updateRangeFromParsed(t, e, n, s) {
    super.updateRangeFromParsed(t, e, n, s);
    const o = n._custom;
    o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, { iScale: n, vScale: s } = e, o = this.getParsed(t), r = o._custom, a = wi(r) ? "[" + r.start + ", " + r.end + "]" : "" + s.getLabelForValue(o[s.axis]);
    return {
      label: "" + n.getLabelForValue(o[n.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const e = this._cachedMeta;
    this.updateElements(e.data, 0, e.data.length, t);
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", { index: r, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), h = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, s);
    for (let f = e; f < e + n; f++) {
      const g = this.getParsed(f), p = o || L(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, h), b = (g._stacks || {})[a.axis], _ = {
        horizontal: c,
        base: p.base,
        enableBorderRadius: !b || wi(g._custom) || r === b._top || r === b._bottom,
        x: c ? p.head : m.center,
        y: c ? m.center : p.head,
        height: c ? m.size : Math.abs(p.size),
        width: c ? Math.abs(p.size) : m.size
      };
      u && (_.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : s));
      const v = _.options || t[f].options;
      ul(_, v, b, r), gl(_, v, h.ratio), this.updateElement(t[f], f, _, s);
    }
  }
  _getStacks(t, e) {
    const { iScale: n } = this._cachedMeta, s = n.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), o = n.options.stacked, r = [], a = (l) => {
      const c = l.controller.getParsed(e), h = c && c[l.vScale.axis];
      if (L(h) || isNaN(h))
        return !0;
    };
    for (const l of s)
      if (!(e !== void 0 && a(l)) && ((o === !1 || r.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && r.push(l.stack), l.index === t))
        break;
    return r.length || r.push(void 0), r;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getStackIndex(t, e, n) {
    const s = this._getStacks(t, n), o = e !== void 0 ? s.indexOf(e) : -1;
    return o === -1 ? s.length - 1 : o;
  }
  _getRuler() {
    const t = this.options, e = this._cachedMeta, n = e.iScale, s = [];
    let o, r;
    for (o = 0, r = e.data.length; o < r; ++o)
      s.push(n.getPixelForValue(this.getParsed(o)[n.axis], o));
    const a = t.barThickness;
    return {
      min: a || rl(e),
      pixels: s,
      start: n._startPixel,
      end: n._endPixel,
      stackCount: this._getStackCount(),
      scale: n,
      grouped: t.grouped,
      ratio: a ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: e, _stacked: n }, options: { base: s, minBarLength: o } } = this, r = s || 0, a = this.getParsed(t), l = a._custom, c = wi(l);
    let h = a[e.axis], d = 0, u = n ? this.applyStack(e, a, n) : h, f, g;
    u !== h && (d = u - h, u = h), c && (h = l.barStart, u = l.barEnd - l.barStart, h !== 0 && ht(h) !== ht(l.barEnd) && (d = 0), d += h);
    const p = !L(s) && !c ? s : d;
    let m = e.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? f = e.getPixelForValue(d + u) : f = m, g = f - m, Math.abs(g) < o) {
      g = hl(g, e, r) * o, h === r && (m -= g / 2);
      const b = e.getPixelForDecimal(0), _ = e.getPixelForDecimal(1), v = Math.min(b, _), y = Math.max(b, _);
      m = Math.max(Math.min(m, y), v), f = m + g;
    }
    if (m === e.getPixelForValue(r)) {
      const b = ht(g) * e.getLineWidthForValue(r) / 2;
      m += b, g -= b;
    }
    return {
      size: g,
      base: m,
      head: f,
      center: f + g / 2
    };
  }
  _calculateBarIndexPixels(t, e) {
    const n = e.scale, s = this.options, o = s.skipNull, r = A(s.maxBarThickness, 1 / 0);
    let a, l;
    if (e.grouped) {
      const c = o ? this._getStackCount(t) : e.stackCount, h = s.barThickness === "flex" ? ll(t, e, s, c) : al(t, e, s, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);
      a = h.start + h.chunk * d + h.chunk / 2, l = Math.min(r, h.chunk * h.ratio);
    } else
      a = n.getPixelForValue(this.getParsed(t)[n.axis], t), l = Math.min(r, e.min * e.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, e = t.vScale, n = t.data, s = n.length;
    let o = 0;
    for (; o < s; ++o)
      this.getParsed(o)[e.axis] !== null && n[o].draw(this._ctx);
  }
}
ye.id = "bar";
ye.defaults = {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
ye.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
};
class ve extends ot {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(t, e, n, s) {
    const o = super.parsePrimitiveData(t, e, n, s);
    for (let r = 0; r < o.length; r++)
      o[r]._custom = this.resolveDataElementOptions(r + n).radius;
    return o;
  }
  parseArrayData(t, e, n, s) {
    const o = super.parseArrayData(t, e, n, s);
    for (let r = 0; r < o.length; r++) {
      const a = e[n + r];
      o[r]._custom = A(a[2], this.resolveDataElementOptions(r + n).radius);
    }
    return o;
  }
  parseObjectData(t, e, n, s) {
    const o = super.parseObjectData(t, e, n, s);
    for (let r = 0; r < o.length; r++) {
      const a = e[n + r];
      o[r]._custom = A(a && a.r && +a.r, this.resolveDataElementOptions(r + n).radius);
    }
    return o;
  }
  getMaxOverflow() {
    const t = this._cachedMeta.data;
    let e = 0;
    for (let n = t.length - 1; n >= 0; --n)
      e = Math.max(e, t[n].size(this.resolveDataElementOptions(n)) / 2);
    return e > 0 && e;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, { xScale: n, yScale: s } = e, o = this.getParsed(t), r = n.getLabelForValue(o.x), a = s.getLabelForValue(o.y), l = o._custom;
    return {
      label: e.label,
      value: "(" + r + ", " + a + (l ? ", " + l : "") + ")"
    };
  }
  update(t) {
    const e = this._cachedMeta.data;
    this.updateElements(e, 0, e.length, t);
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", { iScale: r, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, s), h = r.axis, d = a.axis;
    for (let u = e; u < e + n; u++) {
      const f = t[u], g = !o && this.getParsed(u), p = {}, m = p[h] = o ? r.getPixelForDecimal(0.5) : r.getPixelForValue(g[h]), b = p[d] = o ? a.getBasePixel() : a.getPixelForValue(g[d]);
      p.skip = isNaN(m) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(u, f.active ? "active" : s), o && (p.options.radius = 0)), this.updateElement(f, u, p, s);
    }
  }
  resolveDataElementOptions(t, e) {
    const n = this.getParsed(t);
    let s = super.resolveDataElementOptions(t, e);
    s.$shared && (s = Object.assign({}, s, { $shared: !1 }));
    const o = s.radius;
    return e !== "active" && (s.radius = 0), s.radius += A(n && n._custom, o), s;
  }
}
ve.id = "bubble";
ve.defaults = {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
ve.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function pl(i, t, e) {
  let n = 1, s = 1, o = 0, r = 0;
  if (t < N) {
    const a = i, l = a + t, c = Math.cos(a), h = Math.sin(a), d = Math.cos(l), u = Math.sin(l), f = (v, y, x) => ue(v, a, l, !0) ? 1 : Math.max(y, y * e, x, x * e), g = (v, y, x) => ue(v, a, l, !0) ? -1 : Math.min(y, y * e, x, x * e), p = f(0, c, d), m = f(W, h, u), b = g(V, c, d), _ = g(V + W, h, u);
    n = (p - b) / 2, s = (m - _) / 2, o = -(p + b) / 2, r = -(m + _) / 2;
  }
  return { ratioX: n, ratioY: s, offsetX: o, offsetY: r };
}
class Rt extends ot {
  constructor(t, e) {
    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, e) {
    const n = this.getDataset().data, s = this._cachedMeta;
    if (this._parsing === !1)
      s._parsed = n;
    else {
      let o = (l) => +n[l];
      if (O(n[t])) {
        const { key: l = "value" } = this._parsing;
        o = (c) => +kt(n[c], l);
      }
      let r, a;
      for (r = t, a = t + e; r < a; ++r)
        s._parsed[r] = o(r);
    }
  }
  _getRotation() {
    return st(this.options.rotation - 90);
  }
  _getCircumference() {
    return st(this.options.circumference);
  }
  _getRotationExtents() {
    let t = N, e = -N;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n)) {
        const s = this.chart.getDatasetMeta(n).controller, o = s._getRotation(), r = s._getCircumference();
        t = Math.min(t, o), e = Math.max(e, o + r);
      }
    return {
      rotation: t,
      circumference: e - t
    };
  }
  update(t) {
    const e = this.chart, { chartArea: n } = e, s = this._cachedMeta, o = s.data, r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(n.width, n.height) - r) / 2, 0), l = Math.min(dr(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = pl(d, h, l), m = (n.width - r) / u, b = (n.height - r) / f, _ = Math.max(Math.min(m, b) / 2, 0), v = $s(this.options.radius, _), y = Math.max(v * l, 0), x = (v - y) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * v, this.offsetY = p * v, s.total = this.calculateTotal(), this.outerRadius = v - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * c, 0), this.updateElements(o, 0, o.length, t);
  }
  _circumference(t, e) {
    const n = this.options, s = this._cachedMeta, o = this._getCircumference();
    return e && n.animation.animateRotate || !this.chart.getDataVisibility(t) || s._parsed[t] === null || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * o / N);
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", r = this.chart, a = r.chartArea, c = r.options.animation, h = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, u = o && c.animateScale, f = u ? 0 : this.innerRadius, g = u ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: m } = this._getSharedOptions(e, s);
    let b = this._getRotation(), _;
    for (_ = 0; _ < e; ++_)
      b += this._circumference(_, o);
    for (_ = e; _ < e + n; ++_) {
      const v = this._circumference(_, o), y = t[_], x = {
        x: h + this.offsetX,
        y: d + this.offsetY,
        startAngle: b,
        endAngle: b + v,
        circumference: v,
        outerRadius: g,
        innerRadius: f
      };
      m && (x.options = p || this.resolveDataElementOptions(_, y.active ? "active" : s)), b += v, this.updateElement(y, _, x, s);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, e = t.data;
    let n = 0, s;
    for (s = 0; s < e.length; s++) {
      const o = t._parsed[s];
      o !== null && !isNaN(o) && this.chart.getDataVisibility(s) && !e[s].hidden && (n += Math.abs(o));
    }
    return n;
  }
  calculateCircumference(t) {
    const e = this._cachedMeta.total;
    return e > 0 && !isNaN(t) ? N * (Math.abs(t) / e) : 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, n = this.chart, s = n.data.labels || [], o = xe(e._parsed[t], n.options.locale);
    return {
      label: s[t] || "",
      value: o
    };
  }
  getMaxBorderWidth(t) {
    let e = 0;
    const n = this.chart;
    let s, o, r, a, l;
    if (!t) {
      for (s = 0, o = n.data.datasets.length; s < o; ++s)
        if (n.isDatasetVisible(s)) {
          r = n.getDatasetMeta(s), t = r.data, a = r.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (s = 0, o = t.length; s < o; ++s)
      l = a.resolveDataElementOptions(s), l.borderAlign !== "inner" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return e;
  }
  getMaxOffset(t) {
    let e = 0;
    for (let n = 0, s = t.length; n < s; ++n) {
      const o = this.resolveDataElementOptions(n);
      e = Math.max(e, o.offset || 0, o.hoverOffset || 0);
    }
    return e;
  }
  _getRingWeightOffset(t) {
    let e = 0;
    for (let n = 0; n < t; ++n)
      this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n));
    return e;
  }
  _getRingWeight(t) {
    return Math.max(A(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Rt.id = "doughnut";
Rt.defaults = {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
Rt.descriptors = {
  _scriptable: (i) => i !== "spacing",
  _indexable: (i) => i !== "spacing"
};
Rt.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(i) {
          const t = i.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: e } } = i.legend.options;
            return t.labels.map((n, s) => {
              const r = i.getDatasetMeta(0).controller.getStyle(s);
              return {
                text: n,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                pointStyle: e,
                hidden: !i.getDataVisibility(s),
                index: s
              };
            });
          }
          return [];
        }
      },
      onClick(i, t, e) {
        e.chart.toggleDataVisibility(t.index), e.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          let t = i.label;
          const e = ": " + i.formattedValue;
          return B(t) ? (t = t.slice(), t[0] += e) : t += e, t;
        }
      }
    }
  }
};
class ke extends ot {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const e = this._cachedMeta, { dataset: n, data: s = [], _dataset: o } = e, r = this.chart._animationsDisabled;
    let { start: a, count: l } = Zs(e, s, r);
    this._drawStart = a, this._drawCount = l, Js(e) && (a = 0, l = s.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = s;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(n, void 0, {
      animated: !r,
      options: c
    }, t), this.updateElements(s, a, l, t);
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: d } = this._getSharedOptions(e, s), u = r.axis, f = a.axis, { spanGaps: g, segment: p } = this.options, m = Yt(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || s === "none";
    let _ = e > 0 && this.getParsed(e - 1);
    for (let v = e; v < e + n; ++v) {
      const y = t[v], x = this.getParsed(v), k = b ? y : {}, w = L(x[f]), M = k[u] = r.getPixelForValue(x[u], v), S = k[f] = o || w ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, x, l) : x[f], v);
      k.skip = isNaN(M) || isNaN(S) || w, k.stop = v > 0 && Math.abs(x[u] - _[u]) > m, p && (k.parsed = x, k.raw = c.data[v]), d && (k.options = h || this.resolveDataElementOptions(v, y.active ? "active" : s)), b || this.updateElement(y, v, k, s), _ = x;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, e = t.dataset, n = e.options && e.options.borderWidth || 0, s = t.data || [];
    if (!s.length)
      return n;
    const o = s[0].size(this.resolveDataElementOptions(0)), r = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
    return Math.max(n, o, r) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
ke.id = "line";
ke.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
};
ke.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
class we extends ot {
  constructor(t, e) {
    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, n = this.chart, s = n.data.labels || [], o = xe(e._parsed[t].r, n.options.locale);
    return {
      label: s[t] || "",
      value: o
    };
  }
  parseObjectData(t, e, n, s) {
    return uo.bind(this)(t, e, n, s);
  }
  update(t) {
    const e = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(e, 0, e.length, t);
  }
  getMinMax() {
    const t = this._cachedMeta, e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    return t.data.forEach((n, s) => {
      const o = this.getParsed(s).r;
      !isNaN(o) && this.chart.getDataVisibility(s) && (o < e.min && (e.min = o), o > e.max && (e.max = o));
    }), e;
  }
  _updateRadius() {
    const t = this.chart, e = t.chartArea, n = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(s / 2, 0), r = Math.max(n.cutoutPercentage ? o / 100 * n.cutoutPercentage : 1, 0), a = (o - r) / t.getVisibleDatasetCount();
    this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", r = this.chart, l = r.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - 0.5 * V;
    let f = u, g;
    const p = 360 / this.countVisibleElements();
    for (g = 0; g < e; ++g)
      f += this._computeAngle(g, s, p);
    for (g = e; g < e + n; g++) {
      const m = t[g];
      let b = f, _ = f + this._computeAngle(g, s, p), v = r.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
      f = _, o && (l.animateScale && (v = 0), l.animateRotate && (b = _ = u));
      const y = {
        x: h,
        y: d,
        innerRadius: 0,
        outerRadius: v,
        startAngle: b,
        endAngle: _,
        options: this.resolveDataElementOptions(g, m.active ? "active" : s)
      };
      this.updateElement(m, g, y, s);
    }
  }
  countVisibleElements() {
    const t = this._cachedMeta;
    let e = 0;
    return t.data.forEach((n, s) => {
      !isNaN(this.getParsed(s).r) && this.chart.getDataVisibility(s) && e++;
    }), e;
  }
  _computeAngle(t, e, n) {
    return this.chart.getDataVisibility(t) ? st(this.resolveDataElementOptions(t, e).angle || n) : 0;
  }
}
we.id = "polarArea";
we.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
we.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(i) {
          const t = i.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: e } } = i.legend.options;
            return t.labels.map((n, s) => {
              const r = i.getDatasetMeta(0).controller.getStyle(s);
              return {
                text: n,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                pointStyle: e,
                hidden: !i.getDataVisibility(s),
                index: s
              };
            });
          }
          return [];
        }
      },
      onClick(i, t, e) {
        e.chart.toggleDataVisibility(t.index), e.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          return i.chart.data.labels[i.dataIndex] + ": " + i.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
};
class oi extends Rt {
}
oi.id = "pie";
oi.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
class Se extends ot {
  getLabelAndValue(t) {
    const e = this._cachedMeta.vScale, n = this.getParsed(t);
    return {
      label: e.getLabels()[t],
      value: "" + e.getLabelForValue(n[e.axis])
    };
  }
  parseObjectData(t, e, n, s) {
    return uo.bind(this)(t, e, n, s);
  }
  update(t) {
    const e = this._cachedMeta, n = e.dataset, s = e.data || [], o = e.iScale.getLabels();
    if (n.points = s, t !== "resize") {
      const r = this.resolveDatasetElementOptions(t);
      this.options.showLine || (r.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: o.length === s.length,
        options: r
      };
      this.updateElement(n, void 0, a, t);
    }
    this.updateElements(s, 0, s.length, t);
  }
  updateElements(t, e, n, s) {
    const o = this._cachedMeta.rScale, r = s === "reset";
    for (let a = e; a < e + n; a++) {
      const l = t[a], c = this.resolveDataElementOptions(a, l.active ? "active" : s), h = o.getPointPositionForValue(a, this.getParsed(a).r), d = r ? o.xCenter : h.x, u = r ? o.yCenter : h.y, f = {
        x: d,
        y: u,
        angle: h.angle,
        skip: isNaN(d) || isNaN(u),
        options: c
      };
      this.updateElement(l, a, f, s);
    }
  }
}
Se.id = "radar";
Se.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
};
Se.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
let rt = class {
  constructor() {
    this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;
  }
  tooltipPosition(t) {
    const { x: e, y: n } = this.getProps(["x", "y"], t);
    return { x: e, y: n };
  }
  hasValue() {
    return Yt(this.x) && Yt(this.y);
  }
  getProps(t, e) {
    const n = this.$animations;
    if (!e || !n)
      return this;
    const s = {};
    return t.forEach((o) => {
      s[o] = n[o] && n[o].active() ? n[o]._to : this[o];
    }), s;
  }
};
rt.defaults = {};
rt.defaultRoutes = void 0;
const wo = {
  values(i) {
    return B(i) ? i : "" + i;
  },
  numeric(i, t, e) {
    if (i === 0)
      return "0";
    const n = this.chart.options.locale;
    let s, o = i;
    if (e.length > 1) {
      const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));
      (c < 1e-4 || c > 1e15) && (s = "scientific"), o = ml(i, e);
    }
    const r = it(Math.abs(o)), a = Math.max(Math.min(-1 * Math.floor(r), 20), 0), l = { notation: s, minimumFractionDigits: a, maximumFractionDigits: a };
    return Object.assign(l, this.options.ticks.format), xe(i, n, l);
  },
  logarithmic(i, t, e) {
    if (i === 0)
      return "0";
    const n = i / Math.pow(10, Math.floor(it(i)));
    return n === 1 || n === 2 || n === 5 ? wo.numeric.call(this, i, t, e) : "";
  }
};
function ml(i, t) {
  let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;
}
var ri = { formatters: wo };
T.set("scale", {
  display: !0,
  offset: !1,
  reverse: !1,
  beginAtZero: !1,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: !0,
    lineWidth: 1,
    drawBorder: !0,
    drawOnChartArea: !0,
    drawTicks: !0,
    tickLength: 8,
    tickWidth: (i, t) => t.lineWidth,
    tickColor: (i, t) => t.color,
    offset: !1,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: !1,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: !1,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: !0,
    autoSkip: !0,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: ri.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: !1,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
T.route("scale.ticks", "color", "", "color");
T.route("scale.grid", "color", "", "borderColor");
T.route("scale.grid", "borderColor", "", "borderColor");
T.route("scale.title", "color", "", "color");
T.describe("scale", {
  _fallback: !1,
  _scriptable: (i) => !i.startsWith("before") && !i.startsWith("after") && i !== "callback" && i !== "parser",
  _indexable: (i) => i !== "borderDash" && i !== "tickBorderDash"
});
T.describe("scales", {
  _fallback: "scale"
});
T.describe("scale.ticks", {
  _scriptable: (i) => i !== "backdropPadding" && i !== "callback",
  _indexable: (i) => i !== "backdropPadding"
});
function bl(i, t) {
  const e = i.options.ticks, n = e.maxTicksLimit || _l(i), s = e.major.enabled ? yl(t) : [], o = s.length, r = s[0], a = s[o - 1], l = [];
  if (o > n)
    return vl(t, l, s, o / n), l;
  const c = xl(s, t, n);
  if (o > 0) {
    let h, d;
    const u = o > 1 ? Math.round((a - r) / (o - 1)) : null;
    for (Re(t, l, c, L(u) ? 0 : r - u, r), h = 0, d = o - 1; h < d; h++)
      Re(t, l, c, s[h], s[h + 1]);
    return Re(t, l, c, a, L(u) ? t.length : a + u), l;
  }
  return Re(t, l, c), l;
}
function _l(i) {
  const t = i.options.offset, e = i._tickSize(), n = i._length / e + (t ? 0 : 1), s = i._maxLength / e;
  return Math.floor(Math.min(n, s));
}
function xl(i, t, e) {
  const n = kl(i), s = t.length / e;
  if (!n)
    return Math.max(s, 1);
  const o = xr(n);
  for (let r = 0, a = o.length - 1; r < a; r++) {
    const l = o[r];
    if (l > s)
      return l;
  }
  return Math.max(s, 1);
}
function yl(i) {
  const t = [];
  let e, n;
  for (e = 0, n = i.length; e < n; e++)
    i[e].major && t.push(e);
  return t;
}
function vl(i, t, e, n) {
  let s = 0, o = e[0], r;
  for (n = Math.ceil(n), r = 0; r < i.length; r++)
    r === o && (t.push(i[r]), s++, o = e[s * n]);
}
function Re(i, t, e, n, s) {
  const o = A(n, 0), r = Math.min(A(s, i.length), i.length);
  let a = 0, l, c, h;
  for (e = Math.ceil(e), s && (l = s - n, e = l / Math.floor(l / e)), h = o; h < 0; )
    a++, h = Math.round(o + a * e);
  for (c = Math.max(o, 0); c < r; c++)
    c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));
}
function kl(i) {
  const t = i.length;
  let e, n;
  if (t < 2)
    return !1;
  for (n = i[0], e = 1; e < t; ++e)
    if (i[e] - i[e - 1] !== n)
      return !1;
  return n;
}
const wl = (i) => i === "left" ? "right" : i === "right" ? "left" : i, Zn = (i, t, e) => t === "top" || t === "left" ? i[t] + e : i[t] - e;
function Jn(i, t) {
  const e = [], n = i.length / t, s = i.length;
  let o = 0;
  for (; o < s; o += n)
    e.push(i[Math.floor(o)]);
  return e;
}
function Sl(i, t, e) {
  const n = i.ticks.length, s = Math.min(t, n - 1), o = i._startPixel, r = i._endPixel, a = 1e-6;
  let l = i.getPixelForTick(s), c;
  if (!(e && (n === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(s - 1)) / 2, l += s < t ? c : -c, l < o - a || l > r + a)))
    return l;
}
function Ml(i, t) {
  F(i, (e) => {
    const n = e.gc, s = n.length / 2;
    let o;
    if (s > t) {
      for (o = 0; o < s; ++o)
        delete e.data[n[o]];
      n.splice(0, s);
    }
  });
}
function Zt(i) {
  return i.drawTicks ? i.tickLength : 0;
}
function ts(i, t) {
  if (!i.display)
    return 0;
  const e = U(i.font, t), n = G(i.padding);
  return (B(i.text) ? i.text.length : 1) * e.lineHeight + n.height;
}
function Cl(i, t) {
  return St(i, {
    scale: t,
    type: "scale"
  });
}
function El(i, t, e) {
  return St(i, {
    tick: e,
    index: t,
    type: "tick"
  });
}
function Al(i, t, e) {
  let n = nn(i);
  return (e && t !== "right" || !e && t === "right") && (n = wl(n)), n;
}
function Ol(i, t, e, n) {
  const { top: s, left: o, bottom: r, right: a, chart: l } = i, { chartArea: c, scales: h } = l;
  let d = 0, u, f, g;
  const p = r - s, m = a - o;
  if (i.isHorizontal()) {
    if (f = K(n, o, a), O(e)) {
      const b = Object.keys(e)[0], _ = e[b];
      g = h[b].getPixelForValue(_) + p - t;
    } else
      e === "center" ? g = (c.bottom + c.top) / 2 + p - t : g = Zn(i, e, t);
    u = a - o;
  } else {
    if (O(e)) {
      const b = Object.keys(e)[0], _ = e[b];
      f = h[b].getPixelForValue(_) - m + t;
    } else
      e === "center" ? f = (c.left + c.right) / 2 - m + t : f = Zn(i, e, t);
    g = K(n, r, s), d = e === "left" ? -W : W;
  }
  return { titleX: f, titleY: g, maxWidth: u, rotation: d };
}
class Ft extends rt {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, e) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: e, _suggestedMin: n, _suggestedMax: s } = this;
    return t = et(t, Number.POSITIVE_INFINITY), e = et(e, Number.NEGATIVE_INFINITY), n = et(n, Number.POSITIVE_INFINITY), s = et(s, Number.NEGATIVE_INFINITY), {
      min: et(t, n),
      max: et(e, s),
      minDefined: j(t),
      maxDefined: j(e)
    };
  }
  getMinMax(t) {
    let { min: e, max: n, minDefined: s, maxDefined: o } = this.getUserBounds(), r;
    if (s && o)
      return { min: e, max: n };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      r = a[l].controller.getMinMax(this, t), s || (e = Math.min(e, r.min)), o || (n = Math.max(n, r.max));
    return e = o && e > n ? n : e, n = s && e > n ? e : n, {
      min: et(e, et(n, e)),
      max: et(n, et(e, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    z(this.options.beforeUpdate, [this]);
  }
  update(t, e, n) {
    const { beginAtZero: s, grace: o, ticks: r } = this.options, a = r.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = aa(this, o, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Jn(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === "auto") && (this.ticks = bl(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, e, n;
    this.isHorizontal() ? (e = this.left, n = this.right) : (e = this.top, n = this.bottom, t = !t), this._startPixel = e, this._endPixel = n, this._reversePixels = t, this._length = n - e, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    z(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    z(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    z(this.options.afterSetDimensions, [this]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), z(this.options[t], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    z(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(t) {
    const e = this.options.ticks;
    let n, s, o;
    for (n = 0, s = t.length; n < s; n++)
      o = t[n], o.label = z(e.callback, [o.value, n, t], this);
  }
  afterTickToLabelConversion() {
    z(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    z(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const t = this.options, e = t.ticks, n = this.ticks.length, s = e.minRotation || 0, o = e.maxRotation;
    let r = s, a, l, c;
    if (!this._isVisible() || !e.display || s >= o || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = s;
      return;
    }
    const h = this._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = X(this.chart.width - d, 0, this.maxWidth);
    a = t.offset ? this.maxWidth / n : f / (n - 1), d + 6 > a && (a = f / (n - (t.offset ? 0.5 : 1)), l = this.maxHeight - Zt(t.grid) - e.padding - ts(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = tn(Math.min(
      Math.asin(X((h.highest.height + 6) / a, -1, 1)),
      Math.asin(X(l / c, -1, 1)) - Math.asin(X(u / c, -1, 1))
    )), r = Math.max(s, Math.min(o, r))), this.labelRotation = r;
  }
  afterCalculateLabelRotation() {
    z(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    z(this.options.beforeFit, [this]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: e, options: { ticks: n, title: s, grid: o } } = this, r = this._isVisible(), a = this.isHorizontal();
    if (r) {
      const l = ts(s, e.options.font);
      if (a ? (t.width = this.maxWidth, t.height = Zt(o) + l) : (t.height = this.maxHeight, t.width = Zt(o) + l), n.display && this.ticks.length) {
        const { first: c, last: h, widest: d, highest: u } = this._getLabelSizes(), f = n.padding * 2, g = st(this.labelRotation), p = Math.cos(g), m = Math.sin(g);
        if (a) {
          const b = n.mirror ? 0 : m * d.width + p * u.height;
          t.height = Math.min(this.maxHeight, t.height + b + f);
        } else {
          const b = n.mirror ? 0 : p * d.width + m * u.height;
          t.width = Math.min(this.maxWidth, t.width + b + f);
        }
        this._calculatePadding(c, h, m, p);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, e, n, s) {
    const { ticks: { align: o, padding: r }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const h = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let u = 0, f = 0;
      l ? c ? (u = s * t.width, f = n * e.height) : (u = n * t.height, f = s * e.width) : o === "start" ? f = e.width : o === "end" ? u = t.width : o !== "inner" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);
    } else {
      let h = e.height / 2, d = t.height / 2;
      o === "start" ? (h = 0, d = t.height) : o === "end" && (h = e.height, d = 0), this.paddingTop = h + r, this.paddingBottom = d + r;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    z(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis: t, position: e } = this.options;
    return e === "top" || e === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let e, n;
    for (e = 0, n = t.length; e < n; e++)
      L(t[e].label) && (t.splice(e, 1), n--, e--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const e = this.options.ticks.sampleSize;
      let n = this.ticks;
      e < n.length && (n = Jn(n, e)), this._labelSizes = t = this._computeLabelSizes(n, n.length);
    }
    return t;
  }
  _computeLabelSizes(t, e) {
    const { ctx: n, _longestTextCache: s } = this, o = [], r = [];
    let a = 0, l = 0, c, h, d, u, f, g, p, m, b, _, v;
    for (c = 0; c < e; ++c) {
      if (u = t[c].label, f = this._resolveTickFontOptions(c), n.font = g = f.string, p = s[g] = s[g] || { data: {}, gc: [] }, m = f.lineHeight, b = _ = 0, !L(u) && !B(u))
        b = Ke(n, p.data, p.gc, b, u), _ = m;
      else if (B(u))
        for (h = 0, d = u.length; h < d; ++h)
          v = u[h], !L(v) && !B(v) && (b = Ke(n, p.data, p.gc, b, v), _ += m);
      o.push(b), r.push(_), a = Math.max(b, a), l = Math.max(_, l);
    }
    Ml(s, e);
    const y = o.indexOf(a), x = r.indexOf(l), k = (w) => ({ width: o[w] || 0, height: r[w] || 0 });
    return {
      first: k(0),
      last: k(e - 1),
      widest: k(y),
      highest: k(x),
      widths: o,
      heights: r
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, e) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const e = this._startPixel + t * this._length;
    return kr(this._alignToPixels ? Et(this.chart, e, 0) : e);
  }
  getDecimalForPixel(t) {
    const e = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - e : e;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: e } = this;
    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
  }
  getContext(t) {
    const e = this.ticks || [];
    if (t >= 0 && t < e.length) {
      const n = e[t];
      return n.$context || (n.$context = El(this.getContext(), t, n));
    }
    return this.$context || (this.$context = Cl(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, e = st(this.labelRotation), n = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), o = this._getLabelSizes(), r = t.autoSkipPadding || 0, a = o ? o.widest.width + r : 0, l = o ? o.highest.height + r : 0;
    return this.isHorizontal() ? l * n > a * s ? a / n : l / s : l * s < a * n ? l / n : a / s;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const e = this.axis, n = this.chart, s = this.options, { grid: o, position: r } = s, a = o.offset, l = this.isHorizontal(), h = this.ticks.length + (a ? 1 : 0), d = Zt(o), u = [], f = o.setContext(this.getContext()), g = f.drawBorder ? f.borderWidth : 0, p = g / 2, m = function(C) {
      return Et(n, C, g);
    };
    let b, _, v, y, x, k, w, M, S, I, R, D;
    if (r === "top")
      b = m(this.bottom), k = this.bottom - d, M = b - p, I = m(t.top) + p, D = t.bottom;
    else if (r === "bottom")
      b = m(this.top), I = t.top, D = m(t.bottom) - p, k = b + p, M = this.top + d;
    else if (r === "left")
      b = m(this.right), x = this.right - d, w = b - p, S = m(t.left) + p, R = t.right;
    else if (r === "right")
      b = m(this.left), S = t.left, R = m(t.right) - p, x = b + p, w = this.left + d;
    else if (e === "x") {
      if (r === "center")
        b = m((t.top + t.bottom) / 2 + 0.5);
      else if (O(r)) {
        const C = Object.keys(r)[0], Y = r[C];
        b = m(this.chart.scales[C].getPixelForValue(Y));
      }
      I = t.top, D = t.bottom, k = b + p, M = k + d;
    } else if (e === "y") {
      if (r === "center")
        b = m((t.left + t.right) / 2);
      else if (O(r)) {
        const C = Object.keys(r)[0], Y = r[C];
        b = m(this.chart.scales[C].getPixelForValue(Y));
      }
      x = b - p, w = x - d, S = t.left, R = t.right;
    }
    const $ = A(s.ticks.maxTicksLimit, h), Q = Math.max(1, Math.ceil(h / $));
    for (_ = 0; _ < h; _ += Q) {
      const C = o.setContext(this.getContext(_)), Y = C.lineWidth, H = C.color, Ct = C.borderDash || [], ui = C.borderDashOffset, zt = C.tickWidth, Oe = C.tickColor, Bt = C.tickBorderDash || [], qt = C.tickBorderDashOffset;
      v = Sl(this, _, a), v !== void 0 && (y = Et(n, v, Y), l ? x = w = S = R = y : k = M = I = D = y, u.push({
        tx1: x,
        ty1: k,
        tx2: w,
        ty2: M,
        x1: S,
        y1: I,
        x2: R,
        y2: D,
        width: Y,
        color: H,
        borderDash: Ct,
        borderDashOffset: ui,
        tickWidth: zt,
        tickColor: Oe,
        tickBorderDash: Bt,
        tickBorderDashOffset: qt
      }));
    }
    return this._ticksLength = h, this._borderValue = b, u;
  }
  _computeLabelItems(t) {
    const e = this.axis, n = this.options, { position: s, ticks: o } = n, r = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = o, u = Zt(n.grid), f = u + h, g = d ? -h : f, p = -st(this.labelRotation), m = [];
    let b, _, v, y, x, k, w, M, S, I, R, D, $ = "middle";
    if (s === "top")
      k = this.bottom - g, w = this._getXAxisLabelAlignment();
    else if (s === "bottom")
      k = this.top + g, w = this._getXAxisLabelAlignment();
    else if (s === "left") {
      const C = this._getYAxisLabelAlignment(u);
      w = C.textAlign, x = C.x;
    } else if (s === "right") {
      const C = this._getYAxisLabelAlignment(u);
      w = C.textAlign, x = C.x;
    } else if (e === "x") {
      if (s === "center")
        k = (t.top + t.bottom) / 2 + f;
      else if (O(s)) {
        const C = Object.keys(s)[0], Y = s[C];
        k = this.chart.scales[C].getPixelForValue(Y) + f;
      }
      w = this._getXAxisLabelAlignment();
    } else if (e === "y") {
      if (s === "center")
        x = (t.left + t.right) / 2 - f;
      else if (O(s)) {
        const C = Object.keys(s)[0], Y = s[C];
        x = this.chart.scales[C].getPixelForValue(Y);
      }
      w = this._getYAxisLabelAlignment(u).textAlign;
    }
    e === "y" && (l === "start" ? $ = "top" : l === "end" && ($ = "bottom"));
    const Q = this._getLabelSizes();
    for (b = 0, _ = a.length; b < _; ++b) {
      v = a[b], y = v.label;
      const C = o.setContext(this.getContext(b));
      M = this.getPixelForTick(b) + o.labelOffset, S = this._resolveTickFontOptions(b), I = S.lineHeight, R = B(y) ? y.length : 1;
      const Y = R / 2, H = C.color, Ct = C.textStrokeColor, ui = C.textStrokeWidth;
      let zt = w;
      r ? (x = M, w === "inner" && (b === _ - 1 ? zt = this.options.reverse ? "left" : "right" : b === 0 ? zt = this.options.reverse ? "right" : "left" : zt = "center"), s === "top" ? c === "near" || p !== 0 ? D = -R * I + I / 2 : c === "center" ? D = -Q.highest.height / 2 - Y * I + I : D = -Q.highest.height + I / 2 : c === "near" || p !== 0 ? D = I / 2 : c === "center" ? D = Q.highest.height / 2 - Y * I : D = Q.highest.height - R * I, d && (D *= -1)) : (k = M, D = (1 - R) * I / 2);
      let Oe;
      if (C.showLabelBackdrop) {
        const Bt = G(C.backdropPadding), qt = Q.heights[b], fi = Q.widths[b];
        let gi = k + D - Bt.top, pi = x - Bt.left;
        switch ($) {
          case "middle":
            gi -= qt / 2;
            break;
          case "bottom":
            gi -= qt;
            break;
        }
        switch (w) {
          case "center":
            pi -= fi / 2;
            break;
          case "right":
            pi -= fi;
            break;
        }
        Oe = {
          left: pi,
          top: gi,
          width: fi + Bt.width,
          height: qt + Bt.height,
          color: C.backdropColor
        };
      }
      m.push({
        rotation: p,
        label: y,
        font: S,
        color: H,
        strokeColor: Ct,
        strokeWidth: ui,
        textOffset: D,
        textAlign: zt,
        textBaseline: $,
        translation: [x, k],
        backdrop: Oe
      });
    }
    return m;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: e } = this.options;
    if (-st(this.labelRotation))
      return t === "top" ? "left" : "right";
    let s = "center";
    return e.align === "start" ? s = "left" : e.align === "end" ? s = "right" : e.align === "inner" && (s = "inner"), s;
  }
  _getYAxisLabelAlignment(t) {
    const { position: e, ticks: { crossAlign: n, mirror: s, padding: o } } = this.options, r = this._getLabelSizes(), a = t + o, l = r.widest.width;
    let c, h;
    return e === "left" ? s ? (h = this.right + o, n === "near" ? c = "left" : n === "center" ? (c = "center", h += l / 2) : (c = "right", h += l)) : (h = this.right - a, n === "near" ? c = "right" : n === "center" ? (c = "center", h -= l / 2) : (c = "left", h = this.left)) : e === "right" ? s ? (h = this.left + o, n === "near" ? c = "right" : n === "center" ? (c = "center", h -= l / 2) : (c = "left", h -= l)) : (h = this.left + a, n === "near" ? c = "left" : n === "center" ? (c = "center", h += l / 2) : (c = "right", h = this.right)) : c = "right", { textAlign: c, x: h };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, e = this.options.position;
    if (e === "left" || e === "right")
      return { top: 0, left: this.left, bottom: t.height, right: this.right };
    if (e === "top" || e === "bottom")
      return { top: this.top, left: 0, bottom: this.bottom, right: t.width };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: e }, left: n, top: s, width: o, height: r } = this;
    e && (t.save(), t.fillStyle = e, t.fillRect(n, s, o, r), t.restore());
  }
  getLineWidthForValue(t) {
    const e = this.options.grid;
    if (!this._isVisible() || !e.display)
      return 0;
    const s = this.ticks.findIndex((o) => o.value === t);
    return s >= 0 ? e.setContext(this.getContext(s)).lineWidth : 0;
  }
  drawGrid(t) {
    const e = this.options.grid, n = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let o, r;
    const a = (l, c, h) => {
      !h.width || !h.color || (n.save(), n.lineWidth = h.width, n.strokeStyle = h.color, n.setLineDash(h.borderDash || []), n.lineDashOffset = h.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(c.x, c.y), n.stroke(), n.restore());
    };
    if (e.display)
      for (o = 0, r = s.length; o < r; ++o) {
        const l = s[o];
        e.drawOnChartArea && a(
          { x: l.x1, y: l.y1 },
          { x: l.x2, y: l.y2 },
          l
        ), e.drawTicks && a(
          { x: l.tx1, y: l.ty1 },
          { x: l.tx2, y: l.ty2 },
          {
            color: l.tickColor,
            width: l.tickWidth,
            borderDash: l.tickBorderDash,
            borderDashOffset: l.tickBorderDashOffset
          }
        );
      }
  }
  drawBorder() {
    const { chart: t, ctx: e, options: { grid: n } } = this, s = n.setContext(this.getContext()), o = n.drawBorder ? s.borderWidth : 0;
    if (!o)
      return;
    const r = n.setContext(this.getContext(0)).lineWidth, a = this._borderValue;
    let l, c, h, d;
    this.isHorizontal() ? (l = Et(t, this.left, o) - o / 2, c = Et(t, this.right, r) + r / 2, h = d = a) : (h = Et(t, this.top, o) - o / 2, d = Et(t, this.bottom, r) + r / 2, l = c = a), e.save(), e.lineWidth = s.borderWidth, e.strokeStyle = s.borderColor, e.beginPath(), e.moveTo(l, h), e.lineTo(c, d), e.stroke(), e.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, s = this._computeLabelArea();
    s && ii(n, s);
    const o = this._labelItems || (this._labelItems = this._computeLabelItems(t));
    let r, a;
    for (r = 0, a = o.length; r < a; ++r) {
      const l = o[r], c = l.font, h = l.label;
      l.backdrop && (n.fillStyle = l.backdrop.color, n.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height));
      let d = l.textOffset;
      It(n, h, 0, d, c, l);
    }
    s && ni(n);
  }
  drawTitle() {
    const { ctx: t, options: { position: e, title: n, reverse: s } } = this;
    if (!n.display)
      return;
    const o = U(n.font), r = G(n.padding), a = n.align;
    let l = o.lineHeight / 2;
    e === "bottom" || e === "center" || O(e) ? (l += r.bottom, B(n.text) && (l += o.lineHeight * (n.text.length - 1))) : l += r.top;
    const { titleX: c, titleY: h, maxWidth: d, rotation: u } = Ol(this, l, e, a);
    It(t, n.text, 0, 0, o, {
      color: n.color,
      maxWidth: d,
      rotation: u,
      textAlign: Al(a, e, s),
      textBaseline: "middle",
      translation: [c, h]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, e = t.ticks && t.ticks.z || 0, n = A(t.grid && t.grid.z, -1);
    return !this._isVisible() || this.draw !== Ft.prototype.draw ? [{
      z: e,
      draw: (s) => {
        this.draw(s);
      }
    }] : [{
      z: n,
      draw: (s) => {
        this.drawBackground(), this.drawGrid(s), this.drawTitle();
      }
    }, {
      z: n + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: e,
      draw: (s) => {
        this.drawLabels(s);
      }
    }];
  }
  getMatchingVisibleMetas(t) {
    const e = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", s = [];
    let o, r;
    for (o = 0, r = e.length; o < r; ++o) {
      const a = e[o];
      a[n] === this.id && (!t || a.type === t) && s.push(a);
    }
    return s;
  }
  _resolveTickFontOptions(t) {
    const e = this.options.ticks.setContext(this.getContext(t));
    return U(e.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class Fe {
  constructor(t, e, n) {
    this.type = t, this.scope = e, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const e = Object.getPrototypeOf(t);
    let n;
    Tl(e) && (n = this.register(e));
    const s = this.items, o = t.id, r = this.scope + "." + o;
    if (!o)
      throw new Error("class does not have id: " + t);
    return o in s || (s[o] = t, Dl(t, r, n), this.override && T.override(t.id, t.overrides)), r;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const e = this.items, n = t.id, s = this.scope;
    n in e && delete e[n], s && n in T[s] && (delete T[s][n], this.override && delete Lt[n]);
  }
}
function Dl(i, t, e) {
  const n = de(/* @__PURE__ */ Object.create(null), [
    e ? T.get(e) : {},
    T.get(t),
    i.defaults
  ]);
  T.set(t, n), i.defaultRoutes && Pl(t, i.defaultRoutes), i.descriptors && T.describe(t, i.descriptors);
}
function Pl(i, t) {
  Object.keys(t).forEach((e) => {
    const n = e.split("."), s = n.pop(), o = [i].concat(n).join("."), r = t[e].split("."), a = r.pop(), l = r.join(".");
    T.route(o, s, l, a);
  });
}
function Tl(i) {
  return "id" in i && "defaults" in i;
}
class Ll {
  constructor() {
    this.controllers = new Fe(ot, "datasets", !0), this.elements = new Fe(rt, "elements"), this.plugins = new Fe(Object, "plugins"), this.scales = new Fe(Ft, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, e, n) {
    [...e].forEach((s) => {
      const o = n || this._getRegistryForType(s);
      n || o.isForType(s) || o === this.plugins && s.id ? this._exec(t, o, s) : F(s, (r) => {
        const a = n || this._getRegistryForType(r);
        this._exec(t, a, r);
      });
    });
  }
  _exec(t, e, n) {
    const s = Ji(t);
    z(n["before" + s], [], n), e[t](n), z(n["after" + s], [], n);
  }
  _getRegistryForType(t) {
    for (let e = 0; e < this._typedRegistries.length; e++) {
      const n = this._typedRegistries[e];
      if (n.isForType(t))
        return n;
    }
    return this.plugins;
  }
  _get(t, e, n) {
    const s = e.get(t);
    if (s === void 0)
      throw new Error('"' + t + '" is not a registered ' + n + ".");
    return s;
  }
}
var ct = new Ll();
class Me extends ot {
  update(t) {
    const e = this._cachedMeta, { data: n = [] } = e, s = this.chart._animationsDisabled;
    let { start: o, count: r } = Zs(e, n, s);
    if (this._drawStart = o, this._drawCount = r, Js(e) && (o = 0, r = n.length), this.options.showLine) {
      const { dataset: a, _dataset: l } = e;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = n;
      const c = this.resolveDatasetElementOptions(t);
      c.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !s,
        options: c
      }, t);
    }
    this.updateElements(n, o, r, t);
  }
  addElements() {
    const { showLine: t } = this.options;
    !this.datasetElementType && t && (this.datasetElementType = ct.getElement("line")), super.addElements();
  }
  updateElements(t, e, n, s) {
    const o = s === "reset", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, s), d = this.getSharedOptions(h), u = this.includeOptions(s, d), f = r.axis, g = a.axis, { spanGaps: p, segment: m } = this.options, b = Yt(p) ? p : Number.POSITIVE_INFINITY, _ = this.chart._animationsDisabled || o || s === "none";
    let v = e > 0 && this.getParsed(e - 1);
    for (let y = e; y < e + n; ++y) {
      const x = t[y], k = this.getParsed(y), w = _ ? x : {}, M = L(k[g]), S = w[f] = r.getPixelForValue(k[f], y), I = w[g] = o || M ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[g], y);
      w.skip = isNaN(S) || isNaN(I) || M, w.stop = y > 0 && Math.abs(k[f] - v[f]) > b, m && (w.parsed = k, w.raw = c.data[y]), u && (w.options = d || this.resolveDataElementOptions(y, x.active ? "active" : s)), _ || this.updateElement(x, y, w, s), v = k;
    }
    this.updateSharedOptions(d, s, h);
  }
  getMaxOverflow() {
    const t = this._cachedMeta, e = t.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let l = e.length - 1; l >= 0; --l)
        a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);
      return a > 0 && a;
    }
    const n = t.dataset, s = n.options && n.options.borderWidth || 0;
    if (!e.length)
      return s;
    const o = e[0].size(this.resolveDataElementOptions(0)), r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
    return Math.max(s, o, r) / 2;
  }
}
Me.id = "scatter";
Me.defaults = {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
};
Me.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          return "(" + i.label + ", " + i.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
function At() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Hi {
  constructor(t) {
    this.options = t || {};
  }
  init(t) {
  }
  formats() {
    return At();
  }
  parse(t, e) {
    return At();
  }
  format(t, e) {
    return At();
  }
  add(t, e, n) {
    return At();
  }
  diff(t, e, n) {
    return At();
  }
  startOf(t, e, n) {
    return At();
  }
  endOf(t, e) {
    return At();
  }
}
Hi.override = function(i) {
  Object.assign(Hi.prototype, i);
};
var Il = {
  _date: Hi
};
function Rl(i, t, e, n) {
  const { controller: s, data: o, _sorted: r } = i, a = s._cachedMeta.iScale;
  if (a && t === a.axis && t !== "r" && r && o.length) {
    const l = a._reversePixels ? wr : mt;
    if (n) {
      if (s._sharedOptions) {
        const c = o[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = l(o, t, e - h), u = l(o, t, e + h);
          return { lo: d.lo, hi: u.hi };
        }
      }
    } else
      return l(o, t, e);
  }
  return { lo: 0, hi: o.length - 1 };
}
function Ce(i, t, e, n, s) {
  const o = i.getSortedVisibleDatasetMetas(), r = e[t];
  for (let a = 0, l = o.length; a < l; ++a) {
    const { index: c, data: h } = o[a], { lo: d, hi: u } = Rl(o[a], t, r, s);
    for (let f = d; f <= u; ++f) {
      const g = h[f];
      g.skip || n(g, c, f);
    }
  }
}
function Fl(i) {
  const t = i.indexOf("x") !== -1, e = i.indexOf("y") !== -1;
  return function(n, s) {
    const o = t ? Math.abs(n.x - s.x) : 0, r = e ? Math.abs(n.y - s.y) : 0;
    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));
  };
}
function Si(i, t, e, n, s) {
  const o = [];
  return !s && !i.isPointInArea(t) || Ce(i, e, t, function(a, l, c) {
    !s && !fe(a, i.chartArea, 0) || a.inRange(t.x, t.y, n) && o.push({ element: a, datasetIndex: l, index: c });
  }, !0), o;
}
function Nl(i, t, e, n) {
  let s = [];
  function o(r, a, l) {
    const { startAngle: c, endAngle: h } = r.getProps(["startAngle", "endAngle"], n), { angle: d } = Xs(r, { x: t.x, y: t.y });
    ue(d, c, h) && s.push({ element: r, datasetIndex: a, index: l });
  }
  return Ce(i, e, t, o), s;
}
function zl(i, t, e, n, s, o) {
  let r = [];
  const a = Fl(e);
  let l = Number.POSITIVE_INFINITY;
  function c(h, d, u) {
    const f = h.inRange(t.x, t.y, s);
    if (n && !f)
      return;
    const g = h.getCenterPoint(s);
    if (!(!!o || i.isPointInArea(g)) && !f)
      return;
    const m = a(t, g);
    m < l ? (r = [{ element: h, datasetIndex: d, index: u }], l = m) : m === l && r.push({ element: h, datasetIndex: d, index: u });
  }
  return Ce(i, e, t, c), r;
}
function Mi(i, t, e, n, s, o) {
  return !o && !i.isPointInArea(t) ? [] : e === "r" && !n ? Nl(i, t, e, s) : zl(i, t, e, n, s, o);
}
function es(i, t, e, n, s) {
  const o = [], r = e === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return Ce(i, e, t, (l, c, h) => {
    l[r](t[e], s) && (o.push({ element: l, datasetIndex: c, index: h }), a = a || l.inRange(t.x, t.y, s));
  }), n && !a ? [] : o;
}
var Bl = {
  evaluateInteractionItems: Ce,
  modes: {
    index(i, t, e, n) {
      const s = Ot(t, i), o = e.axis || "x", r = e.includeInvisible || !1, a = e.intersect ? Si(i, s, o, n, r) : Mi(i, s, o, !1, n, r), l = [];
      return a.length ? (i.getSortedVisibleDatasetMetas().forEach((c) => {
        const h = a[0].index, d = c.data[h];
        d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: h });
      }), l) : [];
    },
    dataset(i, t, e, n) {
      const s = Ot(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      let a = e.intersect ? Si(i, s, o, n, r) : Mi(i, s, o, !1, n, r);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = i.getDatasetMeta(l).data;
        a = [];
        for (let h = 0; h < c.length; ++h)
          a.push({ element: c[h], datasetIndex: l, index: h });
      }
      return a;
    },
    point(i, t, e, n) {
      const s = Ot(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      return Si(i, s, o, n, r);
    },
    nearest(i, t, e, n) {
      const s = Ot(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      return Mi(i, s, o, e.intersect, n, r);
    },
    x(i, t, e, n) {
      const s = Ot(t, i);
      return es(i, s, "x", e.intersect, n);
    },
    y(i, t, e, n) {
      const s = Ot(t, i);
      return es(i, s, "y", e.intersect, n);
    }
  }
};
const So = ["left", "top", "right", "bottom"];
function Jt(i, t) {
  return i.filter((e) => e.pos === t);
}
function is(i, t) {
  return i.filter((e) => So.indexOf(e.pos) === -1 && e.box.axis === t);
}
function te(i, t) {
  return i.sort((e, n) => {
    const s = t ? n : e, o = t ? e : n;
    return s.weight === o.weight ? s.index - o.index : s.weight - o.weight;
  });
}
function Vl(i) {
  const t = [];
  let e, n, s, o, r, a;
  for (e = 0, n = (i || []).length; e < n; ++e)
    s = i[e], { position: o, options: { stack: r, stackWeight: a = 1 } } = s, t.push({
      index: e,
      box: s,
      pos: o,
      horizontal: s.isHorizontal(),
      weight: s.weight,
      stack: r && o + r,
      stackWeight: a
    });
  return t;
}
function Wl(i) {
  const t = {};
  for (const e of i) {
    const { stack: n, pos: s, stackWeight: o } = e;
    if (!n || !So.includes(s))
      continue;
    const r = t[n] || (t[n] = { count: 0, placed: 0, weight: 0, size: 0 });
    r.count++, r.weight += o;
  }
  return t;
}
function Hl(i, t) {
  const e = Wl(i), { vBoxMaxWidth: n, hBoxMaxHeight: s } = t;
  let o, r, a;
  for (o = 0, r = i.length; o < r; ++o) {
    a = i[o];
    const { fullSize: l } = a.box, c = e[a.stack], h = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = h ? h * n : l && t.availableWidth, a.height = s) : (a.width = n, a.height = h ? h * s : l && t.availableHeight);
  }
  return e;
}
function jl(i) {
  const t = Vl(i), e = te(t.filter((c) => c.box.fullSize), !0), n = te(Jt(t, "left"), !0), s = te(Jt(t, "right")), o = te(Jt(t, "top"), !0), r = te(Jt(t, "bottom")), a = is(t, "x"), l = is(t, "y");
  return {
    fullSize: e,
    leftAndTop: n.concat(o),
    rightAndBottom: s.concat(l).concat(r).concat(a),
    chartArea: Jt(t, "chartArea"),
    vertical: n.concat(s).concat(l),
    horizontal: o.concat(r).concat(a)
  };
}
function ns(i, t, e, n) {
  return Math.max(i[e], t[e]) + Math.max(i[n], t[n]);
}
function Mo(i, t) {
  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);
}
function $l(i, t, e, n) {
  const { pos: s, box: o } = e, r = i.maxPadding;
  if (!O(s)) {
    e.size && (i[s] -= e.size);
    const d = n[e.stack] || { size: 0, count: 1 };
    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[s] += e.size;
  }
  o.getPadding && Mo(r, o.getPadding());
  const a = Math.max(0, t.outerWidth - ns(r, i, "left", "right")), l = Math.max(0, t.outerHeight - ns(r, i, "top", "bottom")), c = a !== i.w, h = l !== i.h;
  return i.w = a, i.h = l, e.horizontal ? { same: c, other: h } : { same: h, other: c };
}
function Yl(i) {
  const t = i.maxPadding;
  function e(n) {
    const s = Math.max(t[n] - i[n], 0);
    return i[n] += s, s;
  }
  i.y += e("top"), i.x += e("left"), e("right"), e("bottom");
}
function Ul(i, t) {
  const e = t.maxPadding;
  function n(s) {
    const o = { left: 0, top: 0, right: 0, bottom: 0 };
    return s.forEach((r) => {
      o[r] = Math.max(t[r], e[r]);
    }), o;
  }
  return n(i ? ["left", "right"] : ["top", "bottom"]);
}
function se(i, t, e, n) {
  const s = [];
  let o, r, a, l, c, h;
  for (o = 0, r = i.length, c = 0; o < r; ++o) {
    a = i[o], l = a.box, l.update(
      a.width || t.w,
      a.height || t.h,
      Ul(a.horizontal, t)
    );
    const { same: d, other: u } = $l(t, e, a, n);
    c |= d && s.length, h = h || u, l.fullSize || s.push(a);
  }
  return c && se(s, t, e, n) || h;
}
function Ne(i, t, e, n, s) {
  i.top = e, i.left = t, i.right = t + n, i.bottom = e + s, i.width = n, i.height = s;
}
function ss(i, t, e, n) {
  const s = e.padding;
  let { x: o, y: r } = t;
  for (const a of i) {
    const l = a.box, c = n[a.stack] || { count: 1, placed: 0, weight: 1 }, h = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const d = t.w * h, u = c.size || l.height;
      nt(c.start) && (r = c.start), l.fullSize ? Ne(l, s.left, r, e.outerWidth - s.right - s.left, u) : Ne(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;
    } else {
      const d = t.h * h, u = c.size || l.width;
      nt(c.start) && (o = c.start), l.fullSize ? Ne(l, o, s.top, u, e.outerHeight - s.bottom - s.top) : Ne(l, o, t.top + c.placed, u, d), c.start = o, c.placed += d, o = l.right;
    }
  }
  t.x = o, t.y = r;
}
T.set("layout", {
  autoPadding: !0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var q = {
  addBox(i, t) {
    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [{
        z: 0,
        draw(e) {
          t.draw(e);
        }
      }];
    }, i.boxes.push(t);
  },
  removeBox(i, t) {
    const e = i.boxes ? i.boxes.indexOf(t) : -1;
    e !== -1 && i.boxes.splice(e, 1);
  },
  configure(i, t, e) {
    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;
  },
  update(i, t, e, n) {
    if (!i)
      return;
    const s = G(i.options.layout.padding), o = Math.max(t - s.width, 0), r = Math.max(e - s.height, 0), a = jl(i.boxes), l = a.vertical, c = a.horizontal;
    F(i.boxes, (p) => {
      typeof p.beforeLayout == "function" && p.beforeLayout();
    });
    const h = l.reduce((p, m) => m.box.options && m.box.options.display === !1 ? p : p + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: e,
      padding: s,
      availableWidth: o,
      availableHeight: r,
      vBoxMaxWidth: o / 2 / h,
      hBoxMaxHeight: r / 2
    }), u = Object.assign({}, s);
    Mo(u, G(n));
    const f = Object.assign({
      maxPadding: u,
      w: o,
      h: r,
      x: s.left,
      y: s.top
    }, s), g = Hl(l.concat(c), d);
    se(a.fullSize, f, d, g), se(l, f, d, g), se(c, f, d, g) && se(l, f, d, g), Yl(f), ss(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, ss(a.rightAndBottom, f, d, g), i.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, F(a.chartArea, (p) => {
      const m = p.box;
      Object.assign(m, i.chartArea), m.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
class Co {
  acquireContext(t, e) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, e, n) {
  }
  removeEventListener(t, e, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, e, n, s) {
    return e = Math.max(0, e || t.width), n = n || t.height, {
      width: e,
      height: Math.max(0, s ? Math.floor(e / s) : n)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Xl extends Co {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const He = "$chartjs", Kl = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, os = (i) => i === null || i === "";
function ql(i, t) {
  const e = i.style, n = i.getAttribute("height"), s = i.getAttribute("width");
  if (i[He] = {
    initial: {
      height: n,
      width: s,
      style: {
        display: e.display,
        height: e.height,
        width: e.width
      }
    }
  }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", os(s)) {
    const o = Nn(i, "width");
    o !== void 0 && (i.width = o);
  }
  if (os(n))
    if (i.style.height === "")
      i.height = i.width / (t || 2);
    else {
      const o = Nn(i, "height");
      o !== void 0 && (i.height = o);
    }
  return i;
}
const Eo = Da ? { passive: !0 } : !1;
function Gl(i, t, e) {
  i.addEventListener(t, e, Eo);
}
function Ql(i, t, e) {
  i.canvas.removeEventListener(t, e, Eo);
}
function Zl(i, t) {
  const e = Kl[i.type] || i.type, { x: n, y: s } = Ot(i, t);
  return {
    type: e,
    chart: t,
    native: i,
    x: n !== void 0 ? n : null,
    y: s !== void 0 ? s : null
  };
}
function Ge(i, t) {
  for (const e of i)
    if (e === t || e.contains(t))
      return !0;
}
function Jl(i, t, e) {
  const n = i.canvas, s = new MutationObserver((o) => {
    let r = !1;
    for (const a of o)
      r = r || Ge(a.addedNodes, n), r = r && !Ge(a.removedNodes, n);
    r && e();
  });
  return s.observe(document, { childList: !0, subtree: !0 }), s;
}
function tc(i, t, e) {
  const n = i.canvas, s = new MutationObserver((o) => {
    let r = !1;
    for (const a of o)
      r = r || Ge(a.removedNodes, n), r = r && !Ge(a.addedNodes, n);
    r && e();
  });
  return s.observe(document, { childList: !0, subtree: !0 }), s;
}
const pe = /* @__PURE__ */ new Map();
let rs = 0;
function Ao() {
  const i = window.devicePixelRatio;
  i !== rs && (rs = i, pe.forEach((t, e) => {
    e.currentDevicePixelRatio !== i && t();
  }));
}
function ec(i, t) {
  pe.size || window.addEventListener("resize", Ao), pe.set(i, t);
}
function ic(i) {
  pe.delete(i), pe.size || window.removeEventListener("resize", Ao);
}
function nc(i, t, e) {
  const n = i.canvas, s = n && dn(n);
  if (!s)
    return;
  const o = Qs((a, l) => {
    const c = s.clientWidth;
    e(a, l), c < s.clientWidth && e();
  }, window), r = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, h = l.contentRect.height;
    c === 0 && h === 0 || o(c, h);
  });
  return r.observe(s), ec(i, o), r;
}
function Ci(i, t, e) {
  e && e.disconnect(), t === "resize" && ic(i);
}
function sc(i, t, e) {
  const n = i.canvas, s = Qs((o) => {
    i.ctx !== null && e(Zl(o, i));
  }, i, (o) => {
    const r = o[0];
    return [r, r.offsetX, r.offsetY];
  });
  return Gl(n, t, s), s;
}
class oc extends Co {
  acquireContext(t, e) {
    const n = t && t.getContext && t.getContext("2d");
    return n && n.canvas === t ? (ql(t, e), n) : null;
  }
  releaseContext(t) {
    const e = t.canvas;
    if (!e[He])
      return !1;
    const n = e[He].initial;
    ["height", "width"].forEach((o) => {
      const r = n[o];
      L(r) ? e.removeAttribute(o) : e.setAttribute(o, r);
    });
    const s = n.style || {};
    return Object.keys(s).forEach((o) => {
      e.style[o] = s[o];
    }), e.width = e.width, delete e[He], !0;
  }
  addEventListener(t, e, n) {
    this.removeEventListener(t, e);
    const s = t.$proxies || (t.$proxies = {}), r = {
      attach: Jl,
      detach: tc,
      resize: nc
    }[e] || sc;
    s[e] = r(t, e, n);
  }
  removeEventListener(t, e) {
    const n = t.$proxies || (t.$proxies = {}), s = n[e];
    if (!s)
      return;
    ({
      attach: Ci,
      detach: Ci,
      resize: Ci
    }[e] || Ql)(t, e, s), n[e] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, e, n, s) {
    return Oa(t, e, n, s);
  }
  isAttached(t) {
    const e = dn(t);
    return !!(e && e.isConnected);
  }
}
function rc(i) {
  return !go() || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas ? Xl : oc;
}
class ac {
  constructor() {
    this._init = [];
  }
  notify(t, e, n, s) {
    e === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const o = s ? this._descriptors(t).filter(s) : this._descriptors(t), r = this._notify(o, t, e, n);
    return e === "afterDestroy" && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), r;
  }
  _notify(t, e, n, s) {
    s = s || {};
    for (const o of t) {
      const r = o.plugin, a = r[n], l = [e, s, o.options];
      if (z(a, l, r) === !1 && s.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    L(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const e = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), e;
  }
  _createDescriptors(t, e) {
    const n = t && t.config, s = A(n.options && n.options.plugins, {}), o = lc(n);
    return s === !1 && !e ? [] : hc(t, o, s, e);
  }
  _notifyStateChanges(t) {
    const e = this._oldCache || [], n = this._cache, s = (o, r) => o.filter((a) => !r.some((l) => a.plugin.id === l.plugin.id));
    this._notify(s(e, n), t, "stop"), this._notify(s(n, e), t, "start");
  }
}
function lc(i) {
  const t = {}, e = [], n = Object.keys(ct.plugins.items);
  for (let o = 0; o < n.length; o++)
    e.push(ct.getPlugin(n[o]));
  const s = i.plugins || [];
  for (let o = 0; o < s.length; o++) {
    const r = s[o];
    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);
  }
  return { plugins: e, localIds: t };
}
function cc(i, t) {
  return !t && i === !1 ? null : i === !0 ? {} : i;
}
function hc(i, { plugins: t, localIds: e }, n, s) {
  const o = [], r = i.getContext();
  for (const a of t) {
    const l = a.id, c = cc(n[l], s);
    c !== null && o.push({
      plugin: a,
      options: dc(i.config, { plugin: a, local: e[l] }, c, r)
    });
  }
  return o;
}
function dc(i, { plugin: t, local: e }, n, s) {
  const o = i.pluginScopeKeys(t), r = i.getOptionScopes(n, o);
  return e && t.defaults && r.push(t.defaults), i.createResolver(r, s, [""], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function ji(i, t) {
  const e = T.datasets[i] || {};
  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || "x";
}
function uc(i, t) {
  let e = i;
  return i === "_index_" ? e = t : i === "_value_" && (e = t === "x" ? "y" : "x"), e;
}
function fc(i, t) {
  return i === t ? "_index_" : "_value_";
}
function gc(i) {
  if (i === "top" || i === "bottom")
    return "x";
  if (i === "left" || i === "right")
    return "y";
}
function $i(i, t) {
  return i === "x" || i === "y" ? i : t.axis || gc(t.position) || i.charAt(0).toLowerCase();
}
function pc(i, t) {
  const e = Lt[i.type] || { scales: {} }, n = t.scales || {}, s = ji(i.type, t), o = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((a) => {
    const l = n[a];
    if (!O(l))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (l._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const c = $i(a, l), h = fc(c, s), d = e.scales || {};
    o[c] = o[c] || a, r[a] = re(/* @__PURE__ */ Object.create(null), [{ axis: c }, l, d[c], d[h]]);
  }), i.data.datasets.forEach((a) => {
    const l = a.type || i.type, c = a.indexAxis || ji(l, t), d = (Lt[l] || {}).scales || {};
    Object.keys(d).forEach((u) => {
      const f = uc(u, c), g = a[f + "AxisID"] || o[f] || f;
      r[g] = r[g] || /* @__PURE__ */ Object.create(null), re(r[g], [{ axis: f }, n[g], d[u]]);
    });
  }), Object.keys(r).forEach((a) => {
    const l = r[a];
    re(l, [T.scales[l.type], T.scale]);
  }), r;
}
function Oo(i) {
  const t = i.options || (i.options = {});
  t.plugins = A(t.plugins, {}), t.scales = pc(i, t);
}
function Do(i) {
  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;
}
function mc(i) {
  return i = i || {}, i.data = Do(i.data), Oo(i), i;
}
const as = /* @__PURE__ */ new Map(), Po = /* @__PURE__ */ new Set();
function ze(i, t) {
  let e = as.get(i);
  return e || (e = t(), as.set(i, e), Po.add(e)), e;
}
const ee = (i, t, e) => {
  const n = kt(t, e);
  n !== void 0 && i.add(n);
};
class bc {
  constructor(t) {
    this._config = mc(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Do(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Oo(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return ze(
      t,
      () => [[
        `datasets.${t}`,
        ""
      ]]
    );
  }
  datasetAnimationScopeKeys(t, e) {
    return ze(
      `${t}.transition.${e}`,
      () => [
        [
          `datasets.${t}.transitions.${e}`,
          `transitions.${e}`
        ],
        [
          `datasets.${t}`,
          ""
        ]
      ]
    );
  }
  datasetElementScopeKeys(t, e) {
    return ze(
      `${t}-${e}`,
      () => [[
        `datasets.${t}.elements.${e}`,
        `datasets.${t}`,
        `elements.${e}`,
        ""
      ]]
    );
  }
  pluginScopeKeys(t) {
    const e = t.id, n = this.type;
    return ze(
      `${n}-plugin-${e}`,
      () => [[
        `plugins.${e}`,
        ...t.additionalOptionScopes || []
      ]]
    );
  }
  _cachedScopes(t, e) {
    const n = this._scopeCache;
    let s = n.get(t);
    return (!s || e) && (s = /* @__PURE__ */ new Map(), n.set(t, s)), s;
  }
  getOptionScopes(t, e, n) {
    const { options: s, type: o } = this, r = this._cachedScopes(t, n), a = r.get(e);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    e.forEach((h) => {
      t && (l.add(t), h.forEach((d) => ee(l, t, d))), h.forEach((d) => ee(l, s, d)), h.forEach((d) => ee(l, Lt[o] || {}, d)), h.forEach((d) => ee(l, T, d)), h.forEach((d) => ee(l, Vi, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Po.has(e) && r.set(e, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: e } = this;
    return [
      t,
      Lt[e] || {},
      T.datasets[e] || {},
      { type: e },
      T,
      Vi
    ];
  }
  resolveNamedOptions(t, e, n, s = [""]) {
    const o = { $shared: !0 }, { resolver: r, subPrefixes: a } = ls(this._resolverCache, t, s);
    let l = r;
    if (xc(r, e)) {
      o.$shared = !1, n = wt(n) ? n() : n;
      const c = this.createResolver(t, n, a);
      l = Ut(r, n, c);
    }
    for (const c of e)
      o[c] = l[c];
    return o;
  }
  createResolver(t, e, n = [""], s) {
    const { resolver: o } = ls(this._resolverCache, t, n);
    return O(e) ? Ut(o, e, void 0, s) : o;
  }
}
function ls(i, t, e) {
  let n = i.get(t);
  n || (n = /* @__PURE__ */ new Map(), i.set(t, n));
  const s = e.join();
  let o = n.get(s);
  return o || (o = {
    resolver: ln(t, e),
    subPrefixes: e.filter((a) => !a.toLowerCase().includes("hover"))
  }, n.set(s, o)), o;
}
const _c = (i) => O(i) && Object.getOwnPropertyNames(i).reduce((t, e) => t || wt(i[e]), !1);
function xc(i, t) {
  const { isScriptable: e, isIndexable: n } = ao(i);
  for (const s of t) {
    const o = e(s), r = n(s), a = (r || o) && i[s];
    if (o && (wt(a) || _c(a)) || r && B(a))
      return !0;
  }
  return !1;
}
var yc = "3.9.1";
const vc = ["top", "bottom", "left", "right", "chartArea"];
function cs(i, t) {
  return i === "top" || i === "bottom" || vc.indexOf(i) === -1 && t === "x";
}
function hs(i, t) {
  return function(e, n) {
    return e[i] === n[i] ? e[t] - n[t] : e[i] - n[i];
  };
}
function ds(i) {
  const t = i.chart, e = t.options.animation;
  t.notifyPlugins("afterRender"), z(e && e.onComplete, [i], t);
}
function kc(i) {
  const t = i.chart, e = t.options.animation;
  z(e && e.onProgress, [i], t);
}
function To(i) {
  return go() && typeof i == "string" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;
}
const Qe = {}, Lo = (i) => {
  const t = To(i);
  return Object.values(Qe).filter((e) => e.canvas === t).pop();
};
function wc(i, t, e) {
  const n = Object.keys(i);
  for (const s of n) {
    const o = +s;
    if (o >= t) {
      const r = i[s];
      delete i[s], (e > 0 || o > t) && (i[o + e] = r);
    }
  }
}
function Sc(i, t, e, n) {
  return !e || i.type === "mouseout" ? null : n ? t : i;
}
let me = class {
  constructor(t, e) {
    const n = this.config = new bc(e), s = To(t), o = Lo(s);
    if (o)
      throw new Error(
        "Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."
      );
    const r = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || rc(s))(), this.platform.updateConfig(n);
    const a = this.platform.acquireContext(s, r.aspectRatio), l = a && a.canvas, c = l && l.height, h = l && l.width;
    if (this.id = hr(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new ac(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Cr((d) => this.update(d), r.resizeDelay || 0), this._dataChanges = [], Qe[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    ut.listen(this, "complete", ds), ut.listen(this, "progress", kc), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: e }, width: n, height: s, _aspectRatio: o } = this;
    return L(t) ? e && o ? o : s ? n / s : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Fn(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return Ln(this.canvas, this.ctx), this;
  }
  stop() {
    return ut.stop(this), this;
  }
  resize(t, e) {
    ut.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e);
  }
  _resize(t, e) {
    const n = this.options, s = this.canvas, o = n.maintainAspectRatio && this.aspectRatio, r = this.platform.getMaximumSize(s, t, e, o), a = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, Fn(this, a, !0) && (this.notifyPlugins("resize", { size: r }), z(n.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const e = this.options.scales || {};
    F(e, (n, s) => {
      n.id = s;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, e = t.scales, n = this.scales, s = Object.keys(n).reduce((r, a) => (r[a] = !1, r), {});
    let o = [];
    e && (o = o.concat(
      Object.keys(e).map((r) => {
        const a = e[r], l = $i(r, a), c = l === "r", h = l === "x";
        return {
          options: a,
          dposition: c ? "chartArea" : h ? "bottom" : "left",
          dtype: c ? "radialLinear" : h ? "category" : "linear"
        };
      })
    )), F(o, (r) => {
      const a = r.options, l = a.id, c = $i(l, a), h = A(a.type, r.dtype);
      (a.position === void 0 || cs(a.position, c) !== cs(r.dposition)) && (a.position = r.dposition), s[l] = !0;
      let d = null;
      if (l in n && n[l].type === h)
        d = n[l];
      else {
        const u = ct.getScale(h);
        d = new u({
          id: l,
          type: h,
          ctx: this.ctx,
          chart: this
        }), n[d.id] = d;
      }
      d.init(a, t);
    }), F(s, (r, a) => {
      r || delete n[a];
    }), F(n, (r) => {
      q.configure(this, r, r.options), q.addBox(this, r);
    });
  }
  _updateMetasets() {
    const t = this._metasets, e = this.data.datasets.length, n = t.length;
    if (t.sort((s, o) => s.index - o.index), n > e) {
      for (let s = e; s < n; ++s)
        this._destroyDatasetMeta(s);
      t.splice(e, n - e);
    }
    this._sortedMetasets = t.slice(0).sort(hs("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: e } } = this;
    t.length > e.length && delete this._stacks, t.forEach((n, s) => {
      e.filter((o) => o === n._dataset).length === 0 && this._destroyDatasetMeta(s);
    });
  }
  buildOrUpdateControllers() {
    const t = [], e = this.data.datasets;
    let n, s;
    for (this._removeUnreferencedMetasets(), n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      let r = this.getDatasetMeta(n);
      const a = o.type || this.config.type;
      if (r.type && r.type !== a && (this._destroyDatasetMeta(n), r = this.getDatasetMeta(n)), r.type = a, r.indexAxis = o.indexAxis || ji(a, this.options), r.order = o.order || 0, r.index = n, r.label = "" + o.label, r.visible = this.isDatasetVisible(n), r.controller)
        r.controller.updateIndex(n), r.controller.linkScales();
      else {
        const l = ct.getController(a), { datasetElementType: c, dataElementType: h } = T.datasets[a];
        Object.assign(l.prototype, {
          dataElementType: ct.getElement(h),
          datasetElementType: c && ct.getElement(c)
        }), r.controller = new l(this, n), t.push(r.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    F(this.data.datasets, (t, e) => {
      this.getDatasetMeta(e).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const e = this.config;
    e.update();
    const n = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 }) === !1)
      return;
    const o = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let r = 0;
    for (let c = 0, h = this.data.datasets.length; c < h; c++) {
      const { controller: d } = this.getDatasetMeta(c), u = !s && o.indexOf(d) === -1;
      d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);
    }
    r = this._minPadding = n.layout.autoPadding ? r : 0, this._updateLayout(r), s || F(o, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(hs("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    F(this.scales, (t) => {
      q.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, e = new Set(Object.keys(this._listeners)), n = new Set(t.events);
    (!vn(e, n) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];
    for (const { method: n, start: s, count: o } of e) {
      const r = n === "_removeElements" ? -o : o;
      wc(t, s, r);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const e = this.data.datasets.length, n = (o) => new Set(
      t.filter((r) => r[0] === o).map((r, a) => a + "," + r.splice(1).join(","))
    ), s = n(0);
    for (let o = 1; o < e; o++)
      if (!vn(s, n(o)))
        return;
    return Array.from(s).map((o) => o.split(",")).map((o) => ({ method: o[1], start: +o[2], count: +o[3] }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1)
      return;
    q.update(this, this.width, this.height, t);
    const e = this.chartArea, n = e.width <= 0 || e.height <= 0;
    this._layers = [], F(this.boxes, (s) => {
      n && s.position === "chartArea" || (s.configure && s.configure(), this._layers.push(...s._layers()));
    }, this), this._layers.forEach((s, o) => {
      s._idx = o;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 }) !== !1) {
      for (let e = 0, n = this.data.datasets.length; e < n; ++e)
        this.getDatasetMeta(e).controller.configure();
      for (let e = 0, n = this.data.datasets.length; e < n; ++e)
        this._updateDataset(e, wt(t) ? t({ datasetIndex: e }) : t);
      this.notifyPlugins("afterDatasetsUpdate", { mode: t });
    }
  }
  _updateDataset(t, e) {
    const n = this.getDatasetMeta(t), s = { meta: n, index: t, mode: e, cancelable: !0 };
    this.notifyPlugins("beforeDatasetUpdate", s) !== !1 && (n.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s));
  }
  render() {
    this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (ut.has(this) ? this.attached && !ut.running(this) && ut.start(this) : (this.draw(), ds({ chart: this })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: n, height: s } = this._resizeBeforeDraw;
      this._resize(n, s), this._resizeBeforeDraw = null;
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1)
      return;
    const e = this._layers;
    for (t = 0; t < e.length && e[t].z <= 0; ++t)
      e[t].draw(this.chartArea);
    for (this._drawDatasets(); t < e.length; ++t)
      e[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const e = this._sortedMetasets, n = [];
    let s, o;
    for (s = 0, o = e.length; s < o; ++s) {
      const r = e[s];
      (!t || r.visible) && n.push(r);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let e = t.length - 1; e >= 0; --e)
      this._drawDataset(t[e]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const e = this.ctx, n = t._clip, s = !n.disabled, o = this.chartArea, r = {
      meta: t,
      index: t.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (s && ii(e, {
      left: n.left === !1 ? 0 : o.left - n.left,
      right: n.right === !1 ? this.width : o.right + n.right,
      top: n.top === !1 ? 0 : o.top - n.top,
      bottom: n.bottom === !1 ? this.height : o.bottom + n.bottom
    }), t.controller.draw(), s && ni(e), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r));
  }
  isPointInArea(t) {
    return fe(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, e, n, s) {
    const o = Bl.modes[e];
    return typeof o == "function" ? o(this, t, n, s) : [];
  }
  getDatasetMeta(t) {
    const e = this.data.datasets[t], n = this._metasets;
    let s = n.filter((o) => o && o._dataset === e).pop();
    return s || (s = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: e && e.order || 0,
      index: t,
      _dataset: e,
      _parsed: [],
      _sorted: !1
    }, n.push(s)), s;
  }
  getContext() {
    return this.$context || (this.$context = St(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const e = this.data.datasets[t];
    if (!e)
      return !1;
    const n = this.getDatasetMeta(t);
    return typeof n.hidden == "boolean" ? !n.hidden : !e.hidden;
  }
  setDatasetVisibility(t, e) {
    const n = this.getDatasetMeta(t);
    n.hidden = !e;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, e, n) {
    const s = n ? "show" : "hide", o = this.getDatasetMeta(t), r = o.controller._resolveAnimations(void 0, s);
    nt(e) ? (o.data[e].hidden = !n, this.update()) : (this.setDatasetVisibility(t, n), r.update(o, { visible: n }), this.update((a) => a.datasetIndex === t ? s : void 0));
  }
  hide(t, e) {
    this._updateVisibility(t, e, !1);
  }
  show(t, e) {
    this._updateVisibility(t, e, !0);
  }
  _destroyDatasetMeta(t) {
    const e = this._metasets[t];
    e && e.controller && e.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, e;
    for (this.stop(), ut.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: e } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Ln(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete Qe[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, e = this.platform, n = (o, r) => {
      e.addEventListener(this, o, r), t[o] = r;
    }, s = (o, r, a) => {
      o.offsetX = r, o.offsetY = a, this._eventHandler(o);
    };
    F(this.options.events, (o) => n(o, s));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, e = this.platform, n = (l, c) => {
      e.addEventListener(this, l, c), t[l] = c;
    }, s = (l, c) => {
      t[l] && (e.removeEventListener(this, l, c), delete t[l]);
    }, o = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let r;
    const a = () => {
      s("attach", a), this.attached = !0, this.resize(), n("resize", o), n("detach", r);
    };
    r = () => {
      this.attached = !1, s("resize", o), this._stop(), this._resize(0, 0), n("attach", a);
    }, e.isAttached(this.canvas) ? a() : r();
  }
  unbindEvents() {
    F(this._listeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._listeners = {}, F(this._responsiveListeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, e, n) {
    const s = n ? "set" : "remove";
    let o, r, a, l;
    for (e === "dataset" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + s + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) {
      r = t[a];
      const c = r && this.getDatasetMeta(r.datasetIndex).controller;
      c && c[s + "HoverStyle"](r.element, r.datasetIndex, r.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const e = this._active || [], n = t.map(({ datasetIndex: o, index: r }) => {
      const a = this.getDatasetMeta(o);
      if (!a)
        throw new Error("No dataset found at index " + o);
      return {
        datasetIndex: o,
        element: a.data[r],
        index: r
      };
    });
    !$e(n, e) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, e));
  }
  notifyPlugins(t, e, n) {
    return this._plugins.notify(this, t, e, n);
  }
  _updateHoverStyles(t, e, n) {
    const s = this.options.hover, o = (l, c) => l.filter((h) => !c.some((d) => h.datasetIndex === d.datasetIndex && h.index === d.index)), r = o(e, t), a = n ? t : o(t, e);
    r.length && this.updateHoverStyle(r, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);
  }
  _eventHandler(t, e) {
    const n = {
      event: t,
      replay: e,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, s = (r) => (r.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", n, s) === !1)
      return;
    const o = this._handleEvent(t, e, n.inChartArea);
    return n.cancelable = !1, this.notifyPlugins("afterEvent", n, s), (o || n.changed) && this.render(), this;
  }
  _handleEvent(t, e, n) {
    const { _active: s = [], options: o } = this, r = e, a = this._getActiveElements(t, s, n, r), l = mr(t), c = Sc(t, this._lastEvent, n, l);
    n && (this._lastEvent = null, z(o.onHover, [t, a, this], this), l && z(o.onClick, [t, a, this], this));
    const h = !$e(a, s);
    return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = c, h;
  }
  _getActiveElements(t, e, n, s) {
    if (t.type === "mouseout")
      return [];
    if (!n)
      return e;
    const o = this.options.hover;
    return this.getElementsAtEventForMode(t, o.mode, o, s);
  }
};
const us = () => F(me.instances, (i) => i._plugins.invalidate()), bt = !0;
Object.defineProperties(me, {
  defaults: {
    enumerable: bt,
    value: T
  },
  instances: {
    enumerable: bt,
    value: Qe
  },
  overrides: {
    enumerable: bt,
    value: Lt
  },
  registry: {
    enumerable: bt,
    value: ct
  },
  version: {
    enumerable: bt,
    value: yc
  },
  getChart: {
    enumerable: bt,
    value: Lo
  },
  register: {
    enumerable: bt,
    value: (...i) => {
      ct.add(...i), us();
    }
  },
  unregister: {
    enumerable: bt,
    value: (...i) => {
      ct.remove(...i), us();
    }
  }
});
function Io(i, t, e) {
  const { startAngle: n, pixelMargin: s, x: o, y: r, outerRadius: a, innerRadius: l } = t;
  let c = s / a;
  i.beginPath(), i.arc(o, r, a, n - c, e + c), l > s ? (c = s / l, i.arc(o, r, l, e + c, n - c, !0)) : i.arc(o, r, s, e + W, n - W), i.closePath(), i.clip();
}
function Mc(i) {
  return an(i, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function Cc(i, t, e, n) {
  const s = Mc(i.options.borderRadius), o = (e - t) / 2, r = Math.min(o, n * t / 2), a = (l) => {
    const c = (e - Math.min(o, l)) * n / 2;
    return X(l, 0, Math.min(o, c));
  };
  return {
    outerStart: a(s.outerStart),
    outerEnd: a(s.outerEnd),
    innerStart: X(s.innerStart, 0, r),
    innerEnd: X(s.innerEnd, 0, r)
  };
}
function Wt(i, t, e, n) {
  return {
    x: e + i * Math.cos(t),
    y: n + i * Math.sin(t)
  };
}
function Yi(i, t, e, n, s, o) {
  const { x: r, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = t, d = Math.max(t.outerRadius + n + e - c, 0), u = h > 0 ? h + n + e + c : 0;
  let f = 0;
  const g = s - l;
  if (n) {
    const C = h > 0 ? h - n : 0, Y = d > 0 ? d - n : 0, H = (C + Y) / 2, Ct = H !== 0 ? g * H / (H + n) : g;
    f = (g - Ct) / 2;
  }
  const p = Math.max(1e-3, g * d - e / V) / d, m = (g - p) / 2, b = l + m + f, _ = s - m - f, { outerStart: v, outerEnd: y, innerStart: x, innerEnd: k } = Cc(t, u, d, _ - b), w = d - v, M = d - y, S = b + v / w, I = _ - y / M, R = u + x, D = u + k, $ = b + x / R, Q = _ - k / D;
  if (i.beginPath(), o) {
    if (i.arc(r, a, d, S, I), y > 0) {
      const H = Wt(M, I, r, a);
      i.arc(H.x, H.y, y, I, _ + W);
    }
    const C = Wt(D, _, r, a);
    if (i.lineTo(C.x, C.y), k > 0) {
      const H = Wt(D, Q, r, a);
      i.arc(H.x, H.y, k, _ + W, Q + Math.PI);
    }
    if (i.arc(r, a, u, _ - k / u, b + x / u, !0), x > 0) {
      const H = Wt(R, $, r, a);
      i.arc(H.x, H.y, x, $ + Math.PI, b - W);
    }
    const Y = Wt(w, b, r, a);
    if (i.lineTo(Y.x, Y.y), v > 0) {
      const H = Wt(w, S, r, a);
      i.arc(H.x, H.y, v, b - W, S);
    }
  } else {
    i.moveTo(r, a);
    const C = Math.cos(S) * d + r, Y = Math.sin(S) * d + a;
    i.lineTo(C, Y);
    const H = Math.cos(I) * d + r, Ct = Math.sin(I) * d + a;
    i.lineTo(H, Ct);
  }
  i.closePath();
}
function Ec(i, t, e, n, s) {
  const { fullCircles: o, startAngle: r, circumference: a } = t;
  let l = t.endAngle;
  if (o) {
    Yi(i, t, e, n, r + N, s);
    for (let c = 0; c < o; ++c)
      i.fill();
    isNaN(a) || (l = r + a % N, a % N === 0 && (l += N));
  }
  return Yi(i, t, e, n, l, s), i.fill(), l;
}
function Ac(i, t, e) {
  const { x: n, y: s, startAngle: o, pixelMargin: r, fullCircles: a } = t, l = Math.max(t.outerRadius - r, 0), c = t.innerRadius + r;
  let h;
  for (e && Io(i, t, o + N), i.beginPath(), i.arc(n, s, c, o + N, o, !0), h = 0; h < a; ++h)
    i.stroke();
  for (i.beginPath(), i.arc(n, s, l, o, o + N), h = 0; h < a; ++h)
    i.stroke();
}
function Oc(i, t, e, n, s, o) {
  const { options: r } = t, { borderWidth: a, borderJoinStyle: l } = r, c = r.borderAlign === "inner";
  a && (c ? (i.lineWidth = a * 2, i.lineJoin = l || "round") : (i.lineWidth = a, i.lineJoin = l || "bevel"), t.fullCircles && Ac(i, t, c), c && Io(i, t, s), Yi(i, t, e, n, s, o), i.stroke());
}
class ai extends rt {
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, e, n) {
    const s = this.getProps(["x", "y"], n), { angle: o, distance: r } = Xs(s, { x: t, y: e }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: h, circumference: d } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], n), u = this.options.spacing / 2, g = A(d, l - a) >= N || ue(o, a, l), p = pt(r, c + u, h + u);
    return g && p;
  }
  getCenterPoint(t) {
    const { x: e, y: n, startAngle: s, endAngle: o, innerRadius: r, outerRadius: a } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], t), { offset: l, spacing: c } = this.options, h = (s + o) / 2, d = (r + a + c + l) / 2;
    return {
      x: e + Math.cos(h) * d,
      y: n + Math.sin(h) * d
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: e, circumference: n } = this, s = (e.offset || 0) / 2, o = (e.spacing || 0) / 2, r = e.circular;
    if (this.pixelMargin = e.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = n > N ? Math.floor(n / N) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    let a = 0;
    if (s) {
      a = s / 2;
      const c = (this.startAngle + this.endAngle) / 2;
      t.translate(Math.cos(c) * a, Math.sin(c) * a), this.circumference >= V && (a = s);
    }
    t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;
    const l = Ec(t, this, a, o, r);
    Oc(t, this, a, o, l, r), t.restore();
  }
}
ai.id = "arc";
ai.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
};
ai.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function Ro(i, t, e = t) {
  i.lineCap = A(e.borderCapStyle, t.borderCapStyle), i.setLineDash(A(e.borderDash, t.borderDash)), i.lineDashOffset = A(e.borderDashOffset, t.borderDashOffset), i.lineJoin = A(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = A(e.borderWidth, t.borderWidth), i.strokeStyle = A(e.borderColor, t.borderColor);
}
function Dc(i, t, e) {
  i.lineTo(e.x, e.y);
}
function Pc(i) {
  return i.stepped ? Jr : i.tension || i.cubicInterpolationMode === "monotone" ? ta : Dc;
}
function Fo(i, t, e = {}) {
  const n = i.length, { start: s = 0, end: o = n - 1 } = e, { start: r, end: a } = t, l = Math.max(s, r), c = Math.min(o, a), h = s < r && o < r || s > a && o > a;
  return {
    count: n,
    start: l,
    loop: t.loop,
    ilen: c < l && !h ? n + c - l : c - l
  };
}
function Tc(i, t, e, n) {
  const { points: s, options: o } = t, { count: r, start: a, loop: l, ilen: c } = Fo(s, e, n), h = Pc(o);
  let { move: d = !0, reverse: u } = n || {}, f, g, p;
  for (f = 0; f <= c; ++f)
    g = s[(a + (u ? c - f : f)) % r], !g.skip && (d ? (i.moveTo(g.x, g.y), d = !1) : h(i, p, g, u, o.stepped), p = g);
  return l && (g = s[(a + (u ? c : 0)) % r], h(i, p, g, u, o.stepped)), !!l;
}
function Lc(i, t, e, n) {
  const s = t.points, { count: o, start: r, ilen: a } = Fo(s, e, n), { move: l = !0, reverse: c } = n || {};
  let h = 0, d = 0, u, f, g, p, m, b;
  const _ = (y) => (r + (c ? a - y : y)) % o, v = () => {
    p !== m && (i.lineTo(h, m), i.lineTo(h, p), i.lineTo(h, b));
  };
  for (l && (f = s[_(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {
    if (f = s[_(u)], f.skip)
      continue;
    const y = f.x, x = f.y, k = y | 0;
    k === g ? (x < p ? p = x : x > m && (m = x), h = (d * h + y) / ++d) : (v(), i.lineTo(y, x), g = k, d = 0, p = m = x), b = x;
  }
  v();
}
function Ui(i) {
  const t = i.options, e = t.borderDash && t.borderDash.length;
  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? Lc : Tc;
}
function Ic(i) {
  return i.stepped ? Pa : i.tension || i.cubicInterpolationMode === "monotone" ? Ta : Dt;
}
function Rc(i, t, e, n) {
  let s = t._path;
  s || (s = t._path = new Path2D(), t.path(s, e, n) && s.closePath()), Ro(i, t.options), i.stroke(s);
}
function Fc(i, t, e, n) {
  const { segments: s, options: o } = t, r = Ui(t);
  for (const a of s)
    Ro(i, o, a.style), i.beginPath(), r(i, t, a, { start: e, end: e + n - 1 }) && i.closePath(), i.stroke();
}
const Nc = typeof Path2D == "function";
function zc(i, t, e, n) {
  Nc && !t.options.segment ? Rc(i, t, e, n) : Fc(i, t, e, n);
}
class Mt extends rt {
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, e) {
    const n = this.options;
    if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
      const s = n.spanGaps ? this._loop : this._fullLoop;
      wa(this._points, n, t, s, e), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = Ba(this, this.options.segment));
  }
  first() {
    const t = this.segments, e = this.points;
    return t.length && e[t[0].start];
  }
  last() {
    const t = this.segments, e = this.points, n = t.length;
    return n && e[t[n - 1].end];
  }
  interpolate(t, e) {
    const n = this.options, s = t[e], o = this.points, r = xo(this, { property: e, start: s, end: s });
    if (!r.length)
      return;
    const a = [], l = Ic(n);
    let c, h;
    for (c = 0, h = r.length; c < h; ++c) {
      const { start: d, end: u } = r[c], f = o[d], g = o[u];
      if (f === g) {
        a.push(f);
        continue;
      }
      const p = Math.abs((s - f[e]) / (g[e] - f[e])), m = l(f, g, p, n.stepped);
      m[e] = t[e], a.push(m);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(t, e, n) {
    return Ui(this)(t, this, e, n);
  }
  path(t, e, n) {
    const s = this.segments, o = Ui(this);
    let r = this._loop;
    e = e || 0, n = n || this.points.length - e;
    for (const a of s)
      r &= o(t, this, a, { start: e, end: e + n - 1 });
    return !!r;
  }
  draw(t, e, n, s) {
    const o = this.options || {};
    (this.points || []).length && o.borderWidth && (t.save(), zc(t, this, n, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
Mt.id = "line";
Mt.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
};
Mt.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
Mt.descriptors = {
  _scriptable: !0,
  _indexable: (i) => i !== "borderDash" && i !== "fill"
};
function fs(i, t, e, n) {
  const s = i.options, { [e]: o } = i.getProps([e], n);
  return Math.abs(t - o) < s.radius + s.hitRadius;
}
class li extends rt {
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, e, n) {
    const s = this.options, { x: o, y: r } = this.getProps(["x", "y"], n);
    return Math.pow(t - o, 2) + Math.pow(e - r, 2) < Math.pow(s.hitRadius + s.radius, 2);
  }
  inXRange(t, e) {
    return fs(this, t, "x", e);
  }
  inYRange(t, e) {
    return fs(this, t, "y", e);
  }
  getCenterPoint(t) {
    const { x: e, y: n } = this.getProps(["x", "y"], t);
    return { x: e, y: n };
  }
  size(t) {
    t = t || this.options || {};
    let e = t.radius || 0;
    e = Math.max(e, e && t.hoverRadius || 0);
    const n = e && t.borderWidth || 0;
    return (e + n) * 2;
  }
  draw(t, e) {
    const n = this.options;
    this.skip || n.radius < 0.1 || !fe(this, e, this.size(n) / 2) || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, Wi(t, n, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
li.id = "point";
li.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
li.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function No(i, t) {
  const { x: e, y: n, base: s, width: o, height: r } = i.getProps(["x", "y", "base", "width", "height"], t);
  let a, l, c, h, d;
  return i.horizontal ? (d = r / 2, a = Math.min(e, s), l = Math.max(e, s), c = n - d, h = n + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(n, s), h = Math.max(n, s)), { left: a, top: c, right: l, bottom: h };
}
function yt(i, t, e, n) {
  return i ? 0 : X(t, e, n);
}
function Bc(i, t, e) {
  const n = i.options.borderWidth, s = i.borderSkipped, o = ro(n);
  return {
    t: yt(s.top, o.top, 0, e),
    r: yt(s.right, o.right, 0, t),
    b: yt(s.bottom, o.bottom, 0, e),
    l: yt(s.left, o.left, 0, t)
  };
}
function Vc(i, t, e) {
  const { enableBorderRadius: n } = i.getProps(["enableBorderRadius"]), s = i.options.borderRadius, o = Pt(s), r = Math.min(t, e), a = i.borderSkipped, l = n || O(s);
  return {
    topLeft: yt(!l || a.top || a.left, o.topLeft, 0, r),
    topRight: yt(!l || a.top || a.right, o.topRight, 0, r),
    bottomLeft: yt(!l || a.bottom || a.left, o.bottomLeft, 0, r),
    bottomRight: yt(!l || a.bottom || a.right, o.bottomRight, 0, r)
  };
}
function Wc(i) {
  const t = No(i), e = t.right - t.left, n = t.bottom - t.top, s = Bc(i, e / 2, n / 2), o = Vc(i, e / 2, n / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: e,
      h: n,
      radius: o
    },
    inner: {
      x: t.left + s.l,
      y: t.top + s.t,
      w: e - s.l - s.r,
      h: n - s.t - s.b,
      radius: {
        topLeft: Math.max(0, o.topLeft - Math.max(s.t, s.l)),
        topRight: Math.max(0, o.topRight - Math.max(s.t, s.r)),
        bottomLeft: Math.max(0, o.bottomLeft - Math.max(s.b, s.l)),
        bottomRight: Math.max(0, o.bottomRight - Math.max(s.b, s.r))
      }
    }
  };
}
function Ei(i, t, e, n) {
  const s = t === null, o = e === null, a = i && !(s && o) && No(i, n);
  return a && (s || pt(t, a.left, a.right)) && (o || pt(e, a.top, a.bottom));
}
function Hc(i) {
  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;
}
function jc(i, t) {
  i.rect(t.x, t.y, t.w, t.h);
}
function Ai(i, t, e = {}) {
  const n = i.x !== e.x ? -t : 0, s = i.y !== e.y ? -t : 0, o = (i.x + i.w !== e.x + e.w ? t : 0) - n, r = (i.y + i.h !== e.y + e.h ? t : 0) - s;
  return {
    x: i.x + n,
    y: i.y + s,
    w: i.w + o,
    h: i.h + r,
    radius: i.radius
  };
}
class ci extends rt {
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: e, options: { borderColor: n, backgroundColor: s } } = this, { inner: o, outer: r } = Wc(this), a = Hc(r.radius) ? ge : jc;
    t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, Ai(r, e, o)), t.clip(), a(t, Ai(o, -e, r)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), a(t, Ai(o, e)), t.fillStyle = s, t.fill(), t.restore();
  }
  inRange(t, e, n) {
    return Ei(this, t, e, n);
  }
  inXRange(t, e) {
    return Ei(this, t, null, e);
  }
  inYRange(t, e) {
    return Ei(this, null, t, e);
  }
  getCenterPoint(t) {
    const { x: e, y: n, base: s, horizontal: o } = this.getProps(["x", "y", "base", "horizontal"], t);
    return {
      x: o ? (e + s) / 2 : e,
      y: o ? n : (n + s) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
ci.id = "bar";
ci.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
ci.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function $c(i, t, e, n, s) {
  const o = s.samples || n;
  if (o >= e)
    return i.slice(t, t + e);
  const r = [], a = (e - 2) / (o - 2);
  let l = 0;
  const c = t + e - 1;
  let h = t, d, u, f, g, p;
  for (r[l++] = i[h], d = 0; d < o - 2; d++) {
    let m = 0, b = 0, _;
    const v = Math.floor((d + 1) * a) + 1 + t, y = Math.min(Math.floor((d + 2) * a) + 1, e) + t, x = y - v;
    for (_ = v; _ < y; _++)
      m += i[_].x, b += i[_].y;
    m /= x, b /= x;
    const k = Math.floor(d * a) + 1 + t, w = Math.min(Math.floor((d + 1) * a) + 1, e) + t, { x: M, y: S } = i[h];
    for (f = g = -1, _ = k; _ < w; _++)
      g = 0.5 * Math.abs(
        (M - m) * (i[_].y - S) - (M - i[_].x) * (b - S)
      ), g > f && (f = g, u = i[_], p = _);
    r[l++] = u, h = p;
  }
  return r[l++] = i[c], r;
}
function Yc(i, t, e, n) {
  let s = 0, o = 0, r, a, l, c, h, d, u, f, g, p;
  const m = [], b = t + e - 1, _ = i[t].x, y = i[b].x - _;
  for (r = t; r < t + e; ++r) {
    a = i[r], l = (a.x - _) / y * n, c = a.y;
    const x = l | 0;
    if (x === h)
      c < g ? (g = c, d = r) : c > p && (p = c, u = r), s = (o * s + a.x) / ++o;
    else {
      const k = r - 1;
      if (!L(d) && !L(u)) {
        const w = Math.min(d, u), M = Math.max(d, u);
        w !== f && w !== k && m.push({
          ...i[w],
          x: s
        }), M !== f && M !== k && m.push({
          ...i[M],
          x: s
        });
      }
      r > 0 && k !== f && m.push(i[k]), m.push(a), h = x, o = 0, g = p = c, d = u = f = r;
    }
  }
  return m;
}
function zo(i) {
  if (i._decimated) {
    const t = i._data;
    delete i._decimated, delete i._data, Object.defineProperty(i, "data", { value: t });
  }
}
function gs(i) {
  i.data.datasets.forEach((t) => {
    zo(t);
  });
}
function Uc(i, t) {
  const e = t.length;
  let n = 0, s;
  const { iScale: o } = i, { min: r, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();
  return l && (n = X(mt(t, o.axis, r).lo, 0, e - 1)), c ? s = X(mt(t, o.axis, a).hi + 1, n, e) - n : s = e - n, { start: n, count: s };
}
var Xc = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (i, t, e) => {
    if (!e.enabled) {
      gs(i);
      return;
    }
    const n = i.width;
    i.data.datasets.forEach((s, o) => {
      const { _data: r, indexAxis: a } = s, l = i.getDatasetMeta(o), c = r || s.data;
      if (ne([a, i.options.indexAxis]) === "y" || !l.controller.supportsDecimation)
        return;
      const h = i.scales[l.xAxisID];
      if (h.type !== "linear" && h.type !== "time" || i.options.parsing)
        return;
      let { start: d, count: u } = Uc(l, c);
      const f = e.threshold || 4 * n;
      if (u <= f) {
        zo(s);
        return;
      }
      L(r) && (s._data = c, delete s.data, Object.defineProperty(s, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(p) {
          this._data = p;
        }
      }));
      let g;
      switch (e.algorithm) {
        case "lttb":
          g = $c(c, d, u, n, e);
          break;
        case "min-max":
          g = Yc(c, d, u, n);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);
      }
      s._decimated = g;
    });
  },
  destroy(i) {
    gs(i);
  }
};
function Kc(i, t, e) {
  const n = i.segments, s = i.points, o = t.points, r = [];
  for (const a of n) {
    let { start: l, end: c } = a;
    c = un(l, c, s);
    const h = Xi(e, s[l], s[c], a.loop);
    if (!t.segments) {
      r.push({
        source: a,
        target: h,
        start: s[l],
        end: s[c]
      });
      continue;
    }
    const d = xo(t, h);
    for (const u of d) {
      const f = Xi(e, o[u.start], o[u.end], u.loop), g = _o(a, s, f);
      for (const p of g)
        r.push({
          source: p,
          target: u,
          start: {
            [e]: ps(h, f, "start", Math.max)
          },
          end: {
            [e]: ps(h, f, "end", Math.min)
          }
        });
    }
  }
  return r;
}
function Xi(i, t, e, n) {
  if (n)
    return;
  let s = t[i], o = e[i];
  return i === "angle" && (s = J(s), o = J(o)), { property: i, start: s, end: o };
}
function qc(i, t) {
  const { x: e = null, y: n = null } = i || {}, s = t.points, o = [];
  return t.segments.forEach(({ start: r, end: a }) => {
    a = un(r, a, s);
    const l = s[r], c = s[a];
    n !== null ? (o.push({ x: l.x, y: n }), o.push({ x: c.x, y: n })) : e !== null && (o.push({ x: e, y: l.y }), o.push({ x: e, y: c.y }));
  }), o;
}
function un(i, t, e) {
  for (; t > i; t--) {
    const n = e[t];
    if (!isNaN(n.x) && !isNaN(n.y))
      break;
  }
  return t;
}
function ps(i, t, e, n) {
  return i && t ? n(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;
}
function Bo(i, t) {
  let e = [], n = !1;
  return B(i) ? (n = !0, e = i) : e = qc(i, t), e.length ? new Mt({
    points: e,
    options: { tension: 0 },
    _loop: n,
    _fullLoop: n
  }) : null;
}
function ms(i) {
  return i && i.fill !== !1;
}
function Gc(i, t, e) {
  let s = i[t].fill;
  const o = [t];
  let r;
  if (!e)
    return s;
  for (; s !== !1 && o.indexOf(s) === -1; ) {
    if (!j(s))
      return s;
    if (r = i[s], !r)
      return !1;
    if (r.visible)
      return s;
    o.push(s), s = r.fill;
  }
  return !1;
}
function Qc(i, t, e) {
  const n = eh(i);
  if (O(n))
    return isNaN(n.value) ? !1 : n;
  let s = parseFloat(n);
  return j(s) && Math.floor(s) === s ? Zc(n[0], t, s, e) : ["origin", "start", "end", "stack", "shape"].indexOf(n) >= 0 && n;
}
function Zc(i, t, e, n) {
  return (i === "-" || i === "+") && (e = t + e), e === t || e < 0 || e >= n ? !1 : e;
}
function Jc(i, t) {
  let e = null;
  return i === "start" ? e = t.bottom : i === "end" ? e = t.top : O(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;
}
function th(i, t, e) {
  let n;
  return i === "start" ? n = e : i === "end" ? n = t.options.reverse ? t.min : t.max : O(i) ? n = i.value : n = t.getBaseValue(), n;
}
function eh(i) {
  const t = i.options, e = t.fill;
  let n = A(e && e.target, e);
  return n === void 0 && (n = !!t.backgroundColor), n === !1 || n === null ? !1 : n === !0 ? "origin" : n;
}
function ih(i) {
  const { scale: t, index: e, line: n } = i, s = [], o = n.segments, r = n.points, a = nh(t, e);
  a.push(Bo({ x: null, y: t.bottom }, n));
  for (let l = 0; l < o.length; l++) {
    const c = o[l];
    for (let h = c.start; h <= c.end; h++)
      sh(s, r[h], a);
  }
  return new Mt({ points: s, options: {} });
}
function nh(i, t) {
  const e = [], n = i.getMatchingVisibleMetas("line");
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    if (o.index === t)
      break;
    o.hidden || e.unshift(o.dataset);
  }
  return e;
}
function sh(i, t, e) {
  const n = [];
  for (let s = 0; s < e.length; s++) {
    const o = e[s], { first: r, last: a, point: l } = oh(o, t, "x");
    if (!(!l || r && a)) {
      if (r)
        n.unshift(l);
      else if (i.push(l), !a)
        break;
    }
  }
  i.push(...n);
}
function oh(i, t, e) {
  const n = i.interpolate(t, e);
  if (!n)
    return {};
  const s = n[e], o = i.segments, r = i.points;
  let a = !1, l = !1;
  for (let c = 0; c < o.length; c++) {
    const h = o[c], d = r[h.start][e], u = r[h.end][e];
    if (pt(s, d, u)) {
      a = s === d, l = s === u;
      break;
    }
  }
  return { first: a, last: l, point: n };
}
class Vo {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, e, n) {
    const { x: s, y: o, radius: r } = this;
    return e = e || { start: 0, end: N }, t.arc(s, o, r, e.end, e.start, !0), !n.bounds;
  }
  interpolate(t) {
    const { x: e, y: n, radius: s } = this, o = t.angle;
    return {
      x: e + Math.cos(o) * s,
      y: n + Math.sin(o) * s,
      angle: o
    };
  }
}
function rh(i) {
  const { chart: t, fill: e, line: n } = i;
  if (j(e))
    return ah(t, e);
  if (e === "stack")
    return ih(i);
  if (e === "shape")
    return !0;
  const s = lh(i);
  return s instanceof Vo ? s : Bo(s, n);
}
function ah(i, t) {
  const e = i.getDatasetMeta(t);
  return e && i.isDatasetVisible(t) ? e.dataset : null;
}
function lh(i) {
  return (i.scale || {}).getPointPositionForValue ? hh(i) : ch(i);
}
function ch(i) {
  const { scale: t = {}, fill: e } = i, n = Jc(e, t);
  if (j(n)) {
    const s = t.isHorizontal();
    return {
      x: s ? n : null,
      y: s ? null : n
    };
  }
  return null;
}
function hh(i) {
  const { scale: t, fill: e } = i, n = t.options, s = t.getLabels().length, o = n.reverse ? t.max : t.min, r = th(e, t, o), a = [];
  if (n.grid.circular) {
    const l = t.getPointPositionForValue(0, o);
    return new Vo({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(r)
    });
  }
  for (let l = 0; l < s; ++l)
    a.push(t.getPointPositionForValue(l, r));
  return a;
}
function Oi(i, t, e) {
  const n = rh(t), { line: s, scale: o, axis: r } = t, a = s.options, l = a.fill, c = a.backgroundColor, { above: h = c, below: d = c } = l || {};
  n && s.points.length && (ii(i, e), dh(i, { line: s, target: n, above: h, below: d, area: e, scale: o, axis: r }), ni(i));
}
function dh(i, t) {
  const { line: e, target: n, above: s, below: o, area: r, scale: a } = t, l = e._loop ? "angle" : t.axis;
  i.save(), l === "x" && o !== s && (bs(i, n, r.top), _s(i, { line: e, target: n, color: s, scale: a, property: l }), i.restore(), i.save(), bs(i, n, r.bottom)), _s(i, { line: e, target: n, color: o, scale: a, property: l }), i.restore();
}
function bs(i, t, e) {
  const { segments: n, points: s } = t;
  let o = !0, r = !1;
  i.beginPath();
  for (const a of n) {
    const { start: l, end: c } = a, h = s[l], d = s[un(l, c, s)];
    o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, { move: r }), r ? i.closePath() : i.lineTo(d.x, e);
  }
  i.lineTo(t.first().x, e), i.closePath(), i.clip();
}
function _s(i, t) {
  const { line: e, target: n, property: s, color: o, scale: r } = t, a = Kc(e, n, s);
  for (const { source: l, target: c, start: h, end: d } of a) {
    const { style: { backgroundColor: u = o } = {} } = l, f = n !== !0;
    i.save(), i.fillStyle = u, uh(i, r, f && Xi(s, h, d)), i.beginPath();
    const g = !!e.pathSegment(i, l);
    let p;
    if (f) {
      g ? i.closePath() : xs(i, n, d, s);
      const m = !!n.pathSegment(i, c, { move: g, reverse: !0 });
      p = g && m, p || xs(i, n, h, s);
    }
    i.closePath(), i.fill(p ? "evenodd" : "nonzero"), i.restore();
  }
}
function uh(i, t, e) {
  const { top: n, bottom: s } = t.chart.chartArea, { property: o, start: r, end: a } = e || {};
  o === "x" && (i.beginPath(), i.rect(r, n, a - r, s - n), i.clip());
}
function xs(i, t, e, n) {
  const s = t.interpolate(e, n);
  s && i.lineTo(s.x, s.y);
}
var fh = {
  id: "filler",
  afterDatasetsUpdate(i, t, e) {
    const n = (i.data.datasets || []).length, s = [];
    let o, r, a, l;
    for (r = 0; r < n; ++r)
      o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof Mt && (l = {
        visible: i.isDatasetVisible(r),
        index: r,
        fill: Qc(a, r, n),
        chart: i,
        axis: o.controller.options.indexAxis,
        scale: o.vScale,
        line: a
      }), o.$filler = l, s.push(l);
    for (r = 0; r < n; ++r)
      l = s[r], !(!l || l.fill === !1) && (l.fill = Gc(s, r, e.propagate));
  },
  beforeDraw(i, t, e) {
    const n = e.drawTime === "beforeDraw", s = i.getSortedVisibleDatasetMetas(), o = i.chartArea;
    for (let r = s.length - 1; r >= 0; --r) {
      const a = s[r].$filler;
      a && (a.line.updateControlPoints(o, a.axis), n && a.fill && Oi(i.ctx, a, o));
    }
  },
  beforeDatasetsDraw(i, t, e) {
    if (e.drawTime !== "beforeDatasetsDraw")
      return;
    const n = i.getSortedVisibleDatasetMetas();
    for (let s = n.length - 1; s >= 0; --s) {
      const o = n[s].$filler;
      ms(o) && Oi(i.ctx, o, i.chartArea);
    }
  },
  beforeDatasetDraw(i, t, e) {
    const n = t.meta.$filler;
    !ms(n) || e.drawTime !== "beforeDatasetDraw" || Oi(i.ctx, n, i.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const ys = (i, t) => {
  let { boxHeight: e = t, boxWidth: n = t } = i;
  return i.usePointStyle && (e = Math.min(e, t), n = i.pointStyleWidth || Math.min(n, t)), {
    boxWidth: n,
    boxHeight: e,
    itemHeight: Math.max(t, e)
  };
}, gh = (i, t) => i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;
class vs extends rt {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e, n) {
    this.maxWidth = t, this.maxHeight = e, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let e = z(t.generateLabels, [this.chart], this) || [];
    t.filter && (e = e.filter((n) => t.filter(n, this.chart.data))), t.sort && (e = e.sort((n, s) => t.sort(n, s, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;
  }
  fit() {
    const { options: t, ctx: e } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const n = t.labels, s = U(n.font), o = s.size, r = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = ys(n, o);
    let c, h;
    e.font = s.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, o, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, e, n, s) {
    const { ctx: o, maxWidth: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], h = s + a;
    let d = t;
    o.textAlign = "left", o.textBaseline = "middle";
    let u = -1, f = -h;
    return this.legendItems.forEach((g, p) => {
      const m = n + e / 2 + o.measureText(g.text).width;
      (p === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (p > 0 ? 0 : 1)] = 0, f += h, u++), l[p] = { left: 0, top: f, row: u, width: m, height: s }, c[c.length - 1] += m + a;
    }), d;
  }
  _fitCols(t, e, n, s) {
    const { ctx: o, maxHeight: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = r - t;
    let d = a, u = 0, f = 0, g = 0, p = 0;
    return this.legendItems.forEach((m, b) => {
      const _ = n + e / 2 + o.measureText(m.text).width;
      b > 0 && f + s + 2 * a > h && (d += u + a, c.push({ width: u, height: f }), g += u + a, p++, u = f = 0), l[b] = { left: g, top: f, col: p, width: _, height: s }, u = Math.max(u, _), f += s + a;
    }), d += u, c.push({ width: u, height: f }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: n, labels: { padding: s }, rtl: o } } = this, r = jt(o, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = K(n, this.left + s, this.right - this.lineWidths[a]);
      for (const c of e)
        a !== c.row && (a = c.row, l = K(n, this.left + s, this.right - this.lineWidths[a])), c.top += this.top + t + s, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + s;
    } else {
      let a = 0, l = K(n, this.top + t + s, this.bottom - this.columnSizes[a].height);
      for (const c of e)
        c.col !== a && (a = c.col, l = K(n, this.top + t + s, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + s, c.left = r.leftForLtr(r.x(c.left), c.width), l += c.height + s;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      ii(t, this), this._draw(), ni(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: e, lineWidths: n, ctx: s } = this, { align: o, labels: r } = t, a = T.color, l = jt(t.rtl, this.left, this.width), c = U(r.font), { color: h, padding: d } = r, u = c.size, f = u / 2;
    let g;
    this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = 0.5, s.font = c.string;
    const { boxWidth: p, boxHeight: m, itemHeight: b } = ys(r, u), _ = function(w, M, S) {
      if (isNaN(p) || p <= 0 || isNaN(m) || m < 0)
        return;
      s.save();
      const I = A(S.lineWidth, 1);
      if (s.fillStyle = A(S.fillStyle, a), s.lineCap = A(S.lineCap, "butt"), s.lineDashOffset = A(S.lineDashOffset, 0), s.lineJoin = A(S.lineJoin, "miter"), s.lineWidth = I, s.strokeStyle = A(S.strokeStyle, a), s.setLineDash(A(S.lineDash, [])), r.usePointStyle) {
        const R = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: S.pointStyle,
          rotation: S.rotation,
          borderWidth: I
        }, D = l.xPlus(w, p / 2), $ = M + f;
        oo(s, R, D, $, r.pointStyleWidth && p);
      } else {
        const R = M + Math.max((u - m) / 2, 0), D = l.leftForLtr(w, p), $ = Pt(S.borderRadius);
        s.beginPath(), Object.values($).some((Q) => Q !== 0) ? ge(s, {
          x: D,
          y: R,
          w: p,
          h: m,
          radius: $
        }) : s.rect(D, R, p, m), s.fill(), I !== 0 && s.stroke();
      }
      s.restore();
    }, v = function(w, M, S) {
      It(s, S.text, w, M + b / 2, c, {
        strikethrough: S.hidden,
        textAlign: l.textAlign(S.textAlign)
      });
    }, y = this.isHorizontal(), x = this._computeTitleHeight();
    y ? g = {
      x: K(o, this.left + d, this.right - n[0]),
      y: this.top + d + x,
      line: 0
    } : g = {
      x: this.left + d,
      y: K(o, this.top + x + d, this.bottom - e[0].height),
      line: 0
    }, po(this.ctx, t.textDirection);
    const k = b + d;
    this.legendItems.forEach((w, M) => {
      s.strokeStyle = w.fontColor || h, s.fillStyle = w.fontColor || h;
      const S = s.measureText(w.text).width, I = l.textAlign(w.textAlign || (w.textAlign = r.textAlign)), R = p + f + S;
      let D = g.x, $ = g.y;
      l.setWidth(this.width), y ? M > 0 && D + R + d > this.right && ($ = g.y += k, g.line++, D = g.x = K(o, this.left + d, this.right - n[g.line])) : M > 0 && $ + k > this.bottom && (D = g.x = D + e[g.line].width + d, g.line++, $ = g.y = K(o, this.top + x + d, this.bottom - e[g.line].height));
      const Q = l.x(D);
      _(Q, $, w), D = Er(I, D + p + f, y ? D + R : this.right, t.rtl), v(l.x(D), $, w), y ? g.x += R + d : g.y += k;
    }), mo(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, e = t.title, n = U(e.font), s = G(e.padding);
    if (!e.display)
      return;
    const o = jt(t.rtl, this.left, this.width), r = this.ctx, a = e.position, l = n.size / 2, c = s.top + l;
    let h, d = this.left, u = this.width;
    if (this.isHorizontal())
      u = Math.max(...this.lineWidths), h = this.top + c, d = K(t.align, d, this.right - u);
    else {
      const g = this.columnSizes.reduce((p, m) => Math.max(p, m.height), 0);
      h = c + K(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
    }
    const f = K(a, d, d + u);
    r.textAlign = o.textAlign(nn(a)), r.textBaseline = "middle", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = n.string, It(r, e.text, f, h, n);
  }
  _computeTitleHeight() {
    const t = this.options.title, e = U(t.font), n = G(t.padding);
    return t.display ? e.lineHeight + n.height : 0;
  }
  _getLegendItemAt(t, e) {
    let n, s, o;
    if (pt(t, this.left, this.right) && pt(e, this.top, this.bottom)) {
      for (o = this.legendHitBoxes, n = 0; n < o.length; ++n)
        if (s = o[n], pt(t, s.left, s.left + s.width) && pt(e, s.top, s.top + s.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(t) {
    const e = this.options;
    if (!ph(t.type, e))
      return;
    const n = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const s = this._hoveredItem, o = gh(s, n);
      s && !o && z(e.onLeave, [t, s, this], this), this._hoveredItem = n, n && !o && z(e.onHover, [t, n, this], this);
    } else
      n && z(e.onClick, [t, n, this], this);
  }
}
function ph(i, t) {
  return !!((i === "mousemove" || i === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (i === "click" || i === "mouseup"));
}
var mh = {
  id: "legend",
  _element: vs,
  start(i, t, e) {
    const n = i.legend = new vs({ ctx: i.ctx, options: e, chart: i });
    q.configure(i, n, e), q.addBox(i, n);
  },
  stop(i) {
    q.removeBox(i, i.legend), delete i.legend;
  },
  beforeUpdate(i, t, e) {
    const n = i.legend;
    q.configure(i, n, e), n.options = e;
  },
  afterUpdate(i) {
    const t = i.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(i, t) {
    t.replay || i.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(i, t, e) {
      const n = t.datasetIndex, s = e.chart;
      s.isDatasetVisible(n) ? (s.hide(n), t.hidden = !0) : (s.show(n), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (i) => i.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(i) {
        const t = i.data.datasets, { labels: { usePointStyle: e, pointStyle: n, textAlign: s, color: o } } = i.legend.options;
        return i._getSortedDatasetMetas().map((r) => {
          const a = r.controller.getStyle(e ? 0 : void 0), l = G(a.borderWidth);
          return {
            text: t[r.index].label,
            fillStyle: a.backgroundColor,
            fontColor: o,
            hidden: !r.visible,
            lineCap: a.borderCapStyle,
            lineDash: a.borderDash,
            lineDashOffset: a.borderDashOffset,
            lineJoin: a.borderJoinStyle,
            lineWidth: (l.width + l.height) / 4,
            strokeStyle: a.borderColor,
            pointStyle: n || a.pointStyle,
            rotation: a.rotation,
            textAlign: s || a.textAlign,
            borderRadius: 0,
            datasetIndex: r.index
          };
        }, this);
      }
    },
    title: {
      color: (i) => i.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (i) => !i.startsWith("on"),
    labels: {
      _scriptable: (i) => !["generateLabels", "filter", "sort"].includes(i)
    }
  }
};
class fn extends rt {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e) {
    const n = this.options;
    if (this.left = 0, this.top = 0, !n.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = e;
    const s = B(n.text) ? n.text.length : 1;
    this._padding = G(n.padding);
    const o = s * U(n.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = o : this.width = o;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: e, left: n, bottom: s, right: o, options: r } = this, a = r.align;
    let l = 0, c, h, d;
    return this.isHorizontal() ? (h = K(a, n, o), d = e + t, c = o - n) : (r.position === "left" ? (h = n + t, d = K(a, s, e), l = V * -0.5) : (h = o - t, d = K(a, e, s), l = V * 0.5), c = s - e), { titleX: h, titleY: d, maxWidth: c, rotation: l };
  }
  draw() {
    const t = this.ctx, e = this.options;
    if (!e.display)
      return;
    const n = U(e.font), o = n.lineHeight / 2 + this._padding.top, { titleX: r, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);
    It(t, e.text, 0, 0, n, {
      color: e.color,
      maxWidth: l,
      rotation: c,
      textAlign: nn(e.align),
      textBaseline: "middle",
      translation: [r, a]
    });
  }
}
function bh(i, t) {
  const e = new fn({
    ctx: i.ctx,
    options: t,
    chart: i
  });
  q.configure(i, e, t), q.addBox(i, e), i.titleBlock = e;
}
var _h = {
  id: "title",
  _element: fn,
  start(i, t, e) {
    bh(i, e);
  },
  stop(i) {
    const t = i.titleBlock;
    q.removeBox(i, t), delete i.titleBlock;
  },
  beforeUpdate(i, t, e) {
    const n = i.titleBlock;
    q.configure(i, n, e), n.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Be = /* @__PURE__ */ new WeakMap();
var xh = {
  id: "subtitle",
  start(i, t, e) {
    const n = new fn({
      ctx: i.ctx,
      options: e,
      chart: i
    });
    q.configure(i, n, e), q.addBox(i, n), Be.set(i, n);
  },
  stop(i) {
    q.removeBox(i, Be.get(i)), Be.delete(i);
  },
  beforeUpdate(i, t, e) {
    const n = Be.get(i);
    q.configure(i, n, e), n.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const he = {
  average(i) {
    if (!i.length)
      return !1;
    let t, e, n = 0, s = 0, o = 0;
    for (t = 0, e = i.length; t < e; ++t) {
      const r = i[t].element;
      if (r && r.hasValue()) {
        const a = r.tooltipPosition();
        n += a.x, s += a.y, ++o;
      }
    }
    return {
      x: n / o,
      y: s / o
    };
  },
  nearest(i, t) {
    if (!i.length)
      return !1;
    let e = t.x, n = t.y, s = Number.POSITIVE_INFINITY, o, r, a;
    for (o = 0, r = i.length; o < r; ++o) {
      const l = i[o].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), h = zi(t, c);
        h < s && (s = h, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      e = l.x, n = l.y;
    }
    return {
      x: e,
      y: n
    };
  }
};
function at(i, t) {
  return t && (B(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;
}
function ft(i) {
  return (typeof i == "string" || i instanceof String) && i.indexOf(`
`) > -1 ? i.split(`
`) : i;
}
function yh(i, t) {
  const { element: e, datasetIndex: n, index: s } = t, o = i.getDatasetMeta(n).controller, { label: r, value: a } = o.getLabelAndValue(s);
  return {
    chart: i,
    label: r,
    parsed: o.getParsed(s),
    raw: i.data.datasets[n].data[s],
    formattedValue: a,
    dataset: o.getDataset(),
    dataIndex: s,
    datasetIndex: n,
    element: e
  };
}
function ks(i, t) {
  const e = i.chart.ctx, { body: n, footer: s, title: o } = i, { boxWidth: r, boxHeight: a } = t, l = U(t.bodyFont), c = U(t.titleFont), h = U(t.footerFont), d = o.length, u = s.length, f = n.length, g = G(t.padding);
  let p = g.height, m = 0, b = n.reduce((y, x) => y + x.before.length + x.lines.length + x.after.length, 0);
  if (b += i.beforeBody.length + i.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {
    const y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    p += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;
  }
  u && (p += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);
  let _ = 0;
  const v = function(y) {
    m = Math.max(m, e.measureText(y).width + _);
  };
  return e.save(), e.font = c.string, F(i.title, v), e.font = l.string, F(i.beforeBody.concat(i.afterBody), v), _ = t.displayColors ? r + 2 + t.boxPadding : 0, F(n, (y) => {
    F(y.before, v), F(y.lines, v), F(y.after, v);
  }), _ = 0, e.font = h.string, F(i.footer, v), e.restore(), m += g.width, { width: m, height: p };
}
function vh(i, t) {
  const { y: e, height: n } = t;
  return e < n / 2 ? "top" : e > i.height - n / 2 ? "bottom" : "center";
}
function kh(i, t, e, n) {
  const { x: s, width: o } = n, r = e.caretSize + e.caretPadding;
  if (i === "left" && s + o + r > t.width || i === "right" && s - o - r < 0)
    return !0;
}
function wh(i, t, e, n) {
  const { x: s, width: o } = e, { width: r, chartArea: { left: a, right: l } } = i;
  let c = "center";
  return n === "center" ? c = s <= (a + l) / 2 ? "left" : "right" : s <= o / 2 ? c = "left" : s >= r - o / 2 && (c = "right"), kh(c, i, t, e) && (c = "center"), c;
}
function ws(i, t, e) {
  const n = e.yAlign || t.yAlign || vh(i, e);
  return {
    xAlign: e.xAlign || t.xAlign || wh(i, t, e, n),
    yAlign: n
  };
}
function Sh(i, t) {
  let { x: e, width: n } = i;
  return t === "right" ? e -= n : t === "center" && (e -= n / 2), e;
}
function Mh(i, t, e) {
  let { y: n, height: s } = i;
  return t === "top" ? n += e : t === "bottom" ? n -= s + e : n -= s / 2, n;
}
function Ss(i, t, e, n) {
  const { caretSize: s, caretPadding: o, cornerRadius: r } = i, { xAlign: a, yAlign: l } = e, c = s + o, { topLeft: h, topRight: d, bottomLeft: u, bottomRight: f } = Pt(r);
  let g = Sh(t, a);
  const p = Mh(t, l, c);
  return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(h, u) + s : a === "right" && (g += Math.max(d, f) + s), {
    x: X(g, 0, n.width - t.width),
    y: X(p, 0, n.height - t.height)
  };
}
function Ve(i, t, e) {
  const n = G(e.padding);
  return t === "center" ? i.x + i.width / 2 : t === "right" ? i.x + i.width - n.right : i.x + n.left;
}
function Ms(i) {
  return at([], ft(i));
}
function Ch(i, t, e) {
  return St(i, {
    tooltip: t,
    tooltipItems: e,
    type: "tooltip"
  });
}
function Cs(i, t) {
  const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return e ? i.override(e) : i;
}
class Ki extends rt {
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const e = this.chart, n = this.options.setContext(this.getContext()), s = n.enabled && e.options.animation && n.animations, o = new yo(this.chart, s);
    return s._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = Ch(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, e) {
    const { callbacks: n } = e, s = n.beforeTitle.apply(this, [t]), o = n.title.apply(this, [t]), r = n.afterTitle.apply(this, [t]);
    let a = [];
    return a = at(a, ft(s)), a = at(a, ft(o)), a = at(a, ft(r)), a;
  }
  getBeforeBody(t, e) {
    return Ms(e.callbacks.beforeBody.apply(this, [t]));
  }
  getBody(t, e) {
    const { callbacks: n } = e, s = [];
    return F(t, (o) => {
      const r = {
        before: [],
        lines: [],
        after: []
      }, a = Cs(n, o);
      at(r.before, ft(a.beforeLabel.call(this, o))), at(r.lines, a.label.call(this, o)), at(r.after, ft(a.afterLabel.call(this, o))), s.push(r);
    }), s;
  }
  getAfterBody(t, e) {
    return Ms(e.callbacks.afterBody.apply(this, [t]));
  }
  getFooter(t, e) {
    const { callbacks: n } = e, s = n.beforeFooter.apply(this, [t]), o = n.footer.apply(this, [t]), r = n.afterFooter.apply(this, [t]);
    let a = [];
    return a = at(a, ft(s)), a = at(a, ft(o)), a = at(a, ft(r)), a;
  }
  _createItems(t) {
    const e = this._active, n = this.chart.data, s = [], o = [], r = [];
    let a = [], l, c;
    for (l = 0, c = e.length; l < c; ++l)
      a.push(yh(this.chart, e[l]));
    return t.filter && (a = a.filter((h, d, u) => t.filter(h, d, u, n))), t.itemSort && (a = a.sort((h, d) => t.itemSort(h, d, n))), F(a, (h) => {
      const d = Cs(t.callbacks, h);
      s.push(d.labelColor.call(this, h)), o.push(d.labelPointStyle.call(this, h)), r.push(d.labelTextColor.call(this, h));
    }), this.labelColors = s, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;
  }
  update(t, e) {
    const n = this.options.setContext(this.getContext()), s = this._active;
    let o, r = [];
    if (!s.length)
      this.opacity !== 0 && (o = {
        opacity: 0
      });
    else {
      const a = he[n.position].call(this, s, this._eventPosition);
      r = this._createItems(n), this.title = this.getTitle(r, n), this.beforeBody = this.getBeforeBody(r, n), this.body = this.getBody(r, n), this.afterBody = this.getAfterBody(r, n), this.footer = this.getFooter(r, n);
      const l = this._size = ks(this, n), c = Object.assign({}, a, l), h = ws(this.chart, n, c), d = Ss(n, c, h, this.chart);
      this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && n.external && n.external.call(this, { chart: this.chart, tooltip: this, replay: e });
  }
  drawCaret(t, e, n, s) {
    const o = this.getCaretPosition(t, n, s);
    e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);
  }
  getCaretPosition(t, e, n) {
    const { xAlign: s, yAlign: o } = this, { caretSize: r, cornerRadius: a } = n, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: d } = Pt(a), { x: u, y: f } = t, { width: g, height: p } = e;
    let m, b, _, v, y, x;
    return o === "center" ? (y = f + p / 2, s === "left" ? (m = u, b = m - r, v = y + r, x = y - r) : (m = u + g, b = m + r, v = y - r, x = y + r), _ = m) : (s === "left" ? b = u + Math.max(l, h) + r : s === "right" ? b = u + g - Math.max(c, d) - r : b = this.caretX, o === "top" ? (v = f, y = v - r, m = b - r, _ = b + r) : (v = f + p, y = v + r, m = b + r, _ = b - r), x = v), { x1: m, x2: b, x3: _, y1: v, y2: y, y3: x };
  }
  drawTitle(t, e, n) {
    const s = this.title, o = s.length;
    let r, a, l;
    if (o) {
      const c = jt(n.rtl, this.x, this.width);
      for (t.x = Ve(this, n.titleAlign, n), e.textAlign = c.textAlign(n.titleAlign), e.textBaseline = "middle", r = U(n.titleFont), a = n.titleSpacing, e.fillStyle = n.titleColor, e.font = r.string, l = 0; l < o; ++l)
        e.fillText(s[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += n.titleMarginBottom - a);
    }
  }
  _drawColorBox(t, e, n, s, o) {
    const r = this.labelColors[n], a = this.labelPointStyles[n], { boxHeight: l, boxWidth: c, boxPadding: h } = o, d = U(o.bodyFont), u = Ve(this, "left", o), f = s.x(u), g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, p = e.y + g;
    if (o.usePointStyle) {
      const m = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, b = s.leftForLtr(f, c) + c / 2, _ = p + l / 2;
      t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Wi(t, m, b, _), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Wi(t, m, b, _);
    } else {
      t.lineWidth = O(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;
      const m = s.leftForLtr(f, c - h), b = s.leftForLtr(s.xPlus(f, 1), c - h - 2), _ = Pt(r.borderRadius);
      Object.values(_).some((v) => v !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ge(t, {
        x: m,
        y: p,
        w: c,
        h: l,
        radius: _
      }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), ge(t, {
        x: b,
        y: p + 1,
        w: c - 2,
        h: l - 2,
        radius: _
      }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, p, c, l), t.strokeRect(m, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(b, p + 1, c - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[n];
  }
  drawBody(t, e, n) {
    const { body: s } = this, { bodySpacing: o, bodyAlign: r, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: h } = n, d = U(n.bodyFont);
    let u = d.lineHeight, f = 0;
    const g = jt(n.rtl, this.x, this.width), p = function(M) {
      e.fillText(M, g.x(t.x + f), t.y + u / 2), t.y += u + o;
    }, m = g.textAlign(r);
    let b, _, v, y, x, k, w;
    for (e.textAlign = r, e.textBaseline = "middle", e.font = d.string, t.x = Ve(this, m, n), e.fillStyle = n.bodyColor, F(this.beforeBody, p), f = a && m !== "right" ? r === "center" ? c / 2 + h : c + 2 + h : 0, y = 0, k = s.length; y < k; ++y) {
      for (b = s[y], _ = this.labelTextColors[y], e.fillStyle = _, F(b.before, p), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, g, n), u = Math.max(d.lineHeight, l)), x = 0, w = v.length; x < w; ++x)
        p(v[x]), u = d.lineHeight;
      F(b.after, p);
    }
    f = 0, u = d.lineHeight, F(this.afterBody, p), t.y -= o;
  }
  drawFooter(t, e, n) {
    const s = this.footer, o = s.length;
    let r, a;
    if (o) {
      const l = jt(n.rtl, this.x, this.width);
      for (t.x = Ve(this, n.footerAlign, n), t.y += n.footerMarginTop, e.textAlign = l.textAlign(n.footerAlign), e.textBaseline = "middle", r = U(n.footerFont), e.fillStyle = n.footerColor, e.font = r.string, a = 0; a < o; ++a)
        e.fillText(s[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(t, e, n, s) {
    const { xAlign: o, yAlign: r } = this, { x: a, y: l } = t, { width: c, height: h } = n, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: g } = Pt(s.cornerRadius);
    e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === "top" && this.drawCaret(t, e, n, s), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === "center" && o === "right" && this.drawCaret(t, e, n, s), e.lineTo(a + c, l + h - g), e.quadraticCurveTo(a + c, l + h, a + c - g, l + h), r === "bottom" && this.drawCaret(t, e, n, s), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === "center" && o === "left" && this.drawCaret(t, e, n, s), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();
  }
  _updateAnimationTarget(t) {
    const e = this.chart, n = this.$animations, s = n && n.x, o = n && n.y;
    if (s || o) {
      const r = he[t.position].call(this, this._active, this._eventPosition);
      if (!r)
        return;
      const a = this._size = ks(this, t), l = Object.assign({}, r, this._size), c = ws(e, t, l), h = Ss(t, l, c, e);
      (s._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const e = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(e);
    const s = {
      width: this.width,
      height: this.height
    }, o = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const r = G(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    e.enabled && a && (t.save(), t.globalAlpha = n, this.drawBackground(o, t, s, e), po(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), mo(t, e.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, e) {
    const n = this._active, s = t.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), o = !$e(n, s), r = this._positionChanged(s, e);
    (o || r) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, e, n = !0) {
    if (e && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const s = this.options, o = this._active || [], r = this._getActiveElements(t, o, e, n), a = this._positionChanged(r, t), l = e || !$e(r, o) || a;
    return l && (this._active = r, (s.enabled || s.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, e))), l;
  }
  _getActiveElements(t, e, n, s) {
    const o = this.options;
    if (t.type === "mouseout")
      return [];
    if (!s)
      return e;
    const r = this.chart.getElementsAtEventForMode(t, o.mode, o, n);
    return o.reverse && r.reverse(), r;
  }
  _positionChanged(t, e) {
    const { caretX: n, caretY: s, options: o } = this, r = he[o.position].call(this, t, e);
    return r !== !1 && (n !== r.x || s !== r.y);
  }
}
Ki.positioners = he;
var Eh = {
  id: "tooltip",
  _element: Ki,
  positioners: he,
  afterInit(i, t, e) {
    e && (i.tooltip = new Ki({ chart: i, options: e }));
  },
  beforeUpdate(i, t, e) {
    i.tooltip && i.tooltip.initialize(e);
  },
  reset(i, t, e) {
    i.tooltip && i.tooltip.initialize(e);
  },
  afterDraw(i) {
    const t = i.tooltip;
    if (t && t._willRender()) {
      const e = {
        tooltip: t
      };
      if (i.notifyPlugins("beforeTooltipDraw", e) === !1)
        return;
      t.draw(i.ctx), i.notifyPlugins("afterTooltipDraw", e);
    }
  },
  afterEvent(i, t) {
    if (i.tooltip) {
      const e = t.replay;
      i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (i, t) => t.bodyFont.size,
    boxWidth: (i, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: dt,
      title(i) {
        if (i.length > 0) {
          const t = i[0], e = t.chart.data.labels, n = e ? e.length : 0;
          if (this && this.options && this.options.mode === "dataset")
            return t.dataset.label || "";
          if (t.label)
            return t.label;
          if (n > 0 && t.dataIndex < n)
            return e[t.dataIndex];
        }
        return "";
      },
      afterTitle: dt,
      beforeBody: dt,
      beforeLabel: dt,
      label(i) {
        if (this && this.options && this.options.mode === "dataset")
          return i.label + ": " + i.formattedValue || i.formattedValue;
        let t = i.dataset.label || "";
        t && (t += ": ");
        const e = i.formattedValue;
        return L(e) || (t += e), t;
      },
      labelColor(i) {
        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);
        return {
          borderColor: e.borderColor,
          backgroundColor: e.backgroundColor,
          borderWidth: e.borderWidth,
          borderDash: e.borderDash,
          borderDashOffset: e.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(i) {
        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);
        return {
          pointStyle: e.pointStyle,
          rotation: e.rotation
        };
      },
      afterLabel: dt,
      afterBody: dt,
      beforeFooter: dt,
      footer: dt,
      afterFooter: dt
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (i) => i !== "filter" && i !== "itemSort" && i !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
const Ah = (i, t, e, n) => (typeof t == "string" ? (e = i.push(t) - 1, n.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e);
function Oh(i, t, e, n) {
  const s = i.indexOf(t);
  if (s === -1)
    return Ah(i, t, e, n);
  const o = i.lastIndexOf(t);
  return s !== o ? e : s;
}
const Dh = (i, t) => i === null ? null : X(Math.round(i), 0, t);
class Ze extends Ft {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const e = this._addedLabels;
    if (e.length) {
      const n = this.getLabels();
      for (const { index: s, label: o } of e)
        n[s] === o && n.splice(s, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, e) {
    if (L(t))
      return null;
    const n = this.getLabels();
    return e = isFinite(e) && n[e] === t ? e : Oh(n, t, A(e, t), this._addedLabels), Dh(e, n.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let { min: n, max: s } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (n = 0), e || (s = this.getLabels().length - 1)), this.min = n, this.max = s;
  }
  buildTicks() {
    const t = this.min, e = this.max, n = this.options.offset, s = [];
    let o = this.getLabels();
    o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
    for (let r = t; r <= e; r++)
      s.push({ value: r });
    return s;
  }
  getLabelForValue(t) {
    const e = this.getLabels();
    return t >= 0 && t < e.length ? e[t] : t;
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
Ze.id = "category";
Ze.defaults = {
  ticks: {
    callback: Ze.prototype.getLabelForValue
  }
};
function Ph(i, t) {
  const e = [], { bounds: s, step: o, min: r, max: a, precision: l, count: c, maxTicks: h, maxDigits: d, includeBounds: u } = i, f = o || 1, g = h - 1, { min: p, max: m } = t, b = !L(r), _ = !L(a), v = !L(c), y = (m - p) / (d + 1);
  let x = wn((m - p) / g / f) * f, k, w, M, S;
  if (x < 1e-14 && !b && !_)
    return [{ value: p }, { value: m }];
  S = Math.ceil(m / x) - Math.floor(p / x), S > g && (x = wn(S * x / g / f) * f), L(l) || (k = Math.pow(10, l), x = Math.ceil(x * k) / k), s === "ticks" ? (w = Math.floor(p / x) * x, M = Math.ceil(m / x) * x) : (w = p, M = m), b && _ && o && yr((a - r) / o, x / 1e3) ? (S = Math.round(Math.min((a - r) / x, h)), x = (a - r) / S, w = r, M = a) : v ? (w = b ? r : w, M = _ ? a : M, S = c - 1, x = (M - w) / S) : (S = (M - w) / x, ae(S, Math.round(S), x / 1e3) ? S = Math.round(S) : S = Math.ceil(S));
  const I = Math.max(
    Sn(x),
    Sn(w)
  );
  k = Math.pow(10, L(l) ? I : l), w = Math.round(w * k) / k, M = Math.round(M * k) / k;
  let R = 0;
  for (b && (u && w !== r ? (e.push({ value: r }), w < r && R++, ae(Math.round((w + R * x) * k) / k, r, Es(r, y, i)) && R++) : w < r && R++); R < S; ++R)
    e.push({ value: Math.round((w + R * x) * k) / k });
  return _ && u && M !== a ? e.length && ae(e[e.length - 1].value, a, Es(a, y, i)) ? e[e.length - 1].value = a : e.push({ value: a }) : (!_ || M === a) && e.push({ value: M }), e;
}
function Es(i, t, { horizontal: e, minRotation: n }) {
  const s = st(n), o = (e ? Math.sin(s) : Math.cos(s)) || 1e-3, r = 0.75 * t * ("" + i).length;
  return Math.min(t / o, r);
}
class Je extends Ft {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    return L(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: n } = this.getUserBounds();
    let { min: s, max: o } = this;
    const r = (l) => s = e ? s : l, a = (l) => o = n ? o : l;
    if (t) {
      const l = ht(s), c = ht(o);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);
    }
    if (s === o) {
      let l = 1;
      (o >= Number.MAX_SAFE_INTEGER || s <= Number.MIN_SAFE_INTEGER) && (l = Math.abs(o * 0.05)), a(o + l), t || r(s - l);
    }
    this.min = s, this.max = o;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: e, stepSize: n } = t, s;
    return n ? (s = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), e = e || 11), e && (s = Math.min(e, s)), s;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, e = t.ticks;
    let n = this.getTickLimit();
    n = Math.max(2, n);
    const s = {
      maxTicks: n,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: e.precision,
      step: e.stepSize,
      count: e.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: e.minRotation || 0,
      includeBounds: e.includeBounds !== !1
    }, o = this._range || this, r = Ph(s, o);
    return t.bounds === "ticks" && Us(r, this, "value"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;
  }
  configure() {
    const t = this.ticks;
    let e = this.min, n = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const s = (n - e) / Math.max(t.length - 1, 1) / 2;
      e -= s, n += s;
    }
    this._startValue = e, this._endValue = n, this._valueRange = n - e;
  }
  getLabelForValue(t) {
    return xe(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class gn extends Je {
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = j(t) ? t : 0, this.max = j(e) ? e : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), e = t ? this.width : this.height, n = st(this.options.ticks.minRotation), s = (t ? Math.sin(n) : Math.cos(n)) || 1e-3, o = this._resolveTickFontOptions(0);
    return Math.ceil(e / Math.min(40, o.lineHeight / s));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
gn.id = "linear";
gn.defaults = {
  ticks: {
    callback: ri.formatters.numeric
  }
};
function As(i) {
  return i / Math.pow(10, Math.floor(it(i))) === 1;
}
function Th(i, t) {
  const e = Math.floor(it(t.max)), n = Math.ceil(t.max / Math.pow(10, e)), s = [];
  let o = et(i.min, Math.pow(10, Math.floor(it(t.min)))), r = Math.floor(it(o)), a = Math.floor(o / Math.pow(10, r)), l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
  do
    s.push({ value: o, major: As(o) }), ++a, a === 10 && (a = 1, ++r, l = r >= 0 ? 1 : l), o = Math.round(a * Math.pow(10, r) * l) / l;
  while (r < e || r === e && a < n);
  const c = et(i.max, o);
  return s.push({ value: c, major: As(o) }), s;
}
class pn extends Ft {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    const n = Je.prototype.parse.apply(this, [t, e]);
    if (n === 0) {
      this._zero = !0;
      return;
    }
    return j(n) && n > 0 ? n : null;
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = j(t) ? Math.max(0, t) : null, this.max = j(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let n = this.min, s = this.max;
    const o = (l) => n = t ? n : l, r = (l) => s = e ? s : l, a = (l, c) => Math.pow(10, Math.floor(it(l)) + c);
    n === s && (n <= 0 ? (o(1), r(10)) : (o(a(n, -1)), r(a(s, 1)))), n <= 0 && o(a(s, -1)), s <= 0 && r(a(n, 1)), this._zero && this.min !== this._suggestedMin && n === a(this.min, 0) && o(a(n, -1)), this.min = n, this.max = s;
  }
  buildTicks() {
    const t = this.options, e = {
      min: this._userMin,
      max: this._userMax
    }, n = Th(e, this);
    return t.bounds === "ticks" && Us(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;
  }
  getLabelForValue(t) {
    return t === void 0 ? "0" : xe(t, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const t = this.min;
    super.configure(), this._startValue = it(t), this._valueRange = it(this.max) - it(t);
  }
  getPixelForValue(t) {
    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (it(t) - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    const e = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + e * this._valueRange);
  }
}
pn.id = "logarithmic";
pn.defaults = {
  ticks: {
    callback: ri.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
};
function qi(i) {
  const t = i.ticks;
  if (t.display && i.display) {
    const e = G(t.backdropPadding);
    return A(t.font && t.font.size, T.font.size) + e.height;
  }
  return 0;
}
function Lh(i, t, e) {
  return e = B(e) ? e : [e], {
    w: Zr(i, t.string, e),
    h: e.length * t.lineHeight
  };
}
function Os(i, t, e, n, s) {
  return i === n || i === s ? {
    start: t - e / 2,
    end: t + e / 2
  } : i < n || i > s ? {
    start: t - e,
    end: t
  } : {
    start: t,
    end: t + e
  };
}
function Ih(i) {
  const t = {
    l: i.left + i._padding.left,
    r: i.right - i._padding.right,
    t: i.top + i._padding.top,
    b: i.bottom - i._padding.bottom
  }, e = Object.assign({}, t), n = [], s = [], o = i._pointLabels.length, r = i.options.pointLabels, a = r.centerPointLabels ? V / o : 0;
  for (let l = 0; l < o; l++) {
    const c = r.setContext(i.getPointLabelContext(l));
    s[l] = c.padding;
    const h = i.getPointPosition(l, i.drawingArea + s[l], a), d = U(c.font), u = Lh(i.ctx, d, i._pointLabels[l]);
    n[l] = u;
    const f = J(i.getIndexAngle(l) + a), g = Math.round(tn(f)), p = Os(g, h.x, u.w, 0, 180), m = Os(g, h.y, u.h, 90, 270);
    Rh(e, t, f, p, m);
  }
  i.setCenterPoint(
    t.l - e.l,
    e.r - t.r,
    t.t - e.t,
    e.b - t.b
  ), i._pointLabelItems = Fh(i, n, s);
}
function Rh(i, t, e, n, s) {
  const o = Math.abs(Math.sin(e)), r = Math.abs(Math.cos(e));
  let a = 0, l = 0;
  n.start < t.l ? (a = (t.l - n.start) / o, i.l = Math.min(i.l, t.l - a)) : n.end > t.r && (a = (n.end - t.r) / o, i.r = Math.max(i.r, t.r + a)), s.start < t.t ? (l = (t.t - s.start) / r, i.t = Math.min(i.t, t.t - l)) : s.end > t.b && (l = (s.end - t.b) / r, i.b = Math.max(i.b, t.b + l));
}
function Fh(i, t, e) {
  const n = [], s = i._pointLabels.length, o = i.options, r = qi(o) / 2, a = i.drawingArea, l = o.pointLabels.centerPointLabels ? V / s : 0;
  for (let c = 0; c < s; c++) {
    const h = i.getPointPosition(c, a + r + e[c], l), d = Math.round(tn(J(h.angle + W))), u = t[c], f = Bh(h.y, u.h, d), g = Nh(d), p = zh(h.x, u.w, g);
    n.push({
      x: h.x,
      y: f,
      textAlign: g,
      left: p,
      top: f,
      right: p + u.w,
      bottom: f + u.h
    });
  }
  return n;
}
function Nh(i) {
  return i === 0 || i === 180 ? "center" : i < 180 ? "left" : "right";
}
function zh(i, t, e) {
  return e === "right" ? i -= t : e === "center" && (i -= t / 2), i;
}
function Bh(i, t, e) {
  return e === 90 || e === 270 ? i -= t / 2 : (e > 270 || e < 90) && (i -= t), i;
}
function Vh(i, t) {
  const { ctx: e, options: { pointLabels: n } } = i;
  for (let s = t - 1; s >= 0; s--) {
    const o = n.setContext(i.getPointLabelContext(s)), r = U(o.font), { x: a, y: l, textAlign: c, left: h, top: d, right: u, bottom: f } = i._pointLabelItems[s], { backdropColor: g } = o;
    if (!L(g)) {
      const p = Pt(o.borderRadius), m = G(o.backdropPadding);
      e.fillStyle = g;
      const b = h - m.left, _ = d - m.top, v = u - h + m.width, y = f - d + m.height;
      Object.values(p).some((x) => x !== 0) ? (e.beginPath(), ge(e, {
        x: b,
        y: _,
        w: v,
        h: y,
        radius: p
      }), e.fill()) : e.fillRect(b, _, v, y);
    }
    It(
      e,
      i._pointLabels[s],
      a,
      l + r.lineHeight / 2,
      r,
      {
        color: o.color,
        textAlign: c,
        textBaseline: "middle"
      }
    );
  }
}
function Wo(i, t, e, n) {
  const { ctx: s } = i;
  if (e)
    s.arc(i.xCenter, i.yCenter, t, 0, N);
  else {
    let o = i.getPointPosition(0, t);
    s.moveTo(o.x, o.y);
    for (let r = 1; r < n; r++)
      o = i.getPointPosition(r, t), s.lineTo(o.x, o.y);
  }
}
function Wh(i, t, e, n) {
  const s = i.ctx, o = t.circular, { color: r, lineWidth: a } = t;
  !o && !n || !r || !a || e < 0 || (s.save(), s.strokeStyle = r, s.lineWidth = a, s.setLineDash(t.borderDash), s.lineDashOffset = t.borderDashOffset, s.beginPath(), Wo(i, e, o, n), s.closePath(), s.stroke(), s.restore());
}
function Hh(i, t, e) {
  return St(i, {
    label: e,
    index: t,
    type: "pointLabel"
  });
}
class Ee extends Je {
  constructor(t) {
    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const t = this._padding = G(qi(this.options) / 2), e = this.width = this.maxWidth - t.width, n = this.height = this.maxHeight - t.height;
    this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + n / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, n) / 2);
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!1);
    this.min = j(t) && !isNaN(t) ? t : 0, this.max = j(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / qi(this.options));
  }
  generateTickLabels(t) {
    Je.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, n) => {
      const s = z(this.options.pointLabels.callback, [e, n], this);
      return s || s === 0 ? s : "";
    }).filter((e, n) => this.chart.getDataVisibility(n));
  }
  fit() {
    const t = this.options;
    t.display && t.pointLabels.display ? Ih(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(t, e, n, s) {
    this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((n - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, n, s));
  }
  getIndexAngle(t) {
    const e = N / (this._pointLabels.length || 1), n = this.options.startAngle || 0;
    return J(t * e + st(n));
  }
  getDistanceFromCenterForValue(t) {
    if (L(t))
      return NaN;
    const e = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;
  }
  getValueForDistanceFromCenter(t) {
    if (L(t))
      return NaN;
    const e = t / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - e : this.min + e;
  }
  getPointLabelContext(t) {
    const e = this._pointLabels || [];
    if (t >= 0 && t < e.length) {
      const n = e[t];
      return Hh(this.getContext(), t, n);
    }
  }
  getPointPosition(t, e, n = 0) {
    const s = this.getIndexAngle(t) - W + n;
    return {
      x: Math.cos(s) * e + this.xCenter,
      y: Math.sin(s) * e + this.yCenter,
      angle: s
    };
  }
  getPointPositionForValue(t, e) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  getPointLabelPosition(t) {
    const { left: e, top: n, right: s, bottom: o } = this._pointLabelItems[t];
    return {
      left: e,
      top: n,
      right: s,
      bottom: o
    };
  }
  drawBackground() {
    const { backgroundColor: t, grid: { circular: e } } = this.options;
    if (t) {
      const n = this.ctx;
      n.save(), n.beginPath(), Wo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), n.closePath(), n.fillStyle = t, n.fill(), n.restore();
    }
  }
  drawGrid() {
    const t = this.ctx, e = this.options, { angleLines: n, grid: s } = e, o = this._pointLabels.length;
    let r, a, l;
    if (e.pointLabels.display && Vh(this, o), s.display && this.ticks.forEach((c, h) => {
      if (h !== 0) {
        a = this.getDistanceFromCenterForValue(c.value);
        const d = s.setContext(this.getContext(h - 1));
        Wh(this, d, a, o);
      }
    }), n.display) {
      for (t.save(), r = o - 1; r >= 0; r--) {
        const c = n.setContext(this.getPointLabelContext(r)), { color: h, lineWidth: d } = c;
        !d || !h || (t.lineWidth = d, t.strokeStyle = h, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(r, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());
      }
      t.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const t = this.ctx, e = this.options, n = e.ticks;
    if (!n.display)
      return;
    const s = this.getIndexAngle(0);
    let o, r;
    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && !e.reverse)
        return;
      const c = n.setContext(this.getContext(l)), h = U(c.font);
      if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        t.font = h.string, r = t.measureText(a.label).width, t.fillStyle = c.backdropColor;
        const d = G(c.backdropPadding);
        t.fillRect(
          -r / 2 - d.left,
          -o - h.size / 2 - d.top,
          r + d.width,
          h.size + d.height
        );
      }
      It(t, a.label, 0, -o, h, {
        color: c.color
      });
    }), t.restore();
  }
  drawTitle() {
  }
}
Ee.id = "radialLinear";
Ee.defaults = {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: ri.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(i) {
      return i;
    },
    padding: 5,
    centerPointLabels: !1
  }
};
Ee.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
Ee.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
const hi = {
  millisecond: { common: !0, size: 1, steps: 1e3 },
  second: { common: !0, size: 1e3, steps: 60 },
  minute: { common: !0, size: 6e4, steps: 60 },
  hour: { common: !0, size: 36e5, steps: 24 },
  day: { common: !0, size: 864e5, steps: 30 },
  week: { common: !1, size: 6048e5, steps: 4 },
  month: { common: !0, size: 2628e6, steps: 12 },
  quarter: { common: !1, size: 7884e6, steps: 4 },
  year: { common: !0, size: 3154e7 }
}, Z = Object.keys(hi);
function jh(i, t) {
  return i - t;
}
function Ds(i, t) {
  if (L(t))
    return null;
  const e = i._adapter, { parser: n, round: s, isoWeekday: o } = i._parseOpts;
  let r = t;
  return typeof n == "function" && (r = n(r)), j(r) || (r = typeof n == "string" ? e.parse(r, n) : e.parse(r)), r === null ? null : (s && (r = s === "week" && (Yt(o) || o === !0) ? e.startOf(r, "isoWeek", o) : e.startOf(r, s)), +r);
}
function Ps(i, t, e, n) {
  const s = Z.length;
  for (let o = Z.indexOf(i); o < s - 1; ++o) {
    const r = hi[Z[o]], a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;
    if (r.common && Math.ceil((e - t) / (a * r.size)) <= n)
      return Z[o];
  }
  return Z[s - 1];
}
function $h(i, t, e, n, s) {
  for (let o = Z.length - 1; o >= Z.indexOf(e); o--) {
    const r = Z[o];
    if (hi[r].common && i._adapter.diff(s, n, r) >= t - 1)
      return r;
  }
  return Z[e ? Z.indexOf(e) : 0];
}
function Yh(i) {
  for (let t = Z.indexOf(i) + 1, e = Z.length; t < e; ++t)
    if (hi[Z[t]].common)
      return Z[t];
}
function Ts(i, t, e) {
  if (!e)
    i[t] = !0;
  else if (e.length) {
    const { lo: n, hi: s } = en(e, t), o = e[n] >= t ? e[n] : e[s];
    i[o] = !0;
  }
}
function Uh(i, t, e, n) {
  const s = i._adapter, o = +s.startOf(t[0].value, n), r = t[t.length - 1].value;
  let a, l;
  for (a = o; a <= r; a = +s.add(a, 1, n))
    l = e[a], l >= 0 && (t[l].major = !0);
  return t;
}
function Ls(i, t, e) {
  const n = [], s = {}, o = t.length;
  let r, a;
  for (r = 0; r < o; ++r)
    a = t[r], s[a] = r, n.push({
      value: a,
      major: !1
    });
  return o === 0 || !e ? n : Uh(i, n, s, e);
}
class Ae extends Ft {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, e) {
    const n = t.time || (t.time = {}), s = this._adapter = new Il._date(t.adapters.date);
    s.init(e), re(n.displayFormats, s.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(t), this._normalized = e.normalized;
  }
  parse(t, e) {
    return t === void 0 ? null : Ds(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, e = this._adapter, n = t.time.unit || "day";
    let { min: s, max: o, minDefined: r, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !r && !isNaN(c.min) && (s = Math.min(s, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));
    }
    (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), s = j(s) && !isNaN(s) ? s : +e.startOf(Date.now(), n), o = j(o) && !isNaN(o) ? o : +e.endOf(Date.now(), n) + 1, this.min = Math.min(s, o - 1), this.max = Math.max(s + 1, o);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let e = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return t.length && (e = t[0], n = t[t.length - 1]), { min: e, max: n };
  }
  buildTicks() {
    const t = this.options, e = t.time, n = t.ticks, s = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
    const o = this.min, r = this.max, a = Sr(s, o, r);
    return this._unit = e.unit || (n.autoSkip ? Ps(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : $h(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : Yh(this._unit), this.initOffsets(s), t.reverse && a.reverse(), Ls(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t) {
    let e = 0, n = 0, s, o;
    this.options.offset && t.length && (s = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - s : e = (this.getDecimalForValue(t[1]) - s) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? n = o : n = (o - this.getDecimalForValue(t[t.length - 2])) / 2);
    const r = t.length < 3 ? 0.5 : 0.25;
    e = X(e, 0, r), n = X(n, 0, r), this._offsets = { start: e, end: n, factor: 1 / (e + 1 + n) };
  }
  _generate() {
    const t = this._adapter, e = this.min, n = this.max, s = this.options, o = s.time, r = o.unit || Ps(o.minUnit, e, n, this._getLabelCapacity(e)), a = A(o.stepSize, 1), l = r === "week" ? o.isoWeekday : !1, c = Yt(l) || l === !0, h = {};
    let d = e, u, f;
    if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : r), t.diff(n, e, r) > 1e5 * a)
      throw new Error(e + " and " + n + " are too far apart with stepSize of " + a + " " + r);
    const g = s.ticks.source === "data" && this.getDataTimestamps();
    for (u = d, f = 0; u < n; u = +t.add(u, a, r), f++)
      Ts(h, u, g);
    return (u === n || s.bounds === "ticks" || f === 1) && Ts(h, u, g), Object.keys(h).sort((p, m) => p - m).map((p) => +p);
  }
  getLabelForValue(t) {
    const e = this._adapter, n = this.options.time;
    return n.tooltipFormat ? e.format(t, n.tooltipFormat) : e.format(t, n.displayFormats.datetime);
  }
  _tickFormatFunction(t, e, n, s) {
    const o = this.options, r = o.time.displayFormats, a = this._unit, l = this._majorUnit, c = a && r[a], h = l && r[l], d = n[e], u = l && h && d && d.major, f = this._adapter.format(t, s || (u ? h : c)), g = o.ticks.callback;
    return g ? z(g, [f, e, n], this) : f;
  }
  generateTickLabels(t) {
    let e, n, s;
    for (e = 0, n = t.length; e < n; ++e)
      s = t[e], s.label = this._tickFormatFunction(s.value, e, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const e = this._offsets, n = this.getDecimalForValue(t);
    return this.getPixelForDecimal((e.start + n) * e.factor);
  }
  getValueForPixel(t) {
    const e = this._offsets, n = this.getDecimalForPixel(t) / e.factor - e.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(t) {
    const e = this.options.ticks, n = this.ctx.measureText(t).width, s = st(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(s), r = Math.sin(s), a = this._resolveTickFontOptions(0).size;
    return {
      w: n * o + a * r,
      h: n * r + a * o
    };
  }
  _getLabelCapacity(t) {
    const e = this.options.time, n = e.displayFormats, s = n[e.unit] || n.millisecond, o = this._tickFormatFunction(t, 0, Ls(this, [t], this._majorUnit), s), r = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], e, n;
    if (t.length)
      return t;
    const s = this.getMatchingVisibleMetas();
    if (this._normalized && s.length)
      return this._cache.data = s[0].controller.getAllParsedValues(this);
    for (e = 0, n = s.length; e < n; ++e)
      t = t.concat(s[e].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let e, n;
    if (t.length)
      return t;
    const s = this.getLabels();
    for (e = 0, n = s.length; e < n; ++e)
      t.push(Ds(this, s[e]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return qs(t.sort(jh));
  }
}
Ae.id = "time";
Ae.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: !1
    }
  }
};
function We(i, t, e) {
  let n = 0, s = i.length - 1, o, r, a, l;
  e ? (t >= i[n].pos && t <= i[s].pos && ({ lo: n, hi: s } = mt(i, "pos", t)), { pos: o, time: a } = i[n], { pos: r, time: l } = i[s]) : (t >= i[n].time && t <= i[s].time && ({ lo: n, hi: s } = mt(i, "time", t)), { time: o, pos: a } = i[n], { time: r, pos: l } = i[s]);
  const c = r - o;
  return c ? a + (l - a) * (t - o) / c : a;
}
class mn extends Ae {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);
    this._minPos = We(e, this.min), this._tableRange = We(e, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: e, max: n } = this, s = [], o = [];
    let r, a, l, c, h;
    for (r = 0, a = t.length; r < a; ++r)
      c = t[r], c >= e && c <= n && s.push(c);
    if (s.length < 2)
      return [
        { time: e, pos: 0 },
        { time: n, pos: 1 }
      ];
    for (r = 0, a = s.length; r < a; ++r)
      h = s[r + 1], l = s[r - 1], c = s[r], Math.round((h + l) / 2) !== c && o.push({ time: c, pos: r / (a - 1) });
    return o;
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const e = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return e.length && n.length ? t = this.normalize(e.concat(n)) : t = e.length ? e : n, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (We(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const e = this._offsets, n = this.getDecimalForPixel(t) / e.factor - e.end;
    return We(this._table, n * this._tableRange + this._minPos, !0);
  }
}
mn.id = "timeseries";
mn.defaults = Ae.defaults;
function Xh(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Kh = function(t) {
  return qh(t) && !Gh(t);
};
function qh(i) {
  return !!i && typeof i == "object";
}
function Gh(i) {
  var t = Object.prototype.toString.call(i);
  return t === "[object RegExp]" || t === "[object Date]" || Jh(i);
}
var Qh = typeof Symbol == "function" && Symbol.for, Zh = Qh ? Symbol.for("react.element") : 60103;
function Jh(i) {
  return i.$$typeof === Zh;
}
function td(i) {
  return Array.isArray(i) ? [] : {};
}
function be(i, t) {
  return t.clone !== !1 && t.isMergeableObject(i) ? Kt(td(i), i, t) : i;
}
function ed(i, t, e) {
  return i.concat(t).map(function(n) {
    return be(n, e);
  });
}
function id(i, t) {
  if (!t.customMerge)
    return Kt;
  var e = t.customMerge(i);
  return typeof e == "function" ? e : Kt;
}
function nd(i) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(i).filter(function(t) {
    return Object.propertyIsEnumerable.call(i, t);
  }) : [];
}
function Is(i) {
  return Object.keys(i).concat(nd(i));
}
function Ho(i, t) {
  try {
    return t in i;
  } catch {
    return !1;
  }
}
function sd(i, t) {
  return Ho(i, t) && !(Object.hasOwnProperty.call(i, t) && Object.propertyIsEnumerable.call(i, t));
}
function od(i, t, e) {
  var n = {};
  return e.isMergeableObject(i) && Is(i).forEach(function(s) {
    n[s] = be(i[s], e);
  }), Is(t).forEach(function(s) {
    sd(i, s) || (Ho(i, s) && e.isMergeableObject(t[s]) ? n[s] = id(s, e)(i[s], t[s], e) : n[s] = be(t[s], e));
  }), n;
}
function Kt(i, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || ed, e.isMergeableObject = e.isMergeableObject || Kh, e.cloneUnlessOtherwiseSpecified = be;
  var n = Array.isArray(t), s = Array.isArray(i), o = n === s;
  return o ? n ? e.arrayMerge(i, t, e) : od(i, t, e) : be(t, e);
}
Kt.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(n, s) {
    return Kt(n, s, e);
  }, {});
};
var rd = Kt, ad = rd;
const Gi = /* @__PURE__ */ Xh(ad), ld = (i) => i == null ? `${i}` : {}.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), jo = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    const e = i.getAttribute("href");
    t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, ti = (i) => {
  const t = jo(i);
  return t && document.querySelector(t) ? t : null;
}, di = (i) => {
  const t = jo(i);
  return t ? document.querySelector(t) : null;
}, $o = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), Rs = (i) => $o(i) ? i.jquery ? i[0] : i : typeof i == "string" && i.length > 0 ? document.querySelector(i) : null, cd = (i, t, e) => {
  Object.keys(e).forEach((n) => {
    const s = e[n], o = t[n], r = o && $o(o) ? "element" : ld(o);
    if (!new RegExp(s).test(r))
      throw new Error(
        `${i.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`
      );
  });
}, bn = (i) => {
  if (!i)
    return !1;
  if (i.style && i.parentNode && i.parentNode.style) {
    const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);
    return t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, Yo = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", Uo = () => {
  const { jQuery: i } = window;
  return i && !document.body.hasAttribute("data-mdb-no-jquery") ? i : null;
}, hd = (i) => {
  document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", i) : i();
};
document.documentElement.dir;
const dd = (i) => document.createElement(i), ud = (i) => {
  hd(() => {
    const t = Uo();
    if (t) {
      const e = i.NAME, n = t.fn[e];
      t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = () => (t.fn[e] = n, i.jQueryInterface);
    }
  });
}, Di = (() => {
  const i = {};
  let t = 1;
  return {
    set(e, n, s) {
      typeof e[n] > "u" && (e[n] = {
        key: n,
        id: t
      }, t++), i[e[n].id] = s;
    },
    get(e, n) {
      if (!e || typeof e[n] > "u")
        return null;
      const s = e[n];
      return s.key === n ? i[s.id] : null;
    },
    delete(e, n) {
      if (typeof e[n] > "u")
        return;
      const s = e[n];
      s.key === n && (delete i[s.id], delete e[n]);
    }
  };
})(), $t = {
  setData(i, t, e) {
    Di.set(i, t, e);
  },
  getData(i, t) {
    return Di.get(i, t);
  },
  removeData(i, t) {
    Di.delete(i, t);
  }
};
function Fs(i) {
  return i === "true" ? !0 : i === "false" ? !1 : i === Number(i).toString() ? Number(i) : i === "" || i === "null" ? null : i;
}
function Pi(i) {
  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const lt = {
  setDataAttribute(i, t, e) {
    i.setAttribute(`data-mdb-${Pi(t)}`, e);
  },
  removeDataAttribute(i, t) {
    i.removeAttribute(`data-mdb-${Pi(t)}`);
  },
  getDataAttributes(i) {
    if (!i)
      return {};
    const t = {
      ...i.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("mdb")).forEach((e) => {
      let n = e.replace(/^mdb/, "");
      n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = Fs(t[e]);
    }), t;
  },
  getDataAttribute(i, t) {
    return Fs(i.getAttribute(`data-mdb-${Pi(t)}`));
  },
  offset(i) {
    const t = i.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(i) {
    return {
      top: i.offsetTop,
      left: i.offsetLeft
    };
  },
  style(i, t) {
    Object.assign(i.style, t);
  },
  toggleClass(i, t) {
    i && (i.classList.contains(t) ? i.classList.remove(t) : i.classList.add(t));
  },
  addClass(i, t) {
    i.classList.contains(t) || i.classList.add(t);
  },
  addStyle(i, t) {
    Object.keys(t).forEach((e) => {
      i.style[e] = t[e];
    });
  },
  removeClass(i, t) {
    i.classList.contains(t) && i.classList.remove(t);
  },
  hasClass(i, t) {
    return i.classList.contains(t);
  }
}, Ti = Uo(), fd = /[^.]*(?=\..*)\.|.*/, Xo = /\..*/, gd = /::\d+$/, Li = {};
let Ns = 1;
const pd = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Ko = [
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
];
function qo(i, t) {
  return t && `${t}::${Ns++}` || i.uidEvent || Ns++;
}
function Go(i) {
  const t = qo(i);
  return i.uidEvent = t, Li[t] = Li[t] || {}, Li[t];
}
function md(i, t) {
  return function e(n) {
    return n.delegateTarget = i, e.oneOff && E.off(i, n.type, t), t.apply(i, [n]);
  };
}
function bd(i, t, e) {
  return function n(s) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = s; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return s.delegateTarget = r, n.oneOff && E.off(i, s.type, e), e.apply(r, [s]);
    return null;
  };
}
function Qo(i, t, e = null) {
  const n = Object.keys(i);
  for (let s = 0, o = n.length; s < o; s++) {
    const r = i[n[s]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function Zo(i, t, e) {
  const n = typeof t == "string", s = n ? e : t;
  let o = i.replace(Xo, "");
  const r = pd[o];
  return r && (o = r), Ko.indexOf(o) > -1 || (o = i), [n, s, o];
}
function zs(i, t, e, n, s) {
  if (typeof t != "string" || !i)
    return;
  e || (e = n, n = null);
  const [o, r, a] = Zo(
    t,
    e,
    n
  ), l = Go(i), c = l[a] || (l[a] = {}), h = Qo(c, r, o ? e : null);
  if (h) {
    h.oneOff = h.oneOff && s;
    return;
  }
  const d = qo(r, t.replace(fd, "")), u = o ? bd(i, e, n) : md(i, e);
  u.delegationSelector = o ? e : null, u.originalHandler = r, u.oneOff = s, u.uidEvent = d, c[d] = u, i.addEventListener(a, u, o);
}
function Qi(i, t, e, n, s) {
  const o = Qo(t[e], n, s);
  o && (i.removeEventListener(e, o, !!s), delete t[e][o.uidEvent]);
}
function _d(i, t, e, n) {
  const s = t[e] || {};
  Object.keys(s).forEach((o) => {
    if (o.indexOf(n) > -1) {
      const r = s[o];
      Qi(i, t, e, r.originalHandler, r.delegationSelector);
    }
  });
}
const E = {
  on(i, t, e, n) {
    zs(i, t, e, n, !1);
  },
  one(i, t, e, n) {
    zs(i, t, e, n, !0);
  },
  extend(i, t, e) {
    t.forEach((n) => {
      E.on(i, `${n.name}.bs.${e}`, (s) => {
        const o = {};
        n.parametersToCopy && n.parametersToCopy.forEach((a) => {
          o[a] = s[a];
        }), E.trigger(
          i,
          `${n.name}.mdb.${e}`,
          o
        ).defaultPrevented && s.preventDefault();
      });
    });
  },
  off(i, t, e, n) {
    if (typeof t != "string" || !i)
      return;
    const [s, o, r] = Zo(
      t,
      e,
      n
    ), a = r !== t, l = Go(i), c = t.charAt(0) === ".";
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Qi(i, l, r, o, s ? e : null);
      return;
    }
    c && Object.keys(l).forEach((d) => {
      _d(i, l, d, t.slice(1));
    });
    const h = l[r] || {};
    Object.keys(h).forEach((d) => {
      const u = d.replace(gd, "");
      if (!a || t.indexOf(u) > -1) {
        const f = h[d];
        Qi(i, l, r, f.originalHandler, f.delegationSelector);
      }
    });
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const n = t.replace(Xo, ""), s = t !== n, o = Ko.indexOf(n) > -1;
    let r, a = !0, l = !0, c = !1, h = null;
    return s && Ti && (r = Ti.Event(t, e), Ti(i).trigger(r), a = !r.isPropagationStopped(), l = !r.isImmediatePropagationStopped(), c = r.isDefaultPrevented()), o ? (h = document.createEvent("HTMLEvents"), h.initEvent(n, a, !0)) : h = new CustomEvent(t, {
      bubbles: a,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((d) => {
      Object.defineProperty(h, d, {
        get() {
          return e[d];
        }
      });
    }), c && h.preventDefault(), l && i.dispatchEvent(h), h.defaultPrevented && typeof r < "u" && r.preventDefault(), h;
  }
};
class xd {
  constructor(t) {
    t = Rs(t), t && (this._element = t, $t.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    $t.removeData(this._element, this.constructor.DATA_KEY), E.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  /** Static */
  static getInstance(t) {
    return $t.getData(Rs(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  static get DATA_KEY() {
    return `mdb.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const yd = 3, P = {
  closest(i, t) {
    return i.closest(t);
  },
  matches(i, t) {
    return i.matches(t);
  },
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((n) => n.matches(t));
  },
  parents(i, t) {
    const e = [];
    let n = i.parentNode;
    for (; n && n.nodeType === Node.ELEMENT_NODE && n.nodeType !== yd; )
      this.matches(n, t) && e.push(n), n = n.parentNode;
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  }
}, Bs = (() => {
  const i = [];
  return {
    set(t) {
      i.push(t);
    },
    get(t) {
      return i.includes(t);
    }
  };
})(), ei = {
  set(i) {
    Bs.set(i);
  },
  get(i) {
    return Bs.get(i);
  }
}, vd = (i) => ei.get(i), kd = (i) => {
  vd(i.NAME) || Jo(i, !0);
}, Jo = (i, t = !1) => {
  if (!i || ei.get(i.NAME))
    return;
  ei.set(i.NAME);
  const e = Ht[i.NAME] || null, n = (e == null ? void 0 : e.isToggler) || !1;
  if (ud(i), e != null && e.advanced) {
    e.advanced(i, e == null ? void 0 : e.selector);
    return;
  }
  if (n) {
    e.callback(i, e == null ? void 0 : e.selector);
    return;
  }
  t || P.find(e == null ? void 0 : e.selector).forEach((s) => {
    let o = i.getInstance(s);
    o || (o = new i(s), e != null && e.onInit && o[e.onInit]());
  });
};
let Ht;
class wd {
  constructor(t) {
    mi(this, "init", (t) => {
      t.forEach((e) => Jo(e));
    });
    mi(this, "initMDB", (t, e = !1) => {
      const n = Object.keys(Ht).map((s) => {
        if (!!document.querySelector(Ht[s].selector)) {
          const r = t[Ht[s].name];
          return !r && !ei.get(s) && e && console.warn(
            `Please import ${Ht[s].name} from "MDB" package and add it to a object parameter inside "initMDB" function`
          ), r;
        }
        return null;
      });
      this.init(n);
    });
    Ht = t;
  }
}
const _t = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, oe = {
  line: {
    options: {
      ..._t,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ..._t,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ..._t,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ..._t,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ..._t,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ..._t,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ..._t,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ..._t,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
};
me.register(
  ai,
  Mt,
  ci,
  li,
  ye,
  ve,
  Rt,
  ke,
  oi,
  we,
  Se,
  Me,
  Ze,
  gn,
  pn,
  Ee,
  Ae,
  mn,
  Xc,
  fh,
  mh,
  _h,
  Eh,
  xh
);
const Vs = "chart", Ii = "mdb.chart", Sd = "chart", Ri = (i, t, e) => {
  const n = (s, o, r) => {
    const a = s.slice();
    return o.forEach((l, c) => {
      typeof a[c] > "u" ? a[c] = r.cloneUnlessOtherwiseSpecified(l, r) : r.isMergeableObject(l) ? a[c] = Gi(s[c], l, r) : s.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return Gi(e[t], i, {
    arrayMerge: n
  });
}, Md = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkMode: null,
  darkBgColor: "#262626",
  darkBgColorLight: "#fff",
  options: null
}, Cd = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkMode: "(string|null)",
  darkBgColor: "string",
  darkBgColorLight: "string",
  options: "(object|null)"
};
class tr extends xd {
  constructor(t, e, n = {}, s = {}) {
    if (super(t), this._data = e, this._options = n, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(s), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (lt.addClass(this._element, Sd), this._chartConstructor(), lt.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), kd(this.constructor)), this._element && this._darkOptions.darkmodeOff !== null) {
      let o;
      switch (this._darkOptions.darkMode) {
        case "dark":
          o = "dark";
          break;
        case "light":
          o = "light";
          break;
        default:
          o = this.systemColorMode;
          break;
      }
      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
        attributes: !0
      });
    }
  }
  // Getters
  static get NAME() {
    return Vs;
  }
  get systemColorMode() {
    return localStorage.theme || lt.getDataAttribute(this._darkModeClassContainer, "theme") || "light";
  }
  static get BarController() {
    return ye;
  }
  static get BubbleController() {
    return ve;
  }
  static get DoughnutController() {
    return Rt;
  }
  static get LineController() {
    return ke;
  }
  static get PieController() {
    return oi;
  }
  static get PolarAreaController() {
    return we;
  }
  static get RadarController() {
    return Se;
  }
  static get ScatterController() {
    return Me;
  }
  // Public
  dispose() {
    this._observer.disconnect(), $t.removeData(this._element, Ii), this._chart.destroy(), lt.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);
    const n = Object.prototype.hasOwnProperty.call(e, "options") ? e : { options: { ...e } };
    this._options = Gi(this._options, n), this._chart.options = Ri(this._options, this._type, oe).options, this._chart.update();
  }
  static register(t) {
    me.register(t);
  }
  setTheme(t) {
    t !== "dark" && t !== "light" || !this._data || this._handleMode(t);
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const n = lt.getDataAttributes(this._element);
    Object.keys(n).forEach(
      (c) => c.startsWith("dark") && (e[c] = n[c])
    ), e = {
      ...Md,
      ...e
    };
    const s = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, r = ["pie", "doughnut", "polarArea", "radar"];
    let a = {};
    r.includes(this._type) ? ["polarArea", "radar"].includes(this._type) && (a = o) : a = s;
    const l = {
      scales: a,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, cd(Vs, t, Cd), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = Ri(this._options, this._type, oe);
      this._chart = new me(this._canvas, {
        ...this._data,
        ...t
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = dd("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    t.forEach((e) => {
      e.type === "attributes" && this._handleMode(this.systemColorMode);
    });
  }
  _changeDatasetBorderColor(t = !0) {
    this._data.data && [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)
    );
  }
  static jQueryInterface(t, e, n) {
    return this.each(function() {
      let s = $t.getData(this, Ii);
      if (!(!s && /dispose/.test(t))) {
        if (!s) {
          const o = e ? Ri(e, n, oe) : oe[n];
          s = new tr(this, t, o);
        }
        if (typeof t == "string") {
          if (typeof s[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          s[t](e, n);
        }
      }
    });
  }
  static getInstance(t) {
    return $t.getData(t, Ii);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ed = (i) => (i && window.CSS && window.CSS.escape && (i = i.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)), i), Ad = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), Od = (i) => {
  if (!Ad(i) || i.getClientRects().length === 0)
    return !1;
  const t = getComputedStyle(i).getPropertyValue("visibility") === "visible", e = i.closest("details:not([open])");
  if (!e)
    return t;
  if (e !== i) {
    const n = i.closest("summary");
    if (n && n.parentNode !== e || n === null)
      return !1;
  }
  return t;
}, er = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", Dd = () => window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null, Pd = /[^.]*(?=\..*)\.|.*/, Td = /\..*/, Ld = /::\d+$/, Fi = {};
let Ws = 1;
const ir = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Id = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function nr(i, t) {
  return t && `${t}::${Ws++}` || i.uidEvent || Ws++;
}
function sr(i) {
  const t = nr(i);
  return i.uidEvent = t, Fi[t] = Fi[t] || {}, Fi[t];
}
function Rd(i, t) {
  return function e(n) {
    return xn(n, { delegateTarget: i }), e.oneOff && _n.off(i, n.type, t), t.apply(i, [n]);
  };
}
function Fd(i, t, e) {
  return function n(s) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = s; r && r !== this; r = r.parentNode)
      for (const a of o)
        if (a === r)
          return xn(s, { delegateTarget: r }), n.oneOff && _n.off(i, s.type, t, e), e.apply(r, [s]);
  };
}
function or(i, t, e = null) {
  return Object.values(i).find(
    (n) => n.callable === t && n.delegationSelector === e
  );
}
function rr(i, t, e) {
  const n = typeof t == "string", s = n ? e : t || e;
  let o = ar(i);
  return Id.has(o) || (o = i), [n, s, o];
}
function Hs(i, t, e, n, s) {
  if (typeof t != "string" || !i)
    return;
  let [o, r, a] = rr(
    t,
    e,
    n
  );
  t in ir && (r = ((g) => function(p) {
    if (!p.relatedTarget || p.relatedTarget !== p.delegateTarget && !p.delegateTarget.contains(p.relatedTarget))
      return g.call(this, p);
  })(r));
  const l = sr(i), c = l[a] || (l[a] = {}), h = or(c, r, o ? e : null);
  if (h) {
    h.oneOff = h.oneOff && s;
    return;
  }
  const d = nr(r, t.replace(Pd, "")), u = o ? Fd(i, e, r) : Rd(i, r);
  u.delegationSelector = o ? e : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, i.addEventListener(a, u, o);
}
function Zi(i, t, e, n, s) {
  const o = or(t[e], n, s);
  o && (i.removeEventListener(e, o, !!s), delete t[e][o.uidEvent]);
}
function Nd(i, t, e, n) {
  const s = t[e] || {};
  for (const [o, r] of Object.entries(s))
    o.includes(n) && Zi(i, t, e, r.callable, r.delegationSelector);
}
function ar(i) {
  return i = i.replace(Td, ""), ir[i] || i;
}
const _n = {
  on(i, t, e, n) {
    Hs(i, t, e, n, !1);
  },
  one(i, t, e, n) {
    Hs(i, t, e, n, !0);
  },
  off(i, t, e, n) {
    if (typeof t != "string" || !i)
      return;
    const [s, o, r] = rr(
      t,
      e,
      n
    ), a = r !== t, l = sr(i), c = l[r] || {}, h = t.startsWith(".");
    if (typeof o < "u") {
      if (!Object.keys(c).length)
        return;
      Zi(i, l, r, o, s ? e : null);
      return;
    }
    if (h)
      for (const d of Object.keys(l))
        Nd(i, l, d, t.slice(1));
    for (const [d, u] of Object.entries(c)) {
      const f = d.replace(Ld, "");
      (!a || t.includes(f)) && Zi(i, l, r, u.callable, u.delegationSelector);
    }
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const n = Dd(), s = ar(t), o = t !== s;
    let r = null, a = !0, l = !0, c = !1;
    o && n && (r = n.Event(t, e), n(i).trigger(r), a = !r.isPropagationStopped(), l = !r.isImmediatePropagationStopped(), c = r.isDefaultPrevented());
    const h = xn(new Event(t, { bubbles: a, cancelable: !0 }), e);
    return c && h.preventDefault(), l && i.dispatchEvent(h), h.defaultPrevented && r && r.preventDefault(), h;
  }
};
function xn(i, t = {}) {
  for (const [e, n] of Object.entries(t))
    try {
      i[e] = n;
    } catch {
      Object.defineProperty(i, e, {
        configurable: !0,
        get() {
          return n;
        }
      });
    }
  return i;
}
const Ni = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    let e = i.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? Ed(e.trim()) : null;
  }
  return t;
}, je = {
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((e) => e.matches(t));
  },
  parents(i, t) {
    const e = [];
    let n = i.parentNode.closest(t);
    for (; n; )
      e.push(n), n = n.parentNode.closest(t);
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(i) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(",");
    return this.find(t, i).filter((e) => !er(e) && Od(e));
  },
  getSelectorFromElement(i) {
    const t = Ni(i);
    return t && je.findOne(t) ? t : null;
  },
  getElementFromSelector(i) {
    const t = Ni(i);
    return t ? je.findOne(t) : null;
  },
  getMultipleElementsFromSelector(i) {
    const t = Ni(i);
    return t ? je.find(t) : [];
  }
}, Nt = (i, t = "hide") => {
  const e = `click.dismiss${i.EVENT_KEY}`, n = i.NAME;
  _n.on(document, e, `[data-mdb-dismiss="${n}"]`, function(s) {
    if (["A", "AREA"].includes(this.tagName) && s.preventDefault(), er(this))
      return;
    const o = je.getElementFromSelector(this) || this.closest(`.${n}`);
    i.getOrCreateInstance(o)[t]();
  });
}, zd = (i, t) => {
  const e = i;
  Nt(e, "close"), P.find(t).forEach((n) => e.getOrCreateInstance(n));
}, Bd = (i, t) => {
  const e = i, n = `click.bs.${i.name}.data-api`;
  E.on(document, n, t, (s) => {
    s.preventDefault();
    const o = s.target.closest(t);
    e.getOrCreateInstance(o).toggle();
  }), P.find(t).forEach((s) => e.getOrCreateInstance(s));
}, Vd = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = "[data-mdb-slide], [data-mdb-slide-to]", s = "carousel", o = i, r = `load.bs.${i.name}.data-api`, a = t;
  E.on(document, e, n, function(l) {
    const c = di(this);
    if (!c || !c.classList.contains(s))
      return;
    l.preventDefault();
    const h = o.getOrCreateInstance(c), d = this.getAttribute("data-mdb-slide-to");
    if (d) {
      h.to(d), h._maybeEnableCycle();
      return;
    }
    if (lt.getDataAttribute(this, "slide") === "next") {
      h.next(), h._maybeEnableCycle();
      return;
    }
    h.prev(), h._maybeEnableCycle();
  }), E.on(window, r, () => {
    P.find(a).forEach((c) => {
      o.getOrCreateInstance(c);
    });
  });
}, Wd = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = t, s = i;
  E.on(document, e, n, function(o) {
    (o.target.tagName === "A" || o.delegateTarget && o.delegateTarget.tagName === "A") && o.preventDefault();
    const r = ti(this);
    P.find(r).forEach((l) => {
      s.getOrCreateInstance(l, { toggle: !1 }).toggle();
    });
  }), P.find(n).forEach((o) => {
    const r = ti(o);
    P.find(r).forEach((l) => {
      s.getOrCreateInstance(l, { toggle: !1 });
    });
  });
}, Hd = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = `keydown.bs.${i.name}.data-api`, s = `keyup.bs.${i.name}.data-api`, o = ".dropdown-menu", r = `[data-mdb-${i.NAME}-initialized]`, a = i;
  E.on(
    document,
    n,
    r,
    a.dataApiKeydownHandler
  ), E.on(document, n, o, a.dataApiKeydownHandler), E.on(document, e, a.clearMenus), E.on(document, s, a.clearMenus), E.on(document, e, r, function(l) {
    l.preventDefault(), a.getOrCreateInstance(this).toggle();
  }), P.find(t).forEach((l) => {
    a.getOrCreateInstance(l);
  });
}, jd = (i, t) => {
  const e = t, n = `${e} input`, s = `${e} textarea`, o = i;
  E.on(document, "focus", n, o.activate(new o())), E.on(document, "input", n, o.activate(new o())), E.on(document, "blur", n, o.deactivate(new o())), E.on(document, "focus", s, o.activate(new o())), E.on(document, "input", s, o.activate(new o())), E.on(document, "blur", s, o.deactivate(new o())), E.on(window, "shown.bs.modal", (r) => {
    P.find(n, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.update();
    }), P.find(s, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.update();
    });
  }), E.on(window, "shown.bs.dropdown", (r) => {
    const a = r.target.parentNode.querySelector(".dropdown-menu");
    a && (P.find(n, a).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.update();
    }), P.find(s, a).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.update();
    }));
  }), E.on(window, "shown.bs.tab", (r) => {
    let a;
    r.target.href ? a = r.target.href.split("#")[1] : a = lt.getDataAttribute(r.target, "target").split("#")[1];
    const l = P.findOne(`#${a}`);
    P.find(n, l).forEach((c) => {
      const h = o.getInstance(c.parentNode);
      h && h.update();
    }), P.find(s, l).forEach((c) => {
      const h = o.getInstance(c.parentNode);
      h && h.update();
    });
  }), P.find(e).map((r) => new o(r)), E.on(window, "reset", (r) => {
    P.find(n, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.forceInactive();
    }), P.find(s, r.target).forEach((a) => {
      const l = o.getInstance(a.parentNode);
      l && l.forceInactive();
    });
  }), E.on(window, "onautocomplete", (r) => {
    const a = o.getInstance(r.target.parentNode);
    !a || !r.cancelable || a.forceActive();
  });
}, $d = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = ".modal.show", s = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  E.on(document, e, t, function(a) {
    const l = di(this);
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), E.one(l, o, (d) => {
      d.defaultPrevented || E.one(l, r, () => {
        bn(this) && this.focus();
      });
    }), P.find(n).forEach((d) => {
      d.classList.contains("modal-non-invasive-show") || s.getInstance(d).hide();
    }), s.getOrCreateInstance(l).toggle(this);
  }), Nt(s), P.find(t).forEach((a) => {
    const l = ti(a), c = P.findOne(l);
    s.getOrCreateInstance(c);
  });
}, Yd = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = ".offcanvas.show", s = i, o = `hidden.bs.${i.name}`, r = `load.bs.${i.name}.data-api`, a = `resize.bs.${i.name}`;
  E.on(document, e, t, function(l) {
    const c = di(this);
    if (["A", "AREA"].includes(this.tagName) && l.preventDefault(), Yo(this))
      return;
    E.one(c, o, () => {
      bn(this) && this.focus();
    });
    const h = P.findOne(n);
    h && h !== c && s.getInstance(h).hide(), s.getOrCreateInstance(c).toggle(this);
  }), E.on(window, r, () => {
    P.find(n).forEach((l) => {
      s.getOrCreateInstance(l).show();
    });
  }), E.on(window, a, () => {
    P.find("[aria-modal][class*=show][class*=offcanvas-]").forEach((l) => {
      getComputedStyle(l).position !== "fixed" && s.getOrCreateInstance(l).hide();
    });
  }), Nt(s);
}, Ud = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, n = i;
  E.on(window, e, () => {
    P.find(t).forEach((s) => {
      n.getOrCreateInstance(s);
    });
  });
}, Xd = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, n = `click.bs.${i.name}.data-api`, s = "active", o = `.${s}[data-mdb-tab-init], .${s}[data-mdb-pill-init], .${s}[data-mdb-toggle="list"]`, r = i;
  E.on(document, n, t, function(a) {
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), !Yo(this) && r.getOrCreateInstance(this).show();
  }), E.on(window, e, () => {
    P.find(o).forEach((a) => {
      r.getOrCreateInstance(a);
    });
  });
}, Kd = (i, t) => {
  const e = i;
  Nt(e), P.find(t).forEach((n) => e.getOrCreateInstance(n));
}, js = (i, t) => {
  const e = i;
  E.one(document, "mousedown", t, e.autoInitial(new e()));
}, qd = (i, t) => {
  const e = i;
  Nt(e, "close"), P.find(t).forEach((n) => e.getOrCreateInstance(n));
}, Gd = (i, t) => {
  const e = `click.mdb.${i.name}.data-api`, n = t, s = `${n} img:not(.lightbox-disabled)`, o = i;
  P.find(n).forEach((r) => new o(r)), E.on(document, e, s, o.toggle());
}, Qd = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, n = ".modal.show", s = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  E.on(document, e, t, function(a) {
    const l = di(this);
    ["A", "AREA"].includes(this.tagName) && a.preventDefault(), E.one(l, o, (d) => {
      d.defaultPrevented || E.one(l, r, () => {
        bn(this) && this.focus();
      });
    }), P.find(n).forEach((d) => {
      d.classList.contains("modal-non-invasive-show") || s.getInstance(d).hide();
    }), s.getOrCreateInstance(l).toggle(this);
  }), Nt(s), P.find(t).forEach((a) => {
    const l = ti(a), c = P.findOne(l);
    s.getOrCreateInstance(c);
  });
}, Zd = (i, t) => {
  const e = t, n = '[data-mdb-toggle="sidenav"]', s = i;
  E.on(document, "click", n, s.toggleSidenav()), P.find(e).forEach((o) => s.getOrCreateInstance(o));
}, Jd = (i, t) => {
  const e = t, n = i;
  Nt(n), P.find(e).forEach((s) => n.getOrCreateInstance(s));
}, tu = {
  // Bootstrap Components
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: zd
  },
  button: {
    name: "Button",
    selector: "[data-mdb-button-init]",
    isToggler: !0,
    callback: Bd
  },
  carousel: {
    name: "Carousel",
    selector: "[data-mdb-carousel-init]",
    isToggler: !0,
    callback: Vd
  },
  collapse: {
    name: "Collapse",
    selector: "[data-mdb-collapse-init]",
    isToggler: !0,
    callback: Wd
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-mdb-dropdown-init]",
    isToggler: !0,
    callback: Hd
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: $d
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-mdb-offcanvas-init]",
    isToggler: !0,
    callback: Yd
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-mdb-scrollspy-init]",
    isToggler: !0,
    callback: Ud
  },
  tab: {
    name: "Tab",
    selector: "[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]",
    isToggler: !0,
    callback: Xd
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: Kd
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-mdb-tooltip-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-mdb-input-init]",
    isToggler: !0,
    callback: jd
  },
  range: {
    name: "Range",
    selector: "[data-mdb-range-init]",
    isToggler: !1
  },
  ripple: {
    name: "Ripple",
    selector: "[data-mdb-ripple-init]",
    isToggler: !0,
    callback: js
  },
  popover: {
    name: "Popover",
    selector: "[data-mdb-popover-init]",
    isToggler: !1,
    callback: js
  }
}, eu = (i, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", n = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, s = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = n(o[a]);
      }
    }), r;
  };
  P.find(t).forEach((o) => {
    if (!i.getInstance(o) && lt.getDataAttribute(o, "chart") !== "bubble" && lt.getDataAttribute(o, "chart") !== "scatter") {
      const r = lt.getDataAttributes(o), a = {
        data: {
          datasets: [s(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new i(o, {
        ...a,
        ...oe[a.type]
      });
    }
    return null;
  });
}, iu = {
  ...tu,
  chart: {
    name: "Chart",
    selector: "[data-mdb-chart-init]",
    isToggler: !1,
    advanced: eu
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-mdb-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-mdb-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datatable: {
    name: "Datatable",
    selector: "[data-mdb-datatable-init]",
    isToggler: !1
  },
  datetimepicker: {
    name: "Datetimepicker",
    selector: "[data-mdb-datetimepicker-init]",
    isToggler: !1
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-mdb-datepicker-init]",
    isToggler: !1
  },
  loading: {
    name: "Loading",
    selector: "[data-mdb-loading-init]",
    isToggler: !1
  },
  multiRangeSlider: {
    name: "MultiRangeSlider",
    selector: "[data-mdb-multi-range-slider-init]",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-mdb-select-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-mdb-timepicker-init]",
    isToggler: !1
  },
  touch: {
    name: "Touch",
    selector: "[data-mdb-touch-init]",
    isToggler: !1
  },
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: qd
  },
  animation: {
    name: "Animate",
    selector: "[data-mdb-animation-init]",
    isToggler: !1,
    onInit: "init"
  },
  clipboard: {
    name: "Clipboard",
    selector: "[data-mdb-clipboard-init]",
    isToggler: !1
  },
  infiniteScroll: {
    name: "InfiniteScroll",
    selector: "[data-mdb-infinite-scroll-init]",
    isToggler: !1
  },
  lazyLoad: {
    name: "LazyLoad",
    selector: "[data-mdb-lazy-load-init]",
    isToggler: !1
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-mdb-lightbox-init]",
    isToggler: !0,
    callback: Gd
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: Qd
  },
  navbar: {
    name: "Navbar",
    selector: "[data-mdb-navbar-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-mdb-perfect-scrollbar-init]",
    isToggler: !1
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-mdb-popconfirm-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-mdb-rating-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-mdb-sidenav-init]",
    isToggler: !0,
    callback: Zd
  },
  smoothScroll: {
    name: "SmoothScroll",
    selector: "[data-mdb-smooth-scroll-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-mdb-stepper-init]",
    isToggler: !1
  },
  sticky: {
    name: "Sticky",
    selector: "[data-mdb-sticky-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: Jd
  }
}, nu = new wd(iu), au = nu.initMDB;
export {
  tr as Chart,
  au as initMDB
};
//# sourceMappingURL=chart.es.min.js.map
