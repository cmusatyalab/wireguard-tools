/*!
* MDB5
* Version: PRO 7.0.0
*
*
* Copyright: Material Design for Bootstrap
* https://mdbootstrap.com/
*
* Read the license: https://mdbootstrap.com/general/license/
*
*
* Documentation: https://mdbootstrap.com/docs/standard/
*
* Support: https://mdbootstrap.com/support/
*
* Contact: contact@mdbootstrap.com
*
*/
var su = Object.defineProperty;
var nu = (i, t, e) => t in i ? su(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var It = (i, t, e) => (nu(i, typeof t != "symbol" ? t + "" : t, e), e);
const Zs = (() => {
  const i = {};
  let t = 1;
  return {
    set(e, s, n) {
      typeof e[s] > "u" && (e[s] = {
        key: s,
        id: t
      }, t++), i[e[s].id] = n;
    },
    get(e, s) {
      if (!e || typeof e[s] > "u")
        return null;
      const n = e[s];
      return n.key === s ? i[n.id] : null;
    },
    delete(e, s) {
      if (typeof e[s] > "u")
        return;
      const n = e[s];
      n.key === s && (delete i[n.id], delete e[s]);
    }
  };
})(), P = {
  setData(i, t, e) {
    Zs.set(i, t, e);
  },
  getData(i, t) {
    return Zs.get(i, t);
  },
  removeData(i, t) {
    Zs.delete(i, t);
  }
}, ou = 1e6, ru = (i) => i == null ? `${i}` : {}.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), Ot = (i) => {
  do
    i += Math.floor(Math.random() * ou);
  while (document.getElementById(i));
  return i;
}, Sc = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    const e = i.getAttribute("href");
    t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, $s = (i) => {
  const t = Sc(i);
  return t && document.querySelector(t) ? t : null;
}, Te = (i) => {
  const t = Sc(i);
  return t ? document.querySelector(t) : null;
}, wc = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), rr = (i) => wc(i) ? i.jquery ? i[0] : i : typeof i == "string" && i.length > 0 ? document.querySelector(i) : null, Y = (i, t, e) => {
  Object.keys(e).forEach((s) => {
    const n = e[s], o = t[s], r = o && wc(o) ? "element" : ru(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${i.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Kt = (i) => {
  if (!i)
    return !1;
  if (i.style && i.parentNode && i.parentNode.style) {
    const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);
    return t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, Oc = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", $c = () => {
  const { jQuery: i } = window;
  return i && !document.body.hasAttribute("data-mdb-no-jquery") ? i : null;
}, Dc = (i) => {
  document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", i) : i();
}, B = document.documentElement.dir === "rtl", au = (i) => Array.from(i), O = (i) => document.createElement(i), Nc = (i) => {
  Dc(() => {
    const t = $c();
    if (t) {
      const e = i.NAME, s = t.fn[e];
      t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = () => (t.fn[e] = s, i.jQueryInterface);
    }
  });
}, Js = $c(), lu = /[^.]*(?=\..*)\.|.*/, Lc = /\..*/, cu = /::\d+$/, tn = {};
let ar = 1;
const hu = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Ic = [
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
];
function kc(i, t) {
  return t && `${t}::${ar++}` || i.uidEvent || ar++;
}
function Mc(i) {
  const t = kc(i);
  return i.uidEvent = t, tn[t] = tn[t] || {}, tn[t];
}
function du(i, t) {
  return function e(s) {
    return s.delegateTarget = i, e.oneOff && h.off(i, s.type, t), t.apply(i, [s]);
  };
}
function uu(i, t, e) {
  return function s(n) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let l = o.length; l--; "")
        if (o[l] === r)
          return n.delegateTarget = r, s.oneOff && h.off(i, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function xc(i, t, e = null) {
  const s = Object.keys(i);
  for (let n = 0, o = s.length; n < o; n++) {
    const r = i[s[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function Rc(i, t, e) {
  const s = typeof t == "string", n = s ? e : t;
  let o = i.replace(Lc, "");
  const r = hu[o];
  return r && (o = r), Ic.indexOf(o) > -1 || (o = i), [s, n, o];
}
function lr(i, t, e, s, n) {
  if (typeof t != "string" || !i)
    return;
  e || (e = s, s = null);
  const [o, r, l] = Rc(
    t,
    e,
    s
  ), c = Mc(i), d = c[l] || (c[l] = {}), p = xc(d, r, o ? e : null);
  if (p) {
    p.oneOff = p.oneOff && n;
    return;
  }
  const f = kc(r, t.replace(lu, "")), m = o ? uu(i, e, s) : du(i, e);
  m.delegationSelector = o ? e : null, m.originalHandler = r, m.oneOff = n, m.uidEvent = f, d[f] = m, i.addEventListener(l, m, o);
}
function jn(i, t, e, s, n) {
  const o = xc(t[e], s, n);
  o && (i.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function pu(i, t, e, s) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.indexOf(s) > -1) {
      const r = n[o];
      jn(i, t, e, r.originalHandler, r.delegationSelector);
    }
  });
}
const h = {
  on(i, t, e, s) {
    lr(i, t, e, s, !1);
  },
  one(i, t, e, s) {
    lr(i, t, e, s, !0);
  },
  extend(i, t, e) {
    t.forEach((s) => {
      h.on(i, `${s.name}.bs.${e}`, (n) => {
        const o = {};
        s.parametersToCopy && s.parametersToCopy.forEach((l) => {
          o[l] = n[l];
        }), h.trigger(
          i,
          `${s.name}.mdb.${e}`,
          o
        ).defaultPrevented && n.preventDefault();
      });
    });
  },
  off(i, t, e, s) {
    if (typeof t != "string" || !i)
      return;
    const [n, o, r] = Rc(
      t,
      e,
      s
    ), l = r !== t, c = Mc(i), d = t.charAt(0) === ".";
    if (typeof o < "u") {
      if (!c || !c[r])
        return;
      jn(i, c, r, o, n ? e : null);
      return;
    }
    d && Object.keys(c).forEach((f) => {
      pu(i, c, f, t.slice(1));
    });
    const p = c[r] || {};
    Object.keys(p).forEach((f) => {
      const m = f.replace(cu, "");
      if (!l || t.indexOf(m) > -1) {
        const g = p[f];
        jn(i, c, r, g.originalHandler, g.delegationSelector);
      }
    });
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const s = t.replace(Lc, ""), n = t !== s, o = Ic.indexOf(s) > -1;
    let r, l = !0, c = !0, d = !1, p = null;
    return n && Js && (r = Js.Event(t, e), Js(i).trigger(r), l = !r.isPropagationStopped(), c = !r.isImmediatePropagationStopped(), d = r.isDefaultPrevented()), o ? (p = document.createEvent("HTMLEvents"), p.initEvent(s, l, !0)) : p = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(p, f, {
        get() {
          return e[f];
        }
      });
    }), d && p.preventDefault(), c && i.dispatchEvent(p), p.defaultPrevented && typeof r < "u" && r.preventDefault(), p;
  }
}, ut = {
  on(i, t, e, s) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.on(i, n[o], e, s);
  },
  off(i, t, e, s) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      h.off(i, n[o], e, s);
  }
};
function cr(i) {
  return i === "true" ? !0 : i === "false" ? !1 : i === Number(i).toString() ? Number(i) : i === "" || i === "null" ? null : i;
}
function en(i) {
  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const a = {
  setDataAttribute(i, t, e) {
    i.setAttribute(`data-mdb-${en(t)}`, e);
  },
  removeDataAttribute(i, t) {
    i.removeAttribute(`data-mdb-${en(t)}`);
  },
  getDataAttributes(i) {
    if (!i)
      return {};
    const t = {
      ...i.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("mdb")).forEach((e) => {
      let s = e.replace(/^mdb/, "");
      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = cr(t[e]);
    }), t;
  },
  getDataAttribute(i, t) {
    return cr(i.getAttribute(`data-mdb-${en(t)}`));
  },
  offset(i) {
    const t = i.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(i) {
    return {
      top: i.offsetTop,
      left: i.offsetLeft
    };
  },
  style(i, t) {
    Object.assign(i.style, t);
  },
  toggleClass(i, t) {
    i && (i.classList.contains(t) ? i.classList.remove(t) : i.classList.add(t));
  },
  addClass(i, t) {
    i.classList.contains(t) || i.classList.add(t);
  },
  addStyle(i, t) {
    Object.keys(t).forEach((e) => {
      i.style[e] = t[e];
    });
  },
  removeClass(i, t) {
    i.classList.contains(t) && i.classList.remove(t);
  },
  hasClass(i, t) {
    return i.classList.contains(t);
  }
}, _u = 3, u = {
  closest(i, t) {
    return i.closest(t);
  },
  matches(i, t) {
    return i.matches(t);
  },
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((s) => s.matches(t));
  },
  parents(i, t) {
    const e = [];
    let s = i.parentNode;
    for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== _u; )
      this.matches(s, t) && e.push(s), s = s.parentNode;
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  }
}, qt = /* @__PURE__ */ new Map(), sn = {
  set(i, t, e) {
    qt.has(i) || qt.set(i, /* @__PURE__ */ new Map());
    const s = qt.get(i);
    if (!s.has(t) && s.size !== 0) {
      console.error(
        `Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`
      );
      return;
    }
    s.set(t, e);
  },
  get(i, t) {
    return qt.has(i) && qt.get(i).get(t) || null;
  },
  remove(i, t) {
    if (!qt.has(i))
      return;
    const e = qt.get(i);
    e.delete(t), e.size === 0 && qt.delete(i);
  }
}, fu = 1e6, mu = 1e3, Un = "transitionend", Pc = (i) => (i && window.CSS && window.CSS.escape && (i = i.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)), i), gu = (i) => i == null ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), bu = (i) => {
  do
    i += Math.floor(Math.random() * fu);
  while (document.getElementById(i));
  return i;
}, vu = (i) => {
  if (!i)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(i);
  const s = Number.parseFloat(t), n = Number.parseFloat(e);
  return !s && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * mu);
}, Hc = (i) => {
  i.dispatchEvent(new Event(Un));
}, zt = (i) => !i || typeof i != "object" ? !1 : (typeof i.jquery < "u" && (i = i[0]), typeof i.nodeType < "u"), ne = (i) => zt(i) ? i.jquery ? i[0] : i : typeof i == "string" && i.length > 0 ? document.querySelector(Pc(i)) : null, Rs = (i) => {
  if (!zt(i) || i.getClientRects().length === 0)
    return !1;
  const t = getComputedStyle(i).getPropertyValue("visibility") === "visible", e = i.closest("details:not([open])");
  if (!e)
    return t;
  if (e !== i) {
    const s = i.closest("summary");
    if (s && s.parentNode !== e || s === null)
      return !1;
  }
  return t;
}, Qe = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled < "u" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", Bc = (i) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof i.getRootNode == "function") {
    const t = i.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return i instanceof ShadowRoot ? i : i.parentNode ? Bc(i.parentNode) : null;
}, Ds = () => {
}, Oi = (i) => {
  i.offsetHeight;
}, Eu = () => window.jQuery && !document.body.hasAttribute("data-mdb-no-jquery") ? window.jQuery : null, St = () => document.documentElement.dir === "rtl", _t = (i, t = [], e = i) => typeof i == "function" ? i(...t) : e, Vc = (i, t, e = !0) => {
  if (!e) {
    _t(i);
    return;
  }
  const s = 5, n = vu(t) + s;
  let o = !1;
  const r = ({ target: l }) => {
    l === t && (o = !0, t.removeEventListener(Un, r), _t(i));
  };
  t.addEventListener(Un, r), setTimeout(() => {
    o || Hc(t);
  }, n);
}, Oo = (i, t, e, s) => {
  const n = i.length;
  let o = i.indexOf(t);
  return o === -1 ? !e && s ? i[n - 1] : i[0] : (o += e ? 1 : -1, s && (o = (o + n) % n), i[Math.max(0, Math.min(o, n - 1))]);
}, Tu = /[^.]*(?=\..*)\.|.*/, Cu = /\..*/, yu = /::\d+$/, nn = {};
let hr = 1;
const Wc = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Au = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Yc(i, t) {
  return t && `${t}::${hr++}` || i.uidEvent || hr++;
}
function Fc(i) {
  const t = Yc(i);
  return i.uidEvent = t, nn[t] = nn[t] || {}, nn[t];
}
function Su(i, t) {
  return function e(s) {
    return $o(s, { delegateTarget: i }), e.oneOff && A.off(i, s.type, t), t.apply(i, [s]);
  };
}
function wu(i, t, e) {
  return function s(n) {
    const o = i.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (const l of o)
        if (l === r)
          return $o(n, { delegateTarget: r }), s.oneOff && A.off(i, n.type, t, e), e.apply(r, [n]);
  };
}
function Kc(i, t, e = null) {
  return Object.values(i).find(
    (s) => s.callable === t && s.delegationSelector === e
  );
}
function zc(i, t, e) {
  const s = typeof t == "string", n = s ? e : t || e;
  let o = Xc(i);
  return Au.has(o) || (o = i), [s, n, o];
}
function dr(i, t, e, s, n) {
  if (typeof t != "string" || !i)
    return;
  let [o, r, l] = zc(
    t,
    e,
    s
  );
  t in Wc && (r = ((_) => function(b) {
    if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
      return _.call(this, b);
  })(r));
  const c = Fc(i), d = c[l] || (c[l] = {}), p = Kc(d, r, o ? e : null);
  if (p) {
    p.oneOff = p.oneOff && n;
    return;
  }
  const f = Yc(r, t.replace(Tu, "")), m = o ? wu(i, e, r) : Su(i, r);
  m.delegationSelector = o ? e : null, m.callable = r, m.oneOff = n, m.uidEvent = f, d[f] = m, i.addEventListener(l, m, o);
}
function Gn(i, t, e, s, n) {
  const o = Kc(t[e], s, n);
  o && (i.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Ou(i, t, e, s) {
  const n = t[e] || {};
  for (const [o, r] of Object.entries(n))
    o.includes(s) && Gn(i, t, e, r.callable, r.delegationSelector);
}
function Xc(i) {
  return i = i.replace(Cu, ""), Wc[i] || i;
}
const A = {
  on(i, t, e, s) {
    dr(i, t, e, s, !1);
  },
  one(i, t, e, s) {
    dr(i, t, e, s, !0);
  },
  off(i, t, e, s) {
    if (typeof t != "string" || !i)
      return;
    const [n, o, r] = zc(
      t,
      e,
      s
    ), l = r !== t, c = Fc(i), d = c[r] || {}, p = t.startsWith(".");
    if (typeof o < "u") {
      if (!Object.keys(d).length)
        return;
      Gn(i, c, r, o, n ? e : null);
      return;
    }
    if (p)
      for (const f of Object.keys(c))
        Ou(i, c, f, t.slice(1));
    for (const [f, m] of Object.entries(d)) {
      const g = f.replace(yu, "");
      (!l || t.includes(g)) && Gn(i, c, r, m.callable, m.delegationSelector);
    }
  },
  trigger(i, t, e) {
    if (typeof t != "string" || !i)
      return null;
    const s = Eu(), n = Xc(t), o = t !== n;
    let r = null, l = !0, c = !0, d = !1;
    o && s && (r = s.Event(t, e), s(i).trigger(r), l = !r.isPropagationStopped(), c = !r.isImmediatePropagationStopped(), d = r.isDefaultPrevented());
    const p = $o(new Event(t, { bubbles: l, cancelable: !0 }), e);
    return d && p.preventDefault(), c && i.dispatchEvent(p), p.defaultPrevented && r && r.preventDefault(), p;
  }
};
function $o(i, t = {}) {
  for (const [e, s] of Object.entries(t))
    try {
      i[e] = s;
    } catch {
      Object.defineProperty(i, e, {
        configurable: !0,
        get() {
          return s;
        }
      });
    }
  return i;
}
function ur(i) {
  if (i === "true")
    return !0;
  if (i === "false")
    return !1;
  if (i === Number(i).toString())
    return Number(i);
  if (i === "" || i === "null")
    return null;
  if (typeof i != "string")
    return i;
  try {
    return JSON.parse(decodeURIComponent(i));
  } catch {
    return i;
  }
}
function on(i) {
  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const ie = {
  setDataAttribute(i, t, e) {
    i.setAttribute(`data-mdb-${on(t)}`, e);
  },
  removeDataAttribute(i, t) {
    i.removeAttribute(`data-mdb-${on(t)}`);
  },
  getDataAttributes(i) {
    if (!i)
      return {};
    const t = {}, e = Object.keys(i.dataset).filter(
      (s) => s.startsWith("mdb") && !s.startsWith("mdbConfig")
    );
    for (const s of e) {
      let n = s.replace(/^mdb/, "");
      n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = ur(i.dataset[s]);
    }
    return t;
  },
  getDataAttribute(i, t) {
    return ur(i.getAttribute(`data-mdb-${on(t)}`));
  }
};
class $i {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(t) {
    return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  _configAfterMerge(t) {
    return t;
  }
  _mergeConfigObj(t, e) {
    const s = zt(e) ? ie.getDataAttribute(e, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof s == "object" ? s : {},
      ...zt(e) ? ie.getDataAttributes(e) : {},
      ...typeof t == "object" ? t : {}
    };
  }
  _typeCheckConfig(t, e = this.constructor.DefaultType) {
    for (const [s, n] of Object.entries(e)) {
      const o = t[s], r = zt(o) ? "element" : gu(o);
      if (!new RegExp(n).test(r))
        throw new TypeError(
          `${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${n}".`
        );
    }
  }
}
const $u = "5.3.2";
let Nt = class extends $i {
  constructor(t, e) {
    super(), t = ne(t), t && (this._element = t, this._config = this._getConfig(e), sn.set(this._element, this.constructor.DATA_KEY, this));
  }
  // Public
  dispose() {
    sn.remove(this._element, this.constructor.DATA_KEY), A.off(this._element, this.constructor.EVENT_KEY);
    for (const t of Object.getOwnPropertyNames(this))
      this[t] = null;
  }
  _queueCallback(t, e, s = !0) {
    Vc(t, e, s);
  }
  _getConfig(t) {
    return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  // Static
  static getInstance(t) {
    return sn.get(ne(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return $u;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(t) {
    return `${t}${this.EVENT_KEY}`;
  }
};
const Du = "button", Nu = "active";
let Lu = class jc extends Nt {
  // Getters
  static get NAME() {
    return Du;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(Nu));
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = jc.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
};
const pr = (() => {
  const i = [];
  return {
    set(t) {
      i.push(t);
    },
    get(t) {
      return i.includes(t);
    }
  };
})(), Ns = {
  set(i) {
    pr.set(i);
  },
  get(i) {
    return pr.get(i);
  }
}, Iu = (i) => Ns.get(i), R = (i) => {
  Iu(i.NAME) || Uc(i, !0);
}, Uc = (i, t = !1) => {
  if (!i || Ns.get(i.NAME))
    return;
  Ns.set(i.NAME);
  const e = Pe[i.NAME] || null, s = (e == null ? void 0 : e.isToggler) || !1;
  if (Nc(i), e != null && e.advanced) {
    e.advanced(i, e == null ? void 0 : e.selector);
    return;
  }
  if (s) {
    e.callback(i, e == null ? void 0 : e.selector);
    return;
  }
  t || u.find(e == null ? void 0 : e.selector).forEach((n) => {
    let o = i.getInstance(n);
    o || (o = new i(n), e != null && e.onInit && o[e.onInit]());
  });
};
let Pe;
class ku {
  constructor(t) {
    It(this, "init", (t) => {
      t.forEach((e) => Uc(e));
    });
    It(this, "initMDB", (t, e = !1) => {
      const s = Object.keys(Pe).map((n) => {
        if (!!document.querySelector(Pe[n].selector)) {
          const r = t[Pe[n].name];
          return !r && !Ns.get(n) && e && console.warn(
            `Please import ${Pe[n].name} from "MDB" package and add it to a object parameter inside "initMDB" function`
          ), r;
        }
        return null;
      });
      this.init(s);
    });
    Pe = t;
  }
}
const Gc = "button", qn = `mdb.${Gc}`, Di = `.${qn}`, _r = `click${Di}`, De = "transitionend", fr = "mouseenter", mr = "mouseleave", Mu = `hide${Di}`, xu = `hidden${Di}`, Ru = `show${Di}`, Pu = `shown${Di}`, gr = "active", Hu = "shown", Vi = "fixed-action-btn", Bu = ".fixed-action-btn:not(.smooth-scroll) > .btn-floating", Vu = "ul .btn", Wu = "ul";
class qc extends Lu {
  constructor(t) {
    super(t), this._fn = {}, this._element && (P.setData(this._element, qn, this), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Static
  static get NAME() {
    return Gc;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, qn);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new qc(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
  // Getters
  get _actionButton() {
    return u.findOne(Bu, this._element);
  }
  get _buttonListElements() {
    return u.find(Vu, this._element);
  }
  get _buttonList() {
    return u.findOne(Wu, this._element);
  }
  get _isTouchDevice() {
    return "ontouchstart" in document.documentElement;
  }
  // Public
  show() {
    a.hasClass(this._element, Vi) && (h.off(this._buttonList, De), h.trigger(this._element, Ru), this._bindListOpenTransitionEnd(), a.addStyle(this._element, { height: `${this._fullContainerHeight}px` }), this._toggleVisibility(!0));
  }
  hide() {
    a.hasClass(this._element, Vi) && (h.off(this._buttonList, De), h.trigger(this._element, Mu), this._bindListHideTransitionEnd(), this._toggleVisibility(!1));
  }
  dispose() {
    a.hasClass(this._element, Vi) && (h.off(this._actionButton, _r), this._actionButton.removeEventListener(fr, this._fn.mouseenter), this._element.removeEventListener(mr, this._fn.mouseleave)), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    a.hasClass(this._element, Vi) && (this._saveInitialHeights(), this._setInitialStyles(), this._bindInitialEvents());
  }
  _bindMouseEnter() {
    this._actionButton.addEventListener(
      fr,
      // prettier-ignore
      this._fn.mouseenter = () => {
        this._isTouchDevice || this.show();
      }
      // prettier-ignore
    );
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      mr,
      // prettier-ignore
      this._fn.mouseleave = () => {
        this.hide();
      }
      // prettier-ignore
    );
  }
  _bindClick() {
    h.on(this._actionButton, _r, () => {
      a.hasClass(this._element, gr) ? this.hide() : this.show();
    });
  }
  _bindListHideTransitionEnd() {
    h.on(this._buttonList, De, (t) => {
      t.propertyName === "transform" && (h.off(this._buttonList, De), this._element.style.height = `${this._initialContainerHeight}px`, h.trigger(this._element, xu));
    });
  }
  _bindListOpenTransitionEnd() {
    h.on(this._buttonList, De, (t) => {
      t.propertyName === "transform" && (h.off(this._buttonList, De), h.trigger(this._element, Pu));
    });
  }
  _toggleVisibility(t) {
    const e = t ? "addClass" : "removeClass", s = t ? "translate(0)" : `translateY(${this._fullContainerHeight}px)`;
    a.addStyle(this._buttonList, { transform: s }), this._buttonListElements && this._buttonListElements.forEach((n) => a[e](n, Hu)), a[e](this._element, gr);
  }
  _getHeight(t) {
    const e = window.getComputedStyle(t);
    return parseFloat(e.getPropertyValue("height"));
  }
  _saveInitialHeights() {
    this._initialContainerHeight = this._getHeight(this._element), this._initialListHeight = this._getHeight(this._buttonList), this._fullContainerHeight = this._initialContainerHeight + this._initialListHeight;
  }
  _bindInitialEvents() {
    this._bindClick(), this._bindMouseEnter(), this._bindMouseLeave();
  }
  _setInitialStyles() {
    this._buttonList.style.marginBottom = `${this._initialContainerHeight}px`, this._buttonList.style.transform = `translateY(${this._fullContainerHeight}px)`, this._element.style.height = `${this._initialContainerHeight}px`;
  }
}
const rn = (i) => {
  let t = i.getAttribute("data-mdb-target");
  if (!t || t === "#") {
    let e = i.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? Pc(e.trim()) : null;
  }
  return t;
}, M = {
  find(i, t = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(t, i));
  },
  findOne(i, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, i);
  },
  children(i, t) {
    return [].concat(...i.children).filter((e) => e.matches(t));
  },
  parents(i, t) {
    const e = [];
    let s = i.parentNode.closest(t);
    for (; s; )
      e.push(s), s = s.parentNode.closest(t);
    return e;
  },
  prev(i, t) {
    let e = i.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(i, t) {
    let e = i.nextElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(i) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(",");
    return this.find(t, i).filter((e) => !Qe(e) && Rs(e));
  },
  getSelectorFromElement(i) {
    const t = rn(i);
    return t && M.findOne(t) ? t : null;
  },
  getElementFromSelector(i) {
    const t = rn(i);
    return t ? M.findOne(t) : null;
  },
  getMultipleElementsFromSelector(i) {
    const t = rn(i);
    return t ? M.find(t) : [];
  }
}, Qc = "backdrop", Yu = "fade", br = "show", vr = `mousedown.bs.${Qc}`, Fu = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: !1,
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
}, Ku = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
class Zc extends $i {
  constructor(t) {
    super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  // Getters
  static get Default() {
    return Fu;
  }
  static get DefaultType() {
    return Ku;
  }
  static get NAME() {
    return Qc;
  }
  // Public
  show(t) {
    if (!this._config.isVisible) {
      _t(t);
      return;
    }
    this._append();
    const e = this._getElement();
    this._config.isAnimated && Oi(e), e.classList.add(br), this._emulateAnimation(() => {
      _t(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      _t(t);
      return;
    }
    this._getElement().classList.remove(br), this._emulateAnimation(() => {
      this.dispose(), _t(t);
    });
  }
  dispose() {
    this._isAppended && (A.off(this._element, vr), this._element.remove(), this._isAppended = !1);
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add(Yu), this._element = t;
    }
    return this._element;
  }
  _configAfterMerge(t) {
    return t.rootElement = ne(t.rootElement), t;
  }
  _append() {
    if (this._isAppended)
      return;
    const t = this._getElement();
    this._config.rootElement.append(t), A.on(t, vr, () => {
      _t(this._config.clickCallback);
    }), this._isAppended = !0;
  }
  _emulateAnimation(t) {
    Vc(t, this._getElement(), this._config.isAnimated);
  }
}
const we = (i, t = "hide") => {
  const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME;
  A.on(document, e, `[data-mdb-dismiss="${s}"]`, function(n) {
    if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Qe(this))
      return;
    const o = M.getElementFromSelector(this) || this.closest(`.${s}`);
    i.getOrCreateInstance(o)[t]();
  });
}, zu = "focustrap", Xu = "bs.focustrap", Ls = `.${Xu}`, ju = `focusin${Ls}`, Uu = `keydown.tab${Ls}`, Gu = "Tab", qu = "forward", Er = "backward", Qu = {
  autofocus: !0,
  trapElement: null
  // The element to trap focus inside of
}, Zu = {
  autofocus: "boolean",
  trapElement: "element"
};
let Jc = class extends $i {
  constructor(t) {
    super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return Qu;
  }
  static get DefaultType() {
    return Zu;
  }
  static get NAME() {
    return zu;
  }
  // Public
  activate() {
    this._isActive || (this._config.autofocus && this._config.trapElement.focus(), A.off(document, Ls), A.on(document, ju, (t) => this._handleFocusin(t)), A.on(document, Uu, (t) => this._handleKeydown(t)), this._isActive = !0);
  }
  deactivate() {
    this._isActive && (this._isActive = !1, A.off(document, Ls));
  }
  // Private
  _handleFocusin(t) {
    const { trapElement: e } = this._config;
    if (t.target === document || t.target === e || e.contains(t.target))
      return;
    const s = M.focusableChildren(e);
    s.length === 0 ? e.focus() : this._lastTabNavDirection === Er ? s[s.length - 1].focus() : s[0].focus();
  }
  _handleKeydown(t) {
    t.key === Gu && (this._lastTabNavDirection = t.shiftKey ? Er : qu);
  }
};
const Tr = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Cr = ".sticky-top", Wi = "padding-right", yr = "margin-right";
class Ze {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      Wi,
      (e) => e + t
    ), this._setElementAttributes(
      Tr,
      Wi,
      (e) => e + t
    ), this._setElementAttributes(
      Cr,
      yr,
      (e) => e - t
    );
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Wi), this._resetElementAttributes(Tr, Wi), this._resetElementAttributes(Cr, yr);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, s) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const l = window.getComputedStyle(r).getPropertyValue(e);
      r.style.setProperty(e, `${s(Number.parseFloat(l))}px`);
    };
    this._applyManipulationCallback(t, o);
  }
  _saveInitialAttribute(t, e) {
    const s = t.style.getPropertyValue(e);
    s && ie.setDataAttribute(t, e, s);
  }
  _resetElementAttributes(t, e) {
    const s = (n) => {
      const o = ie.getDataAttribute(n, e);
      if (o === null) {
        n.style.removeProperty(e);
        return;
      }
      ie.removeDataAttribute(n, e), n.style.setProperty(e, o);
    };
    this._applyManipulationCallback(t, s);
  }
  _applyManipulationCallback(t, e) {
    if (zt(t)) {
      e(t);
      return;
    }
    for (const s of M.find(t, this._element))
      e(s);
  }
}
const Ju = "offcanvas", tp = "bs.offcanvas", ni = `.${tp}`, ep = "Escape", Ar = "show", Sr = "showing", wr = "hiding", ip = "offcanvas-backdrop", sp = `show${ni}`, np = `shown${ni}`, op = `hide${ni}`, Or = `hidePrevented${ni}`, rp = `hidden${ni}`, ap = `keydown.dismiss${ni}`, lp = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, cp = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
class th extends Nt {
  constructor(t, e) {
    super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
  }
  // Getters
  static get Default() {
    return lp;
  }
  static get DefaultType() {
    return cp;
  }
  static get NAME() {
    return Ju;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || A.trigger(this._element, sp, { relatedTarget: t }).defaultPrevented)
      return;
    this._isShown = !0, this._backdrop.show(), this._config.scroll || new Ze().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Sr);
    const s = () => {
      (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(Ar), this._element.classList.remove(Sr), A.trigger(this._element, np, { relatedTarget: t });
    };
    this._queueCallback(s, this._element, !0);
  }
  hide() {
    if (!this._isShown || A.trigger(this._element, op).defaultPrevented)
      return;
    this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(wr), this._backdrop.hide();
    const e = () => {
      this._element.classList.remove(Ar, wr), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new Ze().reset(), A.trigger(this._element, rp);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const t = () => {
      if (this._config.backdrop === "static") {
        A.trigger(this._element, Or);
        return;
      }
      this.hide();
    }, e = !!this._config.backdrop;
    return new Zc({
      className: ip,
      isVisible: e,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: e ? t : null
    });
  }
  _initializeFocusTrap() {
    return new Jc({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    A.on(this._element, ap, (t) => {
      if (t.key === ep) {
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        A.trigger(this._element, Or);
      }
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = th.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const hp = "swipe", oi = ".bs.swipe", dp = `touchstart${oi}`, up = `touchmove${oi}`, pp = `touchend${oi}`, _p = `pointerdown${oi}`, fp = `pointerup${oi}`, mp = "touch", gp = "pen", bp = "pointer-event", vp = 40, Ep = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
}, Tp = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
let $r = class eh extends $i {
  constructor(t, e) {
    super(), this._element = t, !(!t || !eh.isSupported()) && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents());
  }
  // Getters
  static get Default() {
    return Ep;
  }
  static get DefaultType() {
    return Tp;
  }
  static get NAME() {
    return hp;
  }
  // Public
  dispose() {
    A.off(this._element, oi);
  }
  // Private
  _start(t) {
    if (!this._supportPointerEvents) {
      this._deltaX = t.touches[0].clientX;
      return;
    }
    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX);
  }
  _end(t) {
    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), _t(this._config.endCallback);
  }
  _move(t) {
    this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const t = Math.abs(this._deltaX);
    if (t <= vp)
      return;
    const e = t / this._deltaX;
    this._deltaX = 0, e && _t(e > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    this._supportPointerEvents ? (A.on(this._element, _p, (t) => this._start(t)), A.on(this._element, fp, (t) => this._end(t)), this._element.classList.add(bp)) : (A.on(this._element, dp, (t) => this._start(t)), A.on(this._element, up, (t) => this._move(t)), A.on(this._element, pp, (t) => this._end(t)));
  }
  _eventIsPointerPenTouch(t) {
    return this._supportPointerEvents && (t.pointerType === gp || t.pointerType === mp);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
};
const Cp = "carousel", yp = "bs.carousel", ri = `.${yp}`, Ap = "ArrowLeft", Sp = "ArrowRight", wp = 500, ui = "next", Ne = "prev", He = "left", ms = "right", Op = `slide${ri}`, an = `slid${ri}`, $p = `keydown${ri}`, Dp = `mouseenter${ri}`, Np = `mouseleave${ri}`, Lp = `dragstart${ri}`, Ip = "carousel", Yi = "active", kp = "slide", Mp = "carousel-item-end", xp = "carousel-item-start", Rp = "carousel-item-next", Pp = "carousel-item-prev", ih = ".active", sh = ".carousel-item", Hp = ih + sh, Bp = ".carousel-item img", Vp = ".carousel-indicators", Wp = {
  [Ap]: ms,
  [Sp]: He
}, Yp = {
  interval: 5e3,
  keyboard: !0,
  pause: "hover",
  ride: !1,
  touch: !0,
  wrap: !0
}, Fp = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
let Kp = class nh extends Nt {
  constructor(t, e) {
    super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = M.findOne(Vp, this._element), this._addEventListeners(), this._config.ride === Ip && this.cycle();
  }
  // Getters
  static get Default() {
    return Yp;
  }
  static get DefaultType() {
    return Fp;
  }
  static get NAME() {
    return Cp;
  }
  // Public
  next() {
    this._slide(ui);
  }
  nextWhenVisible() {
    !document.hidden && Rs(this._element) && this.next();
  }
  prev() {
    this._slide(Ne);
  }
  pause() {
    this._isSliding && Hc(this._element), this._clearInterval();
  }
  cycle() {
    this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        A.one(this._element, an, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  to(t) {
    const e = this._getItems();
    if (t > e.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      A.one(this._element, an, () => this.to(t));
      return;
    }
    const s = this._getItemIndex(this._getActive());
    if (s === t)
      return;
    const n = t > s ? ui : Ne;
    this._slide(n, e[t]);
  }
  dispose() {
    this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
  }
  // Private
  _configAfterMerge(t) {
    return t.defaultInterval = t.interval, t;
  }
  _addEventListeners() {
    this._config.keyboard && A.on(this._element, $p, (t) => this._keydown(t)), this._config.pause === "hover" && (A.on(this._element, Dp, () => this.pause()), A.on(this._element, Np, () => this._maybeEnableCycle())), this._config.touch && $r.isSupported() && this._addTouchEventListeners();
  }
  _addTouchEventListeners() {
    for (const s of M.find(Bp, this._element))
      A.on(s, Lp, (n) => n.preventDefault());
    const e = {
      leftCallback: () => this._slide(this._directionToOrder(He)),
      rightCallback: () => this._slide(this._directionToOrder(ms)),
      endCallback: () => {
        this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
          () => this._maybeEnableCycle(),
          wp + this._config.interval
        ));
      }
    };
    this._swipeHelper = new $r(this._element, e);
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = Wp[t.key];
    e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
  }
  _getItemIndex(t) {
    return this._getItems().indexOf(t);
  }
  _setActiveIndicatorElement(t) {
    if (!this._indicatorsElement)
      return;
    const e = M.findOne(ih, this._indicatorsElement);
    e.classList.remove(Yi), e.removeAttribute("aria-current");
    const s = M.findOne(
      `[data-mdb-slide-to="${t}"]`,
      this._indicatorsElement
    );
    s && (s.classList.add(Yi), s.setAttribute("aria-current", "true"));
  }
  _updateInterval() {
    const t = this._activeElement || this._getActive();
    if (!t)
      return;
    const e = Number.parseInt(t.getAttribute("data-mdb-interval"), 10);
    this._config.interval = e || this._config.defaultInterval;
  }
  _slide(t, e = null) {
    if (this._isSliding)
      return;
    const s = this._getActive(), n = t === ui, o = e || Oo(this._getItems(), s, n, this._config.wrap);
    if (o === s)
      return;
    const r = this._getItemIndex(o), l = (g) => A.trigger(this._element, g, {
      relatedTarget: o,
      direction: this._orderToDirection(t),
      from: this._getItemIndex(s),
      to: r
    });
    if (l(Op).defaultPrevented || !s || !o)
      return;
    const d = !!this._interval;
    this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = o;
    const p = n ? xp : Mp, f = n ? Rp : Pp;
    o.classList.add(f), Oi(o), s.classList.add(p), o.classList.add(p);
    const m = () => {
      o.classList.remove(p, f), o.classList.add(Yi), s.classList.remove(Yi, f, p), this._isSliding = !1, l(an);
    };
    this._queueCallback(m, s, this._isAnimated()), d && this.cycle();
  }
  _isAnimated() {
    return this._element.classList.contains(kp);
  }
  _getActive() {
    return M.findOne(Hp, this._element);
  }
  _getItems() {
    return M.find(sh, this._element);
  }
  _clearInterval() {
    this._interval && (clearInterval(this._interval), this._interval = null);
  }
  _directionToOrder(t) {
    return St() ? t === He ? Ne : ui : t === He ? ui : Ne;
  }
  _orderToDirection(t) {
    return St() ? t === Ne ? He : ms : t === Ne ? ms : He;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = nh.getOrCreateInstance(this, t);
      if (typeof t == "number") {
        e.to(t);
        return;
      }
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const Dr = "carousel", zp = "slide.bs.carousel", Xp = "slid.bs.carousel", jp = [
  { name: "slide", parametersToCopy: ["relatedTarget", "direction", "from", "to"] },
  { name: "slid", parametersToCopy: ["relatedTarget", "direction", "from", "to"] }
];
class HS extends Kp {
  constructor(t, e) {
    super(t, e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, zp), h.off(this._element, Xp), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Dr;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    h.extend(this._element, jp, Dr);
  }
}
var rt = "top", bt = "bottom", vt = "right", at = "left", Ps = "auto", ai = [rt, bt, vt, at], Ce = "start", Je = "end", oh = "clippingParents", Do = "viewport", Be = "popper", rh = "reference", Qn = /* @__PURE__ */ ai.reduce(function(i, t) {
  return i.concat([t + "-" + Ce, t + "-" + Je]);
}, []), No = /* @__PURE__ */ [].concat(ai, [Ps]).reduce(function(i, t) {
  return i.concat([t, t + "-" + Ce, t + "-" + Je]);
}, []), ah = "beforeRead", lh = "read", ch = "afterRead", hh = "beforeMain", dh = "main", uh = "afterMain", ph = "beforeWrite", _h = "write", fh = "afterWrite", mh = [ah, lh, ch, hh, dh, uh, ph, _h, fh];
function Bt(i) {
  return i ? (i.nodeName || "").toLowerCase() : null;
}
function Et(i) {
  if (i == null)
    return window;
  if (i.toString() !== "[object Window]") {
    var t = i.ownerDocument;
    return t && t.defaultView || window;
  }
  return i;
}
function ye(i) {
  var t = Et(i).Element;
  return i instanceof t || i instanceof Element;
}
function At(i) {
  var t = Et(i).HTMLElement;
  return i instanceof t || i instanceof HTMLElement;
}
function Lo(i) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Et(i).ShadowRoot;
  return i instanceof t || i instanceof ShadowRoot;
}
function Up(i) {
  var t = i.state;
  Object.keys(t.elements).forEach(function(e) {
    var s = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !At(o) || !Bt(o) || (Object.assign(o.style, s), Object.keys(n).forEach(function(r) {
      var l = n[r];
      l === !1 ? o.removeAttribute(r) : o.setAttribute(r, l === !0 ? "" : l);
    }));
  });
}
function Gp(i) {
  var t = i.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(s) {
      var n = t.elements[s], o = t.attributes[s] || {}, r = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), l = r.reduce(function(c, d) {
        return c[d] = "", c;
      }, {});
      !At(n) || !Bt(n) || (Object.assign(n.style, l), Object.keys(o).forEach(function(c) {
        n.removeAttribute(c);
      }));
    });
  };
}
const Io = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Up,
  effect: Gp,
  requires: ["computeStyles"]
};
function Ht(i) {
  return i.split("-")[0];
}
var be = Math.max, Is = Math.min, ti = Math.round;
function Zn() {
  var i = navigator.userAgentData;
  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function gh() {
  return !/^((?!chrome|android).)*safari/i.test(Zn());
}
function ei(i, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var s = i.getBoundingClientRect(), n = 1, o = 1;
  t && At(i) && (n = i.offsetWidth > 0 && ti(s.width) / i.offsetWidth || 1, o = i.offsetHeight > 0 && ti(s.height) / i.offsetHeight || 1);
  var r = ye(i) ? Et(i) : window, l = r.visualViewport, c = !gh() && e, d = (s.left + (c && l ? l.offsetLeft : 0)) / n, p = (s.top + (c && l ? l.offsetTop : 0)) / o, f = s.width / n, m = s.height / o;
  return {
    width: f,
    height: m,
    top: p,
    right: d + f,
    bottom: p + m,
    left: d,
    x: d,
    y: p
  };
}
function ko(i) {
  var t = ei(i), e = i.offsetWidth, s = i.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {
    x: i.offsetLeft,
    y: i.offsetTop,
    width: e,
    height: s
  };
}
function bh(i, t) {
  var e = t.getRootNode && t.getRootNode();
  if (i.contains(t))
    return !0;
  if (e && Lo(e)) {
    var s = t;
    do {
      if (s && i.isSameNode(s))
        return !0;
      s = s.parentNode || s.host;
    } while (s);
  }
  return !1;
}
function jt(i) {
  return Et(i).getComputedStyle(i);
}
function qp(i) {
  return ["table", "td", "th"].indexOf(Bt(i)) >= 0;
}
function re(i) {
  return ((ye(i) ? i.ownerDocument : (
    // $FlowFixMe[prop-missing]
    i.document
  )) || window.document).documentElement;
}
function Hs(i) {
  return Bt(i) === "html" ? i : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    i.parentNode || // DOM Element detected
    (Lo(i) ? i.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    re(i)
  );
}
function Nr(i) {
  return !At(i) || // https://github.com/popperjs/popper-core/issues/837
  jt(i).position === "fixed" ? null : i.offsetParent;
}
function Qp(i) {
  var t = /firefox/i.test(Zn()), e = /Trident/i.test(Zn());
  if (e && At(i)) {
    var s = jt(i);
    if (s.position === "fixed")
      return null;
  }
  var n = Hs(i);
  for (Lo(n) && (n = n.host); At(n) && ["html", "body"].indexOf(Bt(n)) < 0; ) {
    var o = jt(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Ni(i) {
  for (var t = Et(i), e = Nr(i); e && qp(e) && jt(e).position === "static"; )
    e = Nr(e);
  return e && (Bt(e) === "html" || Bt(e) === "body" && jt(e).position === "static") ? t : e || Qp(i) || t;
}
function Mo(i) {
  return ["top", "bottom"].indexOf(i) >= 0 ? "x" : "y";
}
function Ti(i, t, e) {
  return be(i, Is(t, e));
}
function Zp(i, t, e) {
  var s = Ti(i, t, e);
  return s > e ? e : s;
}
function vh() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Eh(i) {
  return Object.assign({}, vh(), i);
}
function Th(i, t) {
  return t.reduce(function(e, s) {
    return e[s] = i, e;
  }, {});
}
var Jp = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, Eh(typeof t != "number" ? t : Th(t, ai));
};
function t_(i) {
  var t, e = i.state, s = i.name, n = i.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, l = Ht(e.placement), c = Mo(l), d = [at, vt].indexOf(l) >= 0, p = d ? "height" : "width";
  if (!(!o || !r)) {
    var f = Jp(n.padding, e), m = ko(o), g = c === "y" ? rt : at, _ = c === "y" ? bt : vt, b = e.rects.reference[p] + e.rects.reference[c] - r[c] - e.rects.popper[p], C = r[c] - e.rects.reference[c], v = Ni(o), T = v ? c === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, E = b / 2 - C / 2, y = f[g], S = T - m[p] - f[_], w = T / 2 - m[p] / 2 + E, D = Ti(y, w, S), L = c;
    e.modifiersData[s] = (t = {}, t[L] = D, t.centerOffset = D - w, t);
  }
}
function e_(i) {
  var t = i.state, e = i.options, s = e.element, n = s === void 0 ? "[data-popper-arrow]" : s;
  n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || bh(t.elements.popper, n) && (t.elements.arrow = n));
}
const Ch = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: t_,
  effect: e_,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function ii(i) {
  return i.split("-")[1];
}
var i_ = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function s_(i, t) {
  var e = i.x, s = i.y, n = t.devicePixelRatio || 1;
  return {
    x: ti(e * n) / n || 0,
    y: ti(s * n) / n || 0
  };
}
function Lr(i) {
  var t, e = i.popper, s = i.popperRect, n = i.placement, o = i.variation, r = i.offsets, l = i.position, c = i.gpuAcceleration, d = i.adaptive, p = i.roundOffsets, f = i.isFixed, m = r.x, g = m === void 0 ? 0 : m, _ = r.y, b = _ === void 0 ? 0 : _, C = typeof p == "function" ? p({
    x: g,
    y: b
  }) : {
    x: g,
    y: b
  };
  g = C.x, b = C.y;
  var v = r.hasOwnProperty("x"), T = r.hasOwnProperty("y"), E = at, y = rt, S = window;
  if (d) {
    var w = Ni(e), D = "clientHeight", L = "clientWidth";
    if (w === Et(e) && (w = re(e), jt(w).position !== "static" && l === "absolute" && (D = "scrollHeight", L = "scrollWidth")), w = w, n === rt || (n === at || n === vt) && o === Je) {
      y = bt;
      var $ = f && w === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[D]
      );
      b -= $ - s.height, b *= c ? 1 : -1;
    }
    if (n === at || (n === rt || n === bt) && o === Je) {
      E = vt;
      var N = f && w === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[L]
      );
      g -= N - s.width, g *= c ? 1 : -1;
    }
  }
  var I = Object.assign({
    position: l
  }, d && i_), k = p === !0 ? s_({
    x: g,
    y: b
  }, Et(e)) : {
    x: g,
    y: b
  };
  if (g = k.x, b = k.y, c) {
    var x;
    return Object.assign({}, I, (x = {}, x[y] = T ? "0" : "", x[E] = v ? "0" : "", x.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", x));
  }
  return Object.assign({}, I, (t = {}, t[y] = T ? b + "px" : "", t[E] = v ? g + "px" : "", t.transform = "", t));
}
function n_(i) {
  var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, o = e.adaptive, r = o === void 0 ? !0 : o, l = e.roundOffsets, c = l === void 0 ? !0 : l, d = {
    placement: Ht(t.placement),
    variation: ii(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Lr(Object.assign({}, d, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: c
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Lr(Object.assign({}, d, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const xo = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: n_,
  data: {}
};
var Fi = {
  passive: !0
};
function o_(i) {
  var t = i.state, e = i.instance, s = i.options, n = s.scroll, o = n === void 0 ? !0 : n, r = s.resize, l = r === void 0 ? !0 : r, c = Et(t.elements.popper), d = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && d.forEach(function(p) {
    p.addEventListener("scroll", e.update, Fi);
  }), l && c.addEventListener("resize", e.update, Fi), function() {
    o && d.forEach(function(p) {
      p.removeEventListener("scroll", e.update, Fi);
    }), l && c.removeEventListener("resize", e.update, Fi);
  };
}
const Ro = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: o_,
  data: {}
};
var r_ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function gs(i) {
  return i.replace(/left|right|bottom|top/g, function(t) {
    return r_[t];
  });
}
var a_ = {
  start: "end",
  end: "start"
};
function Ir(i) {
  return i.replace(/start|end/g, function(t) {
    return a_[t];
  });
}
function Po(i) {
  var t = Et(i), e = t.pageXOffset, s = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: s
  };
}
function Ho(i) {
  return ei(re(i)).left + Po(i).scrollLeft;
}
function l_(i, t) {
  var e = Et(i), s = re(i), n = e.visualViewport, o = s.clientWidth, r = s.clientHeight, l = 0, c = 0;
  if (n) {
    o = n.width, r = n.height;
    var d = gh();
    (d || !d && t === "fixed") && (l = n.offsetLeft, c = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: l + Ho(i),
    y: c
  };
}
function c_(i) {
  var t, e = re(i), s = Po(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, o = be(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = be(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), l = -s.scrollLeft + Ho(i), c = -s.scrollTop;
  return jt(n || e).direction === "rtl" && (l += be(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: l,
    y: c
  };
}
function Bo(i) {
  var t = jt(i), e = t.overflow, s = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + s);
}
function yh(i) {
  return ["html", "body", "#document"].indexOf(Bt(i)) >= 0 ? i.ownerDocument.body : At(i) && Bo(i) ? i : yh(Hs(i));
}
function Ci(i, t) {
  var e;
  t === void 0 && (t = []);
  var s = yh(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), o = Et(s), r = n ? [o].concat(o.visualViewport || [], Bo(s) ? s : []) : s, l = t.concat(r);
  return n ? l : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    l.concat(Ci(Hs(r)))
  );
}
function Jn(i) {
  return Object.assign({}, i, {
    left: i.x,
    top: i.y,
    right: i.x + i.width,
    bottom: i.y + i.height
  });
}
function h_(i, t) {
  var e = ei(i, !1, t === "fixed");
  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;
}
function kr(i, t, e) {
  return t === Do ? Jn(l_(i, e)) : ye(t) ? h_(t, e) : Jn(c_(re(i)));
}
function d_(i) {
  var t = Ci(Hs(i)), e = ["absolute", "fixed"].indexOf(jt(i).position) >= 0, s = e && At(i) ? Ni(i) : i;
  return ye(s) ? t.filter(function(n) {
    return ye(n) && bh(n, s) && Bt(n) !== "body";
  }) : [];
}
function u_(i, t, e, s) {
  var n = t === "clippingParents" ? d_(i) : [].concat(t), o = [].concat(n, [e]), r = o[0], l = o.reduce(function(c, d) {
    var p = kr(i, d, s);
    return c.top = be(p.top, c.top), c.right = Is(p.right, c.right), c.bottom = Is(p.bottom, c.bottom), c.left = be(p.left, c.left), c;
  }, kr(i, r, s));
  return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l;
}
function Ah(i) {
  var t = i.reference, e = i.element, s = i.placement, n = s ? Ht(s) : null, o = s ? ii(s) : null, r = t.x + t.width / 2 - e.width / 2, l = t.y + t.height / 2 - e.height / 2, c;
  switch (n) {
    case rt:
      c = {
        x: r,
        y: t.y - e.height
      };
      break;
    case bt:
      c = {
        x: r,
        y: t.y + t.height
      };
      break;
    case vt:
      c = {
        x: t.x + t.width,
        y: l
      };
      break;
    case at:
      c = {
        x: t.x - e.width,
        y: l
      };
      break;
    default:
      c = {
        x: t.x,
        y: t.y
      };
  }
  var d = n ? Mo(n) : null;
  if (d != null) {
    var p = d === "y" ? "height" : "width";
    switch (o) {
      case Ce:
        c[d] = c[d] - (t[p] / 2 - e[p] / 2);
        break;
      case Je:
        c[d] = c[d] + (t[p] / 2 - e[p] / 2);
        break;
    }
  }
  return c;
}
function si(i, t) {
  t === void 0 && (t = {});
  var e = t, s = e.placement, n = s === void 0 ? i.placement : s, o = e.strategy, r = o === void 0 ? i.strategy : o, l = e.boundary, c = l === void 0 ? oh : l, d = e.rootBoundary, p = d === void 0 ? Do : d, f = e.elementContext, m = f === void 0 ? Be : f, g = e.altBoundary, _ = g === void 0 ? !1 : g, b = e.padding, C = b === void 0 ? 0 : b, v = Eh(typeof C != "number" ? C : Th(C, ai)), T = m === Be ? rh : Be, E = i.rects.popper, y = i.elements[_ ? T : m], S = u_(ye(y) ? y : y.contextElement || re(i.elements.popper), c, p, r), w = ei(i.elements.reference), D = Ah({
    reference: w,
    element: E,
    strategy: "absolute",
    placement: n
  }), L = Jn(Object.assign({}, E, D)), $ = m === Be ? L : w, N = {
    top: S.top - $.top + v.top,
    bottom: $.bottom - S.bottom + v.bottom,
    left: S.left - $.left + v.left,
    right: $.right - S.right + v.right
  }, I = i.modifiersData.offset;
  if (m === Be && I) {
    var k = I[n];
    Object.keys(N).forEach(function(x) {
      var X = [vt, bt].indexOf(x) >= 0 ? 1 : -1, lt = [rt, bt].indexOf(x) >= 0 ? "y" : "x";
      N[x] += k[lt] * X;
    });
  }
  return N;
}
function p_(i, t) {
  t === void 0 && (t = {});
  var e = t, s = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, l = e.flipVariations, c = e.allowedAutoPlacements, d = c === void 0 ? No : c, p = ii(s), f = p ? l ? Qn : Qn.filter(function(_) {
    return ii(_) === p;
  }) : ai, m = f.filter(function(_) {
    return d.indexOf(_) >= 0;
  });
  m.length === 0 && (m = f);
  var g = m.reduce(function(_, b) {
    return _[b] = si(i, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[Ht(b)], _;
  }, {});
  return Object.keys(g).sort(function(_, b) {
    return g[_] - g[b];
  });
}
function __(i) {
  if (Ht(i) === Ps)
    return [];
  var t = gs(i);
  return [Ir(i), t, Ir(t)];
}
function f_(i) {
  var t = i.state, e = i.options, s = i.name;
  if (!t.modifiersData[s]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, l = r === void 0 ? !0 : r, c = e.fallbackPlacements, d = e.padding, p = e.boundary, f = e.rootBoundary, m = e.altBoundary, g = e.flipVariations, _ = g === void 0 ? !0 : g, b = e.allowedAutoPlacements, C = t.options.placement, v = Ht(C), T = v === C, E = c || (T || !_ ? [gs(C)] : __(C)), y = [C].concat(E).reduce(function($e, Gt) {
      return $e.concat(Ht(Gt) === Ps ? p_(t, {
        placement: Gt,
        boundary: p,
        rootBoundary: f,
        padding: d,
        flipVariations: _,
        allowedAutoPlacements: b
      }) : Gt);
    }, []), S = t.rects.reference, w = t.rects.popper, D = /* @__PURE__ */ new Map(), L = !0, $ = y[0], N = 0; N < y.length; N++) {
      var I = y[N], k = Ht(I), x = ii(I) === Ce, X = [rt, bt].indexOf(k) >= 0, lt = X ? "width" : "height", q = si(t, {
        placement: I,
        boundary: p,
        rootBoundary: f,
        altBoundary: m,
        padding: d
      }), ft = X ? x ? vt : at : x ? bt : rt;
      S[lt] > w[lt] && (ft = gs(ft));
      var xi = gs(ft), ce = [];
      if (o && ce.push(q[k] <= 0), l && ce.push(q[ft] <= 0, q[xi] <= 0), ce.every(function($e) {
        return $e;
      })) {
        $ = I, L = !1;
        break;
      }
      D.set(I, ce);
    }
    if (L)
      for (var Ri = _ ? 3 : 1, Us = function(Gt) {
        var di = y.find(function(Hi) {
          var he = D.get(Hi);
          if (he)
            return he.slice(0, Gt).every(function(Gs) {
              return Gs;
            });
        });
        if (di)
          return $ = di, "break";
      }, hi = Ri; hi > 0; hi--) {
        var Pi = Us(hi);
        if (Pi === "break")
          break;
      }
    t.placement !== $ && (t.modifiersData[s]._skip = !0, t.placement = $, t.reset = !0);
  }
}
const Sh = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: f_,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Mr(i, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: i.top - t.height - e.y,
    right: i.right - t.width + e.x,
    bottom: i.bottom - t.height + e.y,
    left: i.left - t.width - e.x
  };
}
function xr(i) {
  return [rt, vt, bt, at].some(function(t) {
    return i[t] >= 0;
  });
}
function m_(i) {
  var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = si(t, {
    elementContext: "reference"
  }), l = si(t, {
    altBoundary: !0
  }), c = Mr(r, s), d = Mr(l, n, o), p = xr(c), f = xr(d);
  t.modifiersData[e] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: d,
    isReferenceHidden: p,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": p,
    "data-popper-escaped": f
  });
}
const wh = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: m_
};
function g_(i, t, e) {
  var s = Ht(i), n = [at, rt].indexOf(s) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: i
  })) : e, r = o[0], l = o[1];
  return r = r || 0, l = (l || 0) * n, [at, vt].indexOf(s) >= 0 ? {
    x: l,
    y: r
  } : {
    x: r,
    y: l
  };
}
function b_(i) {
  var t = i.state, e = i.options, s = i.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = No.reduce(function(p, f) {
    return p[f] = g_(f, t.rects, o), p;
  }, {}), l = r[t.placement], c = l.x, d = l.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += d), t.modifiersData[s] = r;
}
const Oh = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: b_
};
function v_(i) {
  var t = i.state, e = i.name;
  t.modifiersData[e] = Ah({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const Vo = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: v_,
  data: {}
};
function E_(i) {
  return i === "x" ? "y" : "x";
}
function T_(i) {
  var t = i.state, e = i.options, s = i.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, l = r === void 0 ? !1 : r, c = e.boundary, d = e.rootBoundary, p = e.altBoundary, f = e.padding, m = e.tether, g = m === void 0 ? !0 : m, _ = e.tetherOffset, b = _ === void 0 ? 0 : _, C = si(t, {
    boundary: c,
    rootBoundary: d,
    padding: f,
    altBoundary: p
  }), v = Ht(t.placement), T = ii(t.placement), E = !T, y = Mo(v), S = E_(y), w = t.modifiersData.popperOffsets, D = t.rects.reference, L = t.rects.popper, $ = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, N = typeof $ == "number" ? {
    mainAxis: $,
    altAxis: $
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, $), I = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, k = {
    x: 0,
    y: 0
  };
  if (w) {
    if (o) {
      var x, X = y === "y" ? rt : at, lt = y === "y" ? bt : vt, q = y === "y" ? "height" : "width", ft = w[y], xi = ft + C[X], ce = ft - C[lt], Ri = g ? -L[q] / 2 : 0, Us = T === Ce ? D[q] : L[q], hi = T === Ce ? -L[q] : -D[q], Pi = t.elements.arrow, $e = g && Pi ? ko(Pi) : {
        width: 0,
        height: 0
      }, Gt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : vh(), di = Gt[X], Hi = Gt[lt], he = Ti(0, D[q], $e[q]), Gs = E ? D[q] / 2 - Ri - he - di - N.mainAxis : Us - he - di - N.mainAxis, Qd = E ? -D[q] / 2 + Ri + he + Hi + N.mainAxis : hi + he + Hi + N.mainAxis, qs = t.elements.arrow && Ni(t.elements.arrow), Zd = qs ? y === "y" ? qs.clientTop || 0 : qs.clientLeft || 0 : 0, Qo = (x = I == null ? void 0 : I[y]) != null ? x : 0, Jd = ft + Gs - Qo - Zd, tu = ft + Qd - Qo, Zo = Ti(g ? Is(xi, Jd) : xi, ft, g ? be(ce, tu) : ce);
      w[y] = Zo, k[y] = Zo - ft;
    }
    if (l) {
      var Jo, eu = y === "x" ? rt : at, iu = y === "x" ? bt : vt, de = w[S], Bi = S === "y" ? "height" : "width", tr = de + C[eu], er = de - C[iu], Qs = [rt, at].indexOf(v) !== -1, ir = (Jo = I == null ? void 0 : I[S]) != null ? Jo : 0, sr = Qs ? tr : de - D[Bi] - L[Bi] - ir + N.altAxis, nr = Qs ? de + D[Bi] + L[Bi] - ir - N.altAxis : er, or = g && Qs ? Zp(sr, de, nr) : Ti(g ? sr : tr, de, g ? nr : er);
      w[S] = or, k[S] = or - de;
    }
    t.modifiersData[s] = k;
  }
}
const $h = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: T_,
  requiresIfExists: ["offset"]
};
function C_(i) {
  return {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  };
}
function y_(i) {
  return i === Et(i) || !At(i) ? Po(i) : C_(i);
}
function A_(i) {
  var t = i.getBoundingClientRect(), e = ti(t.width) / i.offsetWidth || 1, s = ti(t.height) / i.offsetHeight || 1;
  return e !== 1 || s !== 1;
}
function S_(i, t, e) {
  e === void 0 && (e = !1);
  var s = At(t), n = At(t) && A_(t), o = re(t), r = ei(i, n, e), l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (s || !s && !e) && ((Bt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Bo(o)) && (l = y_(t)), At(t) ? (c = ei(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : o && (c.x = Ho(o))), {
    x: r.left + l.scrollLeft - c.x,
    y: r.top + l.scrollTop - c.y,
    width: r.width,
    height: r.height
  };
}
function w_(i) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), s = [];
  i.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(l) {
      if (!e.has(l)) {
        var c = t.get(l);
        c && n(c);
      }
    }), s.push(o);
  }
  return i.forEach(function(o) {
    e.has(o.name) || n(o);
  }), s;
}
function O_(i) {
  var t = w_(i);
  return mh.reduce(function(e, s) {
    return e.concat(t.filter(function(n) {
      return n.phase === s;
    }));
  }, []);
}
function $_(i) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(i());
      });
    })), t;
  };
}
function D_(i) {
  var t = i.reduce(function(e, s) {
    var n = e[s.name];
    return e[s.name] = n ? Object.assign({}, n, s, {
      options: Object.assign({}, n.options, s.options),
      data: Object.assign({}, n.data, s.data)
    }) : s, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var Rr = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Pr() {
  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)
    t[e] = arguments[e];
  return !t.some(function(s) {
    return !(s && typeof s.getBoundingClientRect == "function");
  });
}
function Bs(i) {
  i === void 0 && (i = {});
  var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Rr : n;
  return function(l, c, d) {
    d === void 0 && (d = o);
    var p = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Rr, o),
      modifiersData: {},
      elements: {
        reference: l,
        popper: c
      },
      attributes: {},
      styles: {}
    }, f = [], m = !1, g = {
      state: p,
      setOptions: function(v) {
        var T = typeof v == "function" ? v(p.options) : v;
        b(), p.options = Object.assign({}, o, p.options, T), p.scrollParents = {
          reference: ye(l) ? Ci(l) : l.contextElement ? Ci(l.contextElement) : [],
          popper: Ci(c)
        };
        var E = O_(D_([].concat(s, p.options.modifiers)));
        return p.orderedModifiers = E.filter(function(y) {
          return y.enabled;
        }), _(), g.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!m) {
          var v = p.elements, T = v.reference, E = v.popper;
          if (Pr(T, E)) {
            p.rects = {
              reference: S_(T, Ni(E), p.options.strategy === "fixed"),
              popper: ko(E)
            }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(N) {
              return p.modifiersData[N.name] = Object.assign({}, N.data);
            });
            for (var y = 0; y < p.orderedModifiers.length; y++) {
              if (p.reset === !0) {
                p.reset = !1, y = -1;
                continue;
              }
              var S = p.orderedModifiers[y], w = S.fn, D = S.options, L = D === void 0 ? {} : D, $ = S.name;
              typeof w == "function" && (p = w({
                state: p,
                options: L,
                name: $,
                instance: g
              }) || p);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: $_(function() {
        return new Promise(function(C) {
          g.forceUpdate(), C(p);
        });
      }),
      destroy: function() {
        b(), m = !0;
      }
    };
    if (!Pr(l, c))
      return g;
    g.setOptions(d).then(function(C) {
      !m && d.onFirstUpdate && d.onFirstUpdate(C);
    });
    function _() {
      p.orderedModifiers.forEach(function(C) {
        var v = C.name, T = C.options, E = T === void 0 ? {} : T, y = C.effect;
        if (typeof y == "function") {
          var S = y({
            state: p,
            name: v,
            instance: g,
            options: E
          }), w = function() {
          };
          f.push(S || w);
        }
      });
    }
    function b() {
      f.forEach(function(C) {
        return C();
      }), f = [];
    }
    return g;
  };
}
var N_ = /* @__PURE__ */ Bs(), L_ = [Ro, Vo, xo, Io], I_ = /* @__PURE__ */ Bs({
  defaultModifiers: L_
}), k_ = [Ro, Vo, xo, Io, Oh, Sh, $h, Ch, wh], ae = /* @__PURE__ */ Bs({
  defaultModifiers: k_
});
const Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: uh,
  afterRead: ch,
  afterWrite: fh,
  applyStyles: Io,
  arrow: Ch,
  auto: Ps,
  basePlacements: ai,
  beforeMain: hh,
  beforeRead: ah,
  beforeWrite: ph,
  bottom: bt,
  clippingParents: oh,
  computeStyles: xo,
  createPopper: ae,
  createPopperBase: N_,
  createPopperLite: I_,
  detectOverflow: si,
  end: Je,
  eventListeners: Ro,
  flip: Sh,
  hide: wh,
  left: at,
  main: dh,
  modifierPhases: mh,
  offset: Oh,
  placements: No,
  popper: Be,
  popperGenerator: Bs,
  popperOffsets: Vo,
  preventOverflow: $h,
  read: lh,
  reference: rh,
  right: vt,
  start: Ce,
  top: rt,
  variationPlacements: Qn,
  viewport: Do,
  write: _h
}, Symbol.toStringTag, { value: "Module" })), M_ = /^aria-[\w-]*$/i, Nh = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", M_],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, x_ = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), R_ = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, P_ = (i, t) => {
  const e = i.nodeName.toLowerCase();
  return t.includes(e) ? x_.has(e) ? !!R_.test(i.nodeValue) : !0 : t.filter((s) => s instanceof RegExp).some((s) => s.test(e));
};
function H_(i, t, e) {
  if (!i.length)
    return i;
  if (e && typeof e == "function")
    return e(i);
  const n = new window.DOMParser().parseFromString(i, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (const r of o) {
    const l = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(l)) {
      r.remove();
      continue;
    }
    const c = [].concat(...r.attributes), d = [].concat(t["*"] || [], t[l] || []);
    for (const p of c)
      P_(p, d) || r.removeAttribute(p.nodeName);
  }
  return n.body.innerHTML;
}
const B_ = "TemplateFactory", V_ = {
  allowList: Nh,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: !1,
  sanitize: !0,
  sanitizeFn: null,
  template: "<div></div>"
}, W_ = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
}, Y_ = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
class F_ extends $i {
  constructor(t) {
    super(), this._config = this._getConfig(t);
  }
  // Getters
  static get Default() {
    return V_;
  }
  static get DefaultType() {
    return W_;
  }
  static get NAME() {
    return B_;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((t) => this._resolvePossibleFunction(t)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(t) {
    return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this;
  }
  toHtml() {
    const t = document.createElement("div");
    t.innerHTML = this._maybeSanitize(this._config.template);
    for (const [n, o] of Object.entries(this._config.content))
      this._setContent(t, o, n);
    const e = t.children[0], s = this._resolvePossibleFunction(this._config.extraClass);
    return s && e.classList.add(...s.split(" ")), e;
  }
  // Private
  _typeCheckConfig(t) {
    super._typeCheckConfig(t), this._checkContent(t.content);
  }
  _checkContent(t) {
    for (const [e, s] of Object.entries(t))
      super._typeCheckConfig({ selector: e, entry: s }, Y_);
  }
  _setContent(t, e, s) {
    const n = M.findOne(s, t);
    if (n) {
      if (e = this._resolvePossibleFunction(e), !e) {
        n.remove();
        return;
      }
      if (zt(e)) {
        this._putElementInTemplate(ne(e), n);
        return;
      }
      if (this._config.html) {
        n.innerHTML = this._maybeSanitize(e);
        return;
      }
      n.textContent = e;
    }
  }
  _maybeSanitize(t) {
    return this._config.sanitize ? H_(t, this._config.allowList, this._config.sanitizeFn) : t;
  }
  _resolvePossibleFunction(t) {
    return _t(t, [this]);
  }
  _putElementInTemplate(t, e) {
    if (this._config.html) {
      e.innerHTML = "", e.append(t);
      return;
    }
    e.textContent = t.textContent;
  }
}
const K_ = "tooltip", z_ = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ln = "fade", X_ = "modal", Ki = "show", j_ = ".tooltip-inner", Hr = `.${X_}`, Br = "hide.bs.modal", pi = "hover", cn = "focus", U_ = "click", G_ = "manual", q_ = "hide", Q_ = "hidden", Z_ = "show", J_ = "shown", tf = "inserted", ef = "click", sf = "focusin", nf = "focusout", of = "mouseenter", rf = "mouseleave", af = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: St() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: St() ? "right" : "left"
}, lf = {
  allowList: Nh,
  animation: !0,
  boundary: "clippingParents",
  container: !1,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: !1,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: !0,
  sanitizeFn: null,
  selector: !1,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
}, cf = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
let Vs = class Lh extends Nt {
  constructor(t, e) {
    if (typeof Dh > "u")
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
  }
  // Getters
  static get Default() {
    return lf;
  }
  static get DefaultType() {
    return cf;
  }
  static get NAME() {
    return K_;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (this._isEnabled) {
      if (this._activeTrigger.click = !this._activeTrigger.click, this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
  }
  dispose() {
    clearTimeout(this._timeout), A.off(
      this._element.closest(Hr),
      Br,
      this._hideModalHandler
    ), this._element.getAttribute("data-mdb-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-mdb-original-title")), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this._isWithContent() && this._isEnabled))
      return;
    const t = A.trigger(this._element, this.constructor.eventName(Z_)), s = (Bc(this._element) || this._element.ownerDocument.documentElement).contains(
      this._element
    );
    if (t.defaultPrevented || !s)
      return;
    this._disposePopper();
    const n = this._getTipElement();
    this._element.setAttribute("aria-describedby", n.getAttribute("id"));
    const { container: o } = this._config;
    if (this._element.ownerDocument.documentElement.contains(this.tip) || (o.append(n), A.trigger(this._element, this.constructor.eventName(tf))), this._popper = this._createPopper(n), n.classList.add(Ki), "ontouchstart" in document.documentElement)
      for (const l of [].concat(...document.body.children))
        A.on(l, "mouseover", Ds);
    const r = () => {
      A.trigger(this._element, this.constructor.eventName(J_)), this._isHovered === !1 && this._leave(), this._isHovered = !1;
    };
    this._queueCallback(r, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown() || A.trigger(this._element, this.constructor.eventName(q_)).defaultPrevented)
      return;
    if (this._getTipElement().classList.remove(Ki), "ontouchstart" in document.documentElement)
      for (const n of [].concat(...document.body.children))
        A.off(n, "mouseover", Ds);
    this._activeTrigger[U_] = !1, this._activeTrigger[cn] = !1, this._activeTrigger[pi] = !1, this._isHovered = null;
    const s = () => {
      this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), A.trigger(this._element, this.constructor.eventName(Q_)));
    };
    this._queueCallback(s, this.tip, this._isAnimated());
  }
  update() {
    this._popper && this._popper.update();
  }
  // Protected
  _isWithContent() {
    return !!this._getTitle();
  }
  _getTipElement() {
    return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
  }
  _createTipElement(t) {
    const e = this._getTemplateFactory(t).toHtml();
    if (!e)
      return null;
    e.classList.remove(ln, Ki), e.classList.add(`bs-${this.constructor.NAME}-auto`);
    const s = bu(this.constructor.NAME).toString();
    return e.setAttribute("id", s), this._isAnimated() && e.classList.add(ln), e;
  }
  setContent(t) {
    this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
  }
  _getTemplateFactory(t) {
    return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new F_({
      ...this._config,
      // the `content` var has to be after `this._config`
      // to override config.content in case of popover
      content: t,
      extraClass: this._resolvePossibleFunction(this._config.customClass)
    }), this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [j_]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-mdb-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(t) {
    return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(ln);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(Ki);
  }
  _createPopper(t) {
    const e = _t(this._config.placement, [this, t, this._element]), s = af[e.toUpperCase()];
    return ae(this._element, t, this._getPopperConfig(s));
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return _t(t, [this._element]);
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: (s) => {
            this._getTipElement().setAttribute("data-popper-placement", s.state.placement);
          }
        }
      ]
    };
    return {
      ...e,
      ..._t(this._config.popperConfig, [e])
    };
  }
  _setListeners() {
    const t = this._config.trigger.split(" ");
    for (const e of t)
      if (e === "click")
        A.on(
          this._element,
          this.constructor.eventName(ef),
          this._config.selector,
          (s) => {
            this._initializeOnDelegatedTarget(s).toggle();
          }
        );
      else if (e !== G_) {
        const s = e === pi ? this.constructor.eventName(of) : this.constructor.eventName(sf), n = e === pi ? this.constructor.eventName(rf) : this.constructor.eventName(nf);
        A.on(this._element, s, this._config.selector, (o) => {
          const r = this._initializeOnDelegatedTarget(o);
          r._activeTrigger[o.type === "focusin" ? cn : pi] = !0, r._enter();
        }), A.on(this._element, n, this._config.selector, (o) => {
          const r = this._initializeOnDelegatedTarget(o);
          r._activeTrigger[o.type === "focusout" ? cn : pi] = r._element.contains(o.relatedTarget), r._leave();
        });
      }
    this._hideModalHandler = () => {
      this._element && this.hide();
    }, A.on(
      this._element.closest(Hr),
      Br,
      this._hideModalHandler
    );
  }
  _fixTitle() {
    const t = this._element.getAttribute("title");
    t && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t), this._element.setAttribute("data-mdb-original-title", t), this._element.removeAttribute("title"));
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = !0;
      return;
    }
    this._isHovered = !0, this._setTimeout(() => {
      this._isHovered && this.show();
    }, this._config.delay.show);
  }
  _leave() {
    this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
      this._isHovered || this.hide();
    }, this._config.delay.hide));
  }
  _setTimeout(t, e) {
    clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(!0);
  }
  _getConfig(t) {
    const e = ie.getDataAttributes(this._element);
    for (const s of Object.keys(e))
      z_.has(s) && delete e[s];
    return t = {
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
  }
  _configAfterMerge(t) {
    return t.container = t.container === !1 ? document.body : ne(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const [e, s] of Object.entries(this._config))
      this.constructor.Default[e] !== s && (t[e] = s);
    return t.selector = !1, t.trigger = "manual", t;
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Lh.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const hf = "popover", df = ".popover-header", uf = ".popover-body", pf = {
  ...Vs.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
}, _f = {
  ...Vs.DefaultType,
  content: "(null|string|element|function)"
};
let ff = class Ih extends Vs {
  // Getters
  static get Default() {
    return pf;
  }
  static get DefaultType() {
    return _f;
  }
  static get NAME() {
    return hf;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [df]: this._getTitle(),
      [uf]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ih.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const Vr = "popover", mf = "show.bs.popover", gf = "shown.bs.popover", bf = "hide.bs.popover", vf = "hidden.bs.popover", Ef = "inserted.bs.popover", Tf = [
  { name: "show" },
  { name: "shown" },
  { name: "hide" },
  { name: "hidden" },
  { name: "inserted" }
];
class BS extends ff {
  constructor(t, e) {
    super(t, e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this.element, mf), h.off(this.element, gf), h.off(this.element, bf), h.off(this.element, vf), h.off(this.element, Ef), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Vr;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    h.extend(this._element, Tf, Vr);
  }
}
const Cf = "scrollspy", yf = "bs.scrollspy", kh = `.${yf}`, Af = `activate${kh}`, Wr = `click${kh}`, Sf = "dropdown-item", Le = "active", hn = "[href]", wf = ".nav, .list-group", Yr = ".nav-link", Of = ".nav-item", $f = ".list-group-item", Df = `${Yr}, ${Of} > ${Yr}, ${$f}`, Nf = ".dropdown", Lf = ".dropdown-toggle", If = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: !1,
  target: null,
  threshold: [0.1, 0.5, 1]
}, kf = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
let Mf = class Mh extends Nt {
  constructor(t, e) {
    super(t, e), this._config.target && (this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    }, this.refresh());
  }
  // Getters
  static get Default() {
    return If;
  }
  static get DefaultType() {
    return kf;
  }
  static get NAME() {
    return Cf;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
    for (const t of this._observableSections.values())
      this._observer.observe(t);
  }
  dispose() {
    this._observer && this._observer.disconnect(), super.dispose();
  }
  // Private
  _configAfterMerge(t) {
    return t.target = ne(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, typeof t.threshold == "string" && (t.threshold = t.threshold.split(",").map((e) => Number.parseFloat(e))), t;
  }
  _maybeEnableSmoothScroll() {
    this._config.smoothScroll && (A.off(this._config.target, Wr), A.on(this._config.target, Wr, hn, (t) => {
      const e = this._observableSections.get(t.target.hash);
      if (e) {
        t.preventDefault();
        const s = this._rootElement || window, n = e.offsetTop - this._element.offsetTop;
        if (s.scrollTo) {
          s.scrollTo({ top: n, behavior: "smooth" });
          return;
        }
        s.scrollTop = n;
      }
    }));
  }
  _getNewObserver() {
    const t = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((e) => this._observerCallback(e), t);
  }
  // The logic of selection
  _observerCallback(t) {
    const e = (r) => this._targetLinks.get(`#${r.target.id}`), s = (r) => {
      this._previousScrollData.visibleEntryTop = r.target.offsetTop, this._process(e(r));
    }, n = (this._rootElement || document.documentElement).scrollTop, o = n >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = n;
    for (const r of t) {
      if (!r.isIntersecting) {
        this._activeTarget = null, this._clearActiveClass(e(r));
        continue;
      }
      const l = r.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (o && l) {
        if (s(r), !n)
          return;
        continue;
      }
      !o && !l && s(r);
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
    const t = M.find(hn, this._config.target);
    for (const e of t) {
      if (!e.hash || Qe(e))
        continue;
      const s = M.findOne(decodeURI(e.hash), this._element);
      Rs(s) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, s));
    }
  }
  _process(t) {
    this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Le), this._activateParents(t), A.trigger(this._element, Af, { relatedTarget: t }));
  }
  _activateParents(t) {
    if (t.classList.contains(Sf)) {
      M.findOne(
        Lf,
        t.closest(Nf)
      ).classList.add(Le);
      return;
    }
    for (const e of M.parents(t, wf))
      for (const s of M.prev(e, Df))
        s.classList.add(Le);
  }
  _clearActiveClass(t) {
    t.classList.remove(Le);
    const e = M.find(
      `${hn}.${Le}`,
      t
    );
    for (const s of e)
      s.classList.remove(Le);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Mh.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const xh = "scrollspy", xf = `mdb.${xh}`, Rf = `.${xf}`, Fr = "activate.bs.scrollspy", Pf = `activate${Rf}`, Rh = "collapsible-scrollspy", Hf = "active", dn = "ul", Bf = `.${Hf}`, Kr = `.${Rh}`;
class VS extends Mf {
  constructor(t, e) {
    super(t, e), this._collapsibles = [], this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._scrollElement, Fr), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return xh;
  }
  // Private
  _init() {
    this._bindActivateEvent(), this._getCollapsibles(), this._collapsibles.length !== 0 && (this._showSubsection(), this._hideSubsection());
  }
  _getHeight(t) {
    return t.offsetHeight;
  }
  _hide(t) {
    const e = u.findOne(dn, t.parentNode);
    e.style.overflow = "hidden", e.style.height = "0px";
  }
  _show(t, e) {
    t.style.height = e;
  }
  _getCollapsibles() {
    const t = u.find(Kr);
    t && t.forEach((e) => {
      const s = e.parentNode, n = u.findOne(dn, s), o = n.offsetHeight;
      this._collapsibles.push({
        element: n,
        relatedTarget: e.getAttribute("href"),
        height: `${o}px`
      });
    });
  }
  _showSubsection() {
    u.find(Bf).filter((s) => a.hasClass(s, Rh)).forEach((s) => {
      const n = u.findOne(dn, s.parentNode), o = this._collapsibles.find((r) => r.relatedTarget = s.getAttribute("href")).height;
      this._show(n, o);
    });
  }
  _hideSubsection() {
    u.find(Kr).filter((e) => a.hasClass(e, "active") === !1).forEach((e) => {
      this._hide(e);
    });
  }
  _bindActivateEvent() {
    h.on(this._element, Fr, (t) => {
      this._showSubsection(), this._hideSubsection(), h.trigger(this._element, Pf, {
        relatedTarget: t.relatedTarget
      });
    });
  }
}
const Vf = "tab", Wf = "bs.tab", Li = `.${Wf}`, Yf = `hide${Li}`, Ff = `hidden${Li}`, Kf = `show${Li}`, zf = `shown${Li}`, Xf = `keydown${Li}`, jf = "ArrowLeft", zr = "ArrowRight", Uf = "ArrowUp", Xr = "ArrowDown", un = "Home", jr = "End", zi = "active", Ur = "fade", pn = "show", Gf = "dropdown", Ph = ".dropdown-toggle", qf = ".dropdown-menu", _n = `:not(${Ph})`, Qf = '.list-group, .nav, [role="tablist"]', Zf = ".nav-item, .list-group-item", Jf = `.nav-link${_n}, .list-group-item${_n}, [role="tab"]${_n}`, tm = "[data-mdb-tab-initialized]", fn = `${Jf}, ${tm}`;
let em = class to extends Nt {
  constructor(t) {
    super(t), this._parent = this._element.closest(Qf), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), A.on(this._element, Xf, (e) => this._keydown(e)));
  }
  // Getters
  static get NAME() {
    return Vf;
  }
  // Public
  show() {
    const t = this._element;
    if (this._elemIsActive(t))
      return;
    const e = this._getActiveElem(), s = e ? A.trigger(e, Yf, { relatedTarget: t }) : null;
    A.trigger(t, Kf, { relatedTarget: e }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
  }
  // Private
  _activate(t, e) {
    if (!t)
      return;
    t.classList.add(zi), this._activate(M.getElementFromSelector(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.add(pn);
        return;
      }
      t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), A.trigger(t, zf, {
        relatedTarget: e
      });
    };
    this._queueCallback(s, t, t.classList.contains(Ur));
  }
  _deactivate(t, e) {
    if (!t)
      return;
    t.classList.remove(zi), t.blur(), this._deactivate(M.getElementFromSelector(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.remove(pn);
        return;
      }
      t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), A.trigger(t, Ff, { relatedTarget: e });
    };
    this._queueCallback(s, t, t.classList.contains(Ur));
  }
  _keydown(t) {
    if (![jf, zr, Uf, Xr, un, jr].includes(
      t.key
    ))
      return;
    t.stopPropagation(), t.preventDefault();
    const e = this._getChildren().filter((n) => !Qe(n));
    let s;
    if ([un, jr].includes(t.key))
      s = e[t.key === un ? 0 : e.length - 1];
    else {
      const n = [zr, Xr].includes(t.key);
      s = Oo(e, t.target, n, !0);
    }
    s && (s.focus({ preventScroll: !0 }), to.getOrCreateInstance(s).show());
  }
  _getChildren() {
    return M.find(fn, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((t) => this._elemIsActive(t)) || null;
  }
  _setInitialAttributes(t, e) {
    this._setAttributeIfNotExists(t, "role", "tablist");
    for (const s of e)
      this._setInitialAttributesOnChild(s);
  }
  _setInitialAttributesOnChild(t) {
    t = this._getInnerElement(t);
    const e = this._elemIsActive(t), s = this._getOuterElement(t);
    t.setAttribute("aria-selected", e), s !== t && this._setAttributeIfNotExists(s, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
  }
  _setInitialAttributesOnTargetPanel(t) {
    const e = M.getElementFromSelector(t);
    e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
  }
  _toggleDropDown(t, e) {
    const s = this._getOuterElement(t);
    if (!s.classList.contains(Gf))
      return;
    const n = (o, r) => {
      const l = M.findOne(o, s);
      l && l.classList.toggle(r, e);
    };
    n(Ph, zi), n(qf, pn), s.setAttribute("aria-expanded", e);
  }
  _setAttributeIfNotExists(t, e, s) {
    t.hasAttribute(e) || t.setAttribute(e, s);
  }
  _elemIsActive(t) {
    return t.classList.contains(zi);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(t) {
    return t.matches(fn) ? t : M.findOne(fn, t);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(t) {
    return t.closest(Zf) || t;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = to.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
};
const Hh = "tab", im = `mdb.${Hh}`, Ws = `.${im}`, Gr = "show.bs.tab", qr = "shown.bs.tab", sm = "hide.bs.tab", nm = "hidden.bs.tab", om = `show${Ws}`, rm = `shown${Ws}`, am = `hide${Ws}`, lm = `hidden${Ws}`, Qr = "active", Zr = "fade", Jr = "show";
class WS extends em {
  constructor(t) {
    super(t), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, Gr), h.off(this._element, qr), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return Hh;
  }
  // Override
  show() {
    const t = this._element;
    if (this._elemIsActive(t))
      return;
    const e = this._getActiveElem();
    let s = null, n = null;
    e && (s = h.trigger(e, sm, { relatedTarget: t }), n = h.trigger(e, am, { relatedTarget: t }));
    const o = h.trigger(t, Gr, { relatedTarget: e }), r = h.trigger(t, om, { relatedTarget: e });
    o.defaultPrevented || r.defaultPrevented || s && s.defaultPrevented || n && n.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
  }
  _activate(t, e) {
    if (!t)
      return;
    t.classList.add(Qr), this._activate(Te(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.add(Jr);
        return;
      }
      t.focus(), t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), h.trigger(t, qr, {
        relatedTarget: e
      }), h.trigger(t, rm, {
        relatedTarget: e
      });
    };
    this._queueCallback(s, t, t.classList.contains(Zr));
  }
  _deactivate(t, e) {
    if (!t)
      return;
    t.classList.remove(Qr), t.blur(), this._deactivate(Te(t));
    const s = () => {
      if (t.getAttribute("role") !== "tab") {
        t.classList.remove(Jr);
        return;
      }
      t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), h.trigger(t, nm, { relatedTarget: e }), h.trigger(t, lm, { relatedTarget: e });
    };
    this._queueCallback(s, t, t.classList.contains(Zr));
  }
}
const ta = "tooltip", cm = "hide.bs.tooltip", hm = "hidden.bs.tooltip", dm = "show.bs.tooltip", um = "shown.bs.tooltip", pm = "inserted.bs.tooltip", _m = [
  { name: "show" },
  { name: "shown" },
  { name: "hide" },
  { name: "hidden" },
  { name: "inserted" }
];
class fm extends Vs {
  constructor(t, e) {
    super(t, e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, dm), h.off(this._element, um), h.off(this._element, cm), h.off(this._element, hm), h.off(this._element, pm), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return ta;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    h.extend(this._element, _m, ta);
  }
}
(() => {
  var i = { 454: (s, n, o) => {
    o.d(n, { Z: () => c });
    var r = o(645), l = o.n(r)()(function(d) {
      return d[1];
    });
    l.push([s.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const c = l;
  }, 645: (s) => {
    s.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var l = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(l, "}") : l;
        }).join("");
      }, o.i = function(r, l, c) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var d = {};
        if (c)
          for (var p = 0; p < this.length; p++) {
            var f = this[p][0];
            f != null && (d[f] = !0);
          }
        for (var m = 0; m < r.length; m++) {
          var g = [].concat(r[m]);
          c && d[g[0]] || (l && (g[2] ? g[2] = "".concat(l, " and ").concat(g[2]) : g[2] = l), o.push(g));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var s = new window.CustomEvent("test", { cancelable: !0 });
          if (s.preventDefault(), s.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, l) {
            var c, d;
            return (l = l || {}).bubbles = !!l.bubbles, l.cancelable = !!l.cancelable, (c = document.createEvent("CustomEvent")).initCustomEvent(r, l.bubbles, l.cancelable, l.detail), d = c.preventDefault, c.preventDefault = function() {
              d.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, c;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (s, n, o) => {
    var r, l = function() {
      var E = {};
      return function(y) {
        if (E[y] === void 0) {
          var S = document.querySelector(y);
          if (window.HTMLIFrameElement && S instanceof window.HTMLIFrameElement)
            try {
              S = S.contentDocument.head;
            } catch {
              S = null;
            }
          E[y] = S;
        }
        return E[y];
      };
    }(), c = [];
    function d(E) {
      for (var y = -1, S = 0; S < c.length; S++)
        if (c[S].identifier === E) {
          y = S;
          break;
        }
      return y;
    }
    function p(E, y) {
      for (var S = {}, w = [], D = 0; D < E.length; D++) {
        var L = E[D], $ = y.base ? L[0] + y.base : L[0], N = S[$] || 0, I = "".concat($, " ").concat(N);
        S[$] = N + 1;
        var k = d(I), x = { css: L[1], media: L[2], sourceMap: L[3] };
        k !== -1 ? (c[k].references++, c[k].updater(x)) : c.push({ identifier: I, updater: T(x, y), references: 1 }), w.push(I);
      }
      return w;
    }
    function f(E) {
      var y = document.createElement("style"), S = E.attributes || {};
      if (S.nonce === void 0) {
        var w = o.nc;
        w && (S.nonce = w);
      }
      if (Object.keys(S).forEach(function(L) {
        y.setAttribute(L, S[L]);
      }), typeof E.insert == "function")
        E.insert(y);
      else {
        var D = l(E.insert || "head");
        if (!D)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        D.appendChild(y);
      }
      return y;
    }
    var m, g = (m = [], function(E, y) {
      return m[E] = y, m.filter(Boolean).join(`
`);
    });
    function _(E, y, S, w) {
      var D = S ? "" : w.media ? "@media ".concat(w.media, " {").concat(w.css, "}") : w.css;
      if (E.styleSheet)
        E.styleSheet.cssText = g(y, D);
      else {
        var L = document.createTextNode(D), $ = E.childNodes;
        $[y] && E.removeChild($[y]), $.length ? E.insertBefore(L, $[y]) : E.appendChild(L);
      }
    }
    function b(E, y, S) {
      var w = S.css, D = S.media, L = S.sourceMap;
      if (D ? E.setAttribute("media", D) : E.removeAttribute("media"), L && typeof btoa < "u" && (w += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(L)))), " */")), E.styleSheet)
        E.styleSheet.cssText = w;
      else {
        for (; E.firstChild; )
          E.removeChild(E.firstChild);
        E.appendChild(document.createTextNode(w));
      }
    }
    var C = null, v = 0;
    function T(E, y) {
      var S, w, D;
      if (y.singleton) {
        var L = v++;
        S = C || (C = f(y)), w = _.bind(null, S, L, !1), D = _.bind(null, S, L, !0);
      } else
        S = f(y), w = b.bind(null, S, y), D = function() {
          (function($) {
            if ($.parentNode === null)
              return !1;
            $.parentNode.removeChild($);
          })(S);
        };
      return w(E), function($) {
        if ($) {
          if ($.css === E.css && $.media === E.media && $.sourceMap === E.sourceMap)
            return;
          w(E = $);
        } else
          D();
      };
    }
    s.exports = function(E, y) {
      (y = y || {}).singleton || typeof y.singleton == "boolean" || (y.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var S = p(E = E || [], y);
      return function(w) {
        if (w = w || [], Object.prototype.toString.call(w) === "[object Array]") {
          for (var D = 0; D < S.length; D++) {
            var L = d(S[D]);
            c[L].references--;
          }
          for (var $ = p(w, y), N = 0; N < S.length; N++) {
            var I = d(S[N]);
            c[I].references === 0 && (c[I].updater(), c.splice(I, 1));
          }
          S = $;
        }
      };
    };
  } }, t = {};
  function e(s) {
    var n = t[s];
    if (n !== void 0)
      return n.exports;
    var o = t[s] = { id: s, exports: {} };
    return i[s](o, o.exports, e), o.exports;
  }
  e.n = (s) => {
    var n = s && s.__esModule ? () => s.default : () => s;
    return e.d(n, { a: n }), n;
  }, e.d = (s, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(s, o) && Object.defineProperty(s, o, { enumerable: !0, get: n[o] });
  }, e.o = (s, n) => Object.prototype.hasOwnProperty.call(s, n), (() => {
    var s = e(379), n = e.n(s), o = e(454);
    function r(c) {
      if (!c.hasAttribute("autocompleted")) {
        c.setAttribute("autocompleted", "");
        var d = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        c.dispatchEvent(d) || (c.value = "");
      }
    }
    function l(c) {
      c.hasAttribute("autocompleted") && (c.removeAttribute("autocompleted"), c.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(c) {
      c.animationName === "onautofillstart" ? r(c.target) : l(c.target);
    }, !0), document.addEventListener("input", function(c) {
      c.inputType !== "insertReplacementText" && "data" in c ? l(c.target) : r(c.target);
    }, !0);
  })();
})();
class F {
  constructor(t) {
    t = rr(t), t && (this._element = t, P.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    P.removeData(this._element, this.constructor.DATA_KEY), h.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  /** Static */
  static getInstance(t) {
    return P.getData(rr(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  static get DATA_KEY() {
    return `mdb.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const mm = "input", gm = "mdb.input", Xi = "active", Bh = "form-notch", Vh = "form-notch-leading", Wh = "form-notch-middle", bm = "form-notch-trailing", vm = "placeholder-active", Em = "form-helper", Tm = "form-counter", ea = `.${Bh}`, ia = `.${Vh}`, Cm = `.${Wh}`, ym = `.${Em}`;
class Wo extends F {
  constructor(t) {
    super(t), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return mm;
  }
  get input() {
    return u.findOne("input", this._element) || u.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    a.addClass(this.input, Xi);
  }
  forceInactive() {
    a.removeClass(this.input, Xi);
  }
  dispose() {
    this._removeBorder(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  /*
    _getIcons() {
      this._leadingIcon = SelectorEngine.findOne('i.leading', this._element);
  
      if (this._leadingIcon !== null) {
        this._applyLeadingIcon();
      }
    }
  
    _applyLeadingIcon() {
      this._label.innerHTML = ` ${this._label.innerHTML}`;
      this._label.insertBefore(this._leadingIcon, this._label.firstChild);
    }
    */
  _getLabelData() {
    this._label = u.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = u.findOne(ym, this._element);
  }
  _getCounter() {
    this._counter = a.getDataAttribute(this.input, "showcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _showCounter() {
    if (u.find(".form-counter", this._element).length > 0)
      return;
    this._counterElement = document.createElement("div"), a.addClass(this._counterElement, Tm);
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    h.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    a.addClass(this.input, vm);
  }
  _getNotchData() {
    this._notchMiddle = u.findOne(Cm, this._element), this._notchLeading = u.findOne(ia, this._element);
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.classList.contains("input-group"))
      return;
    const t = this.input, e = u.prev(t, ".input-group-text")[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = u.find(ea, this._element), e = O("div");
    a.addClass(e, Bh), this._notchLeading = O("div"), a.addClass(this._notchLeading, Vh), this._notchMiddle = O("div"), a.addClass(this._notchMiddle, Wh), this._notchTrailing = O("div"), a.addClass(this._notchTrailing, bm), !(t.length >= 1) && (e.append(this._notchLeading), e.append(this._notchMiddle), e.append(this._notchTrailing), this._element.append(e));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = u.findOne(ea, this._element);
    t && t.remove();
  }
  _activate(t) {
    Dc(() => {
      this._getElements(t);
      const e = t ? t.target : this.input;
      e.value !== "" && a.addClass(e, Xi), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = u.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = u.findOne(".form-notch-middle", t.target.parentNode), this._notchLeading = u.findOne(
        ia,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input;
    e.value === "" && e.classList.remove(Xi), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, gm);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Wo(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Am = "collapse", Sm = "bs.collapse", Ys = `.${Sm}`, wm = `show${Ys}`, Om = `shown${Ys}`, $m = `hide${Ys}`, Dm = `hidden${Ys}`, mn = "show", Fe = "collapse", ji = "collapsing", Nm = "collapsed", Lm = `:scope .${Fe} .${Fe}`, Im = "collapse-horizontal", km = "width", Mm = "height", xm = ".collapse.show, .collapse.collapsing", sa = "[data-mdb-collapse-init]", Rm = {
  parent: null,
  toggle: !0
}, Pm = {
  parent: "(null|element)",
  toggle: "boolean"
};
let gi = class eo extends Nt {
  constructor(t, e) {
    super(t, e), this._isTransitioning = !1, this._triggerArray = [];
    const s = M.find(sa);
    for (const n of s) {
      const o = M.getSelectorFromElement(n), r = M.find(o).filter(
        (l) => l === this._element
      );
      o !== null && r.length && this._triggerArray.push(n);
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return Rm;
  }
  static get DefaultType() {
    return Pm;
  }
  static get NAME() {
    return Am;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [];
    if (this._config.parent && (t = this._getFirstLevelChildren(xm).filter((l) => l !== this._element).map((l) => eo.getOrCreateInstance(l, { toggle: !1 }))), t.length && t[0]._isTransitioning || A.trigger(this._element, wm).defaultPrevented)
      return;
    for (const l of t)
      l.hide();
    const s = this._getDimension();
    this._element.classList.remove(Fe), this._element.classList.add(ji), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const n = () => {
      this._isTransitioning = !1, this._element.classList.remove(ji), this._element.classList.add(Fe, mn), this._element.style[s] = "", A.trigger(this._element, Om);
    }, r = `scroll${s[0].toUpperCase() + s.slice(1)}`;
    this._queueCallback(n, this._element, !0), this._element.style[s] = `${this._element[r]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || A.trigger(this._element, $m).defaultPrevented)
      return;
    const e = this._getDimension();
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Oi(this._element), this._element.classList.add(ji), this._element.classList.remove(Fe, mn);
    for (const n of this._triggerArray) {
      const o = M.getElementFromSelector(n);
      o && !this._isShown(o) && this._addAriaAndCollapsedClass([n], !1);
    }
    this._isTransitioning = !0;
    const s = () => {
      this._isTransitioning = !1, this._element.classList.remove(ji), this._element.classList.add(Fe), A.trigger(this._element, Dm);
    };
    this._element.style[e] = "", this._queueCallback(s, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.classList.contains(mn);
  }
  // Private
  _configAfterMerge(t) {
    return t.toggle = !!t.toggle, t.parent = ne(t.parent), t;
  }
  _getDimension() {
    return this._element.classList.contains(Im) ? km : Mm;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = this._getFirstLevelChildren(sa);
    for (const e of t) {
      const s = M.getElementFromSelector(e);
      s && this._addAriaAndCollapsedClass([e], this._isShown(s));
    }
  }
  _getFirstLevelChildren(t) {
    const e = M.find(Lm, this._config.parent);
    return M.find(t, this._config.parent).filter(
      (s) => !e.includes(s)
    );
  }
  _addAriaAndCollapsedClass(t, e) {
    if (t.length)
      for (const s of t)
        s.classList.toggle(Nm, !e), s.setAttribute("aria-expanded", e);
  }
  // Static
  static jQueryInterface(t) {
    const e = {};
    return typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1), this.each(function() {
      const s = eo.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t]();
      }
    });
  }
};
const na = "collapse", Hm = "show.bs.collapse", Bm = "shown.bs.collapse", Vm = "hide.bs.collapse", Wm = "hidden.bs.collapse", Ym = [{ name: "show" }, { name: "shown" }, { name: "hide" }, { name: "hidden" }];
class YS extends gi {
  constructor(t, e = {}) {
    super(t, e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, Hm), h.off(this._element, Bm), h.off(this._element, Vm), h.off(this._element, Wm), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return na;
  }
  // Private
  _init() {
    this._bindMdbEvents();
  }
  _bindMdbEvents() {
    h.extend(this._element, Ym, na);
  }
}
const oa = "dropdown", Fm = "bs.dropdown", Fs = `.${Fm}`, Km = "Escape", ra = "Tab", zm = "ArrowUp", aa = "ArrowDown", Xm = 2, jm = `hide${Fs}`, Um = `hidden${Fs}`, Gm = `show${Fs}`, qm = `shown${Fs}`, Ve = "show", Qm = "dropup", Zm = "dropend", Jm = "dropstart", tg = "dropup-center", eg = "dropdown-center", bi = "[data-mdb-dropdown-initialized]:not(.disabled):not(:disabled)", ig = `${bi}.${Ve}`, gn = ".dropdown-menu", sg = ".navbar", ng = ".navbar-nav", og = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", rg = St() ? "top-end" : "top-start", ag = St() ? "top-start" : "top-end", lg = St() ? "bottom-end" : "bottom-start", cg = St() ? "bottom-start" : "bottom-end", hg = St() ? "left-start" : "right-start", dg = St() ? "right-start" : "left-start", ug = "top", pg = "bottom", _g = {
  autoClose: !0,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
}, fg = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
let mg = class bs extends Nt {
  constructor(t, e) {
    super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = M.next(this._element, gn)[0] || M.prev(this._element, gn)[0] || M.findOne(gn, this._parent), this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return _g;
  }
  static get DefaultType() {
    return fg;
  }
  static get NAME() {
    return oa;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (Qe(this._element) || this._isShown())
      return;
    const t = {
      relatedTarget: this._element
    };
    if (!A.trigger(this._element, Gm, t).defaultPrevented) {
      if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(ng))
        for (const s of [].concat(...document.body.children))
          A.on(s, "mouseover", Ds);
      this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ve), this._element.classList.add(Ve), A.trigger(this._element, qm, t);
    }
  }
  hide() {
    if (Qe(this._element) || !this._isShown())
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _completeHide(t) {
    if (!A.trigger(this._element, jm, t).defaultPrevented) {
      if ("ontouchstart" in document.documentElement)
        for (const s of [].concat(...document.body.children))
          A.off(s, "mouseover", Ds);
      this._popper && this._popper.destroy(), this._menu.classList.remove(Ve), this._element.classList.remove(Ve), this._element.setAttribute("aria-expanded", "false"), ie.removeDataAttribute(this._menu, "popper"), A.trigger(this._element, Um, t);
    }
  }
  _getConfig(t) {
    if (t = super._getConfig(t), typeof t.reference == "object" && !zt(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${oa.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper() {
    if (typeof Dh > "u")
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    let t = this._element;
    this._config.reference === "parent" ? t = this._parent : zt(this._config.reference) ? t = ne(this._config.reference) : typeof this._config.reference == "object" && (t = this._config.reference);
    const e = this._getPopperConfig();
    this._popper = ae(t, this._menu, e);
  }
  _isShown() {
    return this._menu.classList.contains(Ve);
  }
  _getPlacement() {
    const t = this._parent;
    if (t.classList.contains(Zm))
      return hg;
    if (t.classList.contains(Jm))
      return dg;
    if (t.classList.contains(tg))
      return ug;
    if (t.classList.contains(eg))
      return pg;
    const e = getComputedStyle(this._menu).getPropertyValue("--mdb-position").trim() === "end";
    return t.classList.contains(Qm) ? e ? ag : rg : e ? cg : lg;
  }
  _detectNavbar() {
    return this._element.closest(sg) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return (this._inNavbar || this._config.display === "static") && (ie.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ..._t(this._config.popperConfig, [t])
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const s = M.find(og, this._menu).filter(
      (n) => Rs(n)
    );
    s.length && Oo(s, e, t === aa, !s.includes(e)).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = bs.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t.button === Xm || t.type === "keyup" && t.key !== ra)
      return;
    const e = M.find(ig);
    for (const s of e) {
      const n = bs.getInstance(s);
      if (!n || n._config.autoClose === !1)
        continue;
      const o = t.composedPath(), r = o.includes(n._menu);
      if (o.includes(n._element) || n._config.autoClose === "inside" && !r || n._config.autoClose === "outside" && r || n._menu.contains(t.target) && (t.type === "keyup" && t.key === ra || /input|select|option|textarea|form/i.test(t.target.tagName)))
        continue;
      const l = { relatedTarget: n._element };
      t.type === "click" && (l.clickEvent = t), n._completeHide(l);
    }
  }
  static dataApiKeydownHandler(t) {
    const e = /input|textarea/i.test(t.target.tagName), s = t.key === Km, n = [zm, aa].includes(t.key);
    if (!n && !s || e && !s)
      return;
    t.preventDefault();
    const o = this.matches(bi) ? this : M.prev(this, bi)[0] || M.next(this, bi)[0] || M.findOne(bi, t.delegateTarget.parentNode), r = bs.getOrCreateInstance(o);
    if (n) {
      t.stopPropagation(), r.show(), r._selectMenuItem(t);
      return;
    }
    r._isShown() && (t.stopPropagation(), r.hide(), o.focus());
  }
};
const io = "dropdown", gg = `mdb.${io}`, Ks = `.${gg}`, bg = {
  offset: [0, 2],
  flip: !0,
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  dropdownAnimation: "on"
}, vg = {
  offset: "(array|string|function)",
  flip: "boolean",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  dropdownAnimation: "string"
}, la = "hide.bs.dropdown", ca = "hidden.bs.dropdown", ha = "show.bs.dropdown", da = "shown.bs.dropdown", Eg = `hide${Ks}`, Tg = `hidden${Ks}`, Cg = `show${Ks}`, yg = `shown${Ks}`, bn = "animation", vn = "fade-in", En = "fade-out";
class FS extends mg {
  constructor(t, e) {
    super(t, e), this._config = this._getConfig(e), this._menuStyle = "", this._popperPlacement = "", this._mdbPopperConfig = "";
    const s = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    this._config.dropdownAnimation === "on" && !s && this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, ha), h.off(this._parent, da), h.off(this._parent, la), h.off(this._parent, ca), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  static get NAME() {
    return io;
  }
  // Private
  _init() {
    this._bindShowEvent(), this._bindShownEvent(), this._bindHideEvent(), this._bindHiddenEvent();
  }
  _getConfig(t) {
    const e = {
      ...bg,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(io, e, vg), e;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            altBoundary: this._config.flip,
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (a.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      /* eslint no-extra-parens: "off" */
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _bindShowEvent() {
    h.on(this._element, ha, (t) => {
      if (h.trigger(this._element, Cg, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._dropdownAnimationStart("show");
    });
  }
  _bindShownEvent() {
    h.on(this._parent, da, (t) => {
      if (h.trigger(this._parent, yg, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
    });
  }
  _bindHideEvent() {
    h.on(this._parent, la, (t) => {
      if (h.trigger(this._parent, Eg, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._menuStyle = this._menu.style.cssText, this._popperPlacement = this._menu.getAttribute("data-popper-placement"), this._mdbPopperConfig = this._menu.getAttribute("data-mdb-popper");
    });
  }
  _bindHiddenEvent() {
    h.on(this._parent, ca, (t) => {
      if (h.trigger(this._parent, Tg, {
        relatedTarget: t.relatedTarget
      }).defaultPrevented) {
        t.preventDefault();
        return;
      }
      this._config.display !== "static" && this._menuStyle !== "" && (this._menu.style.cssText = this._menuStyle), this._menu.setAttribute("data-popper-placement", this._popperPlacement), this._menu.setAttribute("data-mdb-popper", this._mdbPopperConfig), this._dropdownAnimationStart("hide");
    });
  }
  _dropdownAnimationStart(t) {
    switch (t) {
      case "show":
        this._menu.classList.add(bn, vn), this._menu.classList.remove(En);
        break;
      default:
        this._menu.classList.add(bn, En), this._menu.classList.remove(vn);
        break;
    }
    this._bindAnimationEnd();
  }
  _bindAnimationEnd() {
    h.one(this._menu, "animationend", () => {
      this._menu.classList.remove(bn, En, vn);
    });
  }
}
const so = "ripple", Ag = "mdb.ripple", Yt = "ripple-surface", ua = "ripple-wave", pa = "input-wrapper", Sg = ".btn", wg = [Sg, `[data-mdb-${so}-init]`], _a = "ripple-surface-unbound", Og = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Ui = [0, 0, 0], $g = [
  "primary",
  "secondary",
  "success",
  "danger",
  "warning",
  "info",
  "light",
  "dark"
], fa = 0.5, Dg = {
  rippleCentered: !1,
  rippleColor: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Ng = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
};
class ks extends F {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this._element && (a.addClass(this._element, Yt), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._rippleInSpan = !1, this.init();
  }
  // Getters
  static get NAME() {
    return so;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    h.off(this._element, "mousedown", this._clickHandler), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _autoInit(t) {
    wg.forEach((s) => {
      u.closest(t.target, s) && (this._element = u.closest(t.target, s));
    });
    const e = a.getDataAttributes(this._element);
    if (!(this._element.classList.contains("btn") && e.rippleInit === !1)) {
      if (this._options = this._getConfig(), this._element.tagName.toLowerCase() === "input") {
        const s = this._element.parentNode;
        if (this._rippleInSpan = !0, s.tagName.toLowerCase() === "span" && s.classList.contains(Yt))
          this._element = s;
        else {
          const n = getComputedStyle(this._element).boxShadow, o = this._element, r = document.createElement("span");
          o.classList.contains("btn-block") && (r.style.display = "block"), h.one(r, "mouseup", (l) => {
            l.button === 0 && o.click();
          }), r.classList.add(Yt, pa), a.addStyle(r, {
            border: 0,
            "box-shadow": n
          }), s.replaceChild(r, this._element), r.appendChild(this._element), this._element = r;
        }
        this._element.focus();
      }
      this._element.style.minWidth || (a.style(this._element, { "min-width": `${getComputedStyle(this._element).width}` }), this._isMinWidthSet = !0), a.addClass(this._element, Yt), this._createRipple(t);
    }
  }
  _addClickEvent(t) {
    h.on(t, "mousedown", this._clickHandler);
  }
  _getEventLayer(t) {
    const e = Math.round(t.clientX - t.target.getBoundingClientRect().x), s = Math.round(t.clientY - t.target.getBoundingClientRect().y);
    return { layerX: e, layerY: s };
  }
  _createRipple(t) {
    if (this._element === null)
      return;
    a.hasClass(this._element, Yt) || a.addClass(this._element, Yt);
    const { layerX: e, layerY: s } = this._getEventLayer(t), n = e, o = s, r = this._element.offsetHeight, l = this._element.offsetWidth, c = this._durationToMsNumber(this._options.rippleDuration), d = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? l / 2 : o,
      height: r,
      width: l
    }, p = this._getDiameter(d), f = this._options.rippleRadius || p / 2, m = {
      delay: c * fa,
      duration: c - c * fa
    }, g = {
      left: this._options.rippleCentered ? `${l / 2 - f}px` : `${n - f}px`,
      top: this._options.rippleCentered ? `${r / 2 - f}px` : `${o - f}px`,
      height: `${this._options.rippleRadius * 2 || p}px`,
      width: `${this._options.rippleRadius * 2 || p}px`,
      transitionDelay: `0s, ${m.delay}ms`,
      transitionDuration: `${c}ms, ${m.duration}ms`
    }, _ = O("div");
    this._createHTMLRipple({ wrapper: this._element, ripple: _, styles: g }), this._removeHTMLRipple({ ripple: _, duration: c });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: s }) {
    Object.keys(s).forEach((n) => e.style[n] = s[n]), e.classList.add(ua), this._options.rippleColor !== "" && (this._removeOldColorClasses(t), this._addColor(e, t)), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), this._rippleTimer = setTimeout(() => {
      t && (t.remove(), this._element && (u.find(`.${ua}`, this._element).forEach((s) => {
        s.remove();
      }), this._isMinWidthSet && (a.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1), this._rippleInSpan && this._element.classList.contains(pa) ? this._removeWrapperSpan() : a.removeClass(this._element, Yt)));
    }, e);
  }
  _removeWrapperSpan() {
    const t = this._element.firstChild;
    this._element.replaceWith(t), this._element = t, this._element.focus(), this._rippleInSpan = !1;
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...Dg,
      ...e,
      ...t
    }, Y(so, t, Ng), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: s, width: n }) {
    const o = e <= s / 2, r = t <= n / 2, l = (m, g) => Math.sqrt(m ** 2 + g ** 2), c = e === s / 2 && t === n / 2, d = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, p = {
      topLeft: l(t, e),
      topRight: l(n - t, e),
      bottomLeft: l(t, s - e),
      bottomRight: l(n - t, s - e)
    };
    let f = 0;
    return c || d.fourth ? f = p.topLeft : d.third ? f = p.topRight : d.second ? f = p.bottomRight : d.first && (f = p.bottomLeft), f * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      a.addClass(t, "active");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? a.addClass(t, _a) : t.classList.remove(_a);
  }
  _addColor(t, e) {
    if ($g.find(
      (n) => n === this._options.rippleColor.toLowerCase()
    ))
      a.addClass(
        e,
        `${Yt}-${this._options.rippleColor.toLowerCase()}`
      );
    else {
      const n = this._colorToRGB(this._options.rippleColor).join(","), o = Og.split("{{color}}").join(`${n}`);
      t.style.backgroundImage = `radial-gradient(circle, ${o})`;
    }
  }
  _removeOldColorClasses(t) {
    const e = new RegExp(`${Yt}-[a-z]+`, "gi");
    (t.classList.value.match(e) || []).forEach((n) => {
      t.classList.remove(n);
    });
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function s(o) {
      const r = document.body.appendChild(document.createElement("fictum")), l = "rgb(1, 2, 3)";
      return r.style.color = l, r.style.color !== l || (r.style.color = o, r.style.color === l || r.style.color === "") ? Ui : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? Ui : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = s(t)), t.indexOf("rgb") === 0 ? n(t) : Ui);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return P.getData(this, Ag) ? null : new ks(this, t);
    });
  }
}
const Lg = "range", Ig = "mdb.range", Yh = "thumb", ma = "thumb-active", kg = "thumb-value", Mg = `.${kg}`, xg = `.${Yh}`;
class Fh extends F {
  constructor(t) {
    super(t), this._initiated = !1, this._thumb = null, this._element && (this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return Lg;
  }
  get rangeInput() {
    return u.findOne("input[type=range]", this._element);
  }
  // Public
  init() {
    this._initiated || (this._addThumb(), this._thumbUpdate(), this._handleEvents(), this._initiated = !0);
  }
  dispose() {
    this._disposeEvents(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _addThumb() {
    const t = O("span");
    a.addClass(t, Yh), t.innerHTML = '<span class="thumb-value"></span>', this._element.append(t), this._thumb = u.findOne(xg, this._element);
  }
  _handleEvents() {
    h.on(this.rangeInput, "mousedown", () => this._showThumb()), h.on(this.rangeInput, "mouseup", () => this._hideThumb()), h.on(this.rangeInput, "touchstart", () => this._showThumb()), h.on(this.rangeInput, "touchend", () => this._hideThumb()), h.on(this.rangeInput, "input", () => this._thumbUpdate());
  }
  _disposeEvents() {
    h.off(this.rangeInput, "mousedown"), h.off(this.rangeInput, "mouseup"), h.off(this.rangeInput, "touchstart"), h.off(this.rangeInput, "touchend"), h.off(this.rangeInput, "input");
  }
  _showThumb() {
    a.addClass(this._thumb, ma);
  }
  _hideThumb() {
    a.removeClass(this._thumb, ma);
  }
  _thumbUpdate() {
    const t = this.rangeInput, e = t.value, s = t.min ? t.min : 0, n = t.max ? t.max : 100, o = u.findOne(Mg, this._thumb);
    o.textContent = e;
    const r = Number((e - s) * 100 / (n - s));
    a.style(this._thumb, { left: `calc(${r}% + (${8 - r * 0.15}px))` });
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Ig);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Fh(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const ga = "animation", Rg = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationDuration: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, Pg = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationDuration: 500,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class Yo extends F {
  constructor(t, e) {
    super(t), this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return ga;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    h.off(this._element, "mousedown"), h.off(this._animateElement, "animationend"), h.off(window, "scroll"), h.off(this._element, "mouseover"), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = a.getDataAttribute(this._element, "animation-target");
    return t ? u.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._animateElement);
    return t = {
      ...Pg,
      ...e,
      ...t
    }, Y(ga, t, Rg), t;
  }
  _animateOnScroll() {
    const t = a.offset(this._animateElement).top, e = this._animateElement.offsetHeight, s = window.innerHeight, n = t + this._options.animationOffset <= s && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    a.addClass(this._animateElement, "animation"), a.addClass(this._animateElement, this._options.animation);
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(this._options.animation, "animation");
  }
  _removeInvisibleClass() {
    a.removeClass(this._animateElement, "invisible");
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._removeInvisibleClass(), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    a.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    a.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    a.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    a.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    h.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    a.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    a.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    h.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    h.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), h.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    h.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    h.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), h.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new Yo(this[0], t).init();
  }
}
const no = "lightbox", oo = "mdb.lightbox", Hg = `.${oo}`, Bg = ".data-api", Ie = `click${Hg}${Bg}`, Vg = "lightbox", Wg = "lightbox-gallery", Yg = "lightbox-gallery-toolbar", Fg = "lightbox-gallery-content", Kg = "lightbox-gallery-counter", zg = "lightbox-gallery-fullscreen-btn", Xg = "lightbox-gallery-zoom-btn", jg = "lightbox-gallery-left-tools", Ug = "lightbox-gallery-right-tools", Gg = "lightbox-gallery-close-btn", qg = "lightbox-gallery-loader", Qg = "lightbox-gallery-arrow-left", Zg = "lightbox-gallery-arrow-right", Jg = "lightbox-gallery-caption-wrapper", ba = "lightbox-gallery-caption", tb = "lightbox-gallery-image", eb = `[data-mdb-${no}-init] img:not(.lightbox-disabled)`, ib = {
  container: "string",
  zoomLevel: "(number|string)"
}, sb = {
  container: "body",
  zoomLevel: 1
};
class vs extends F {
  constructor(t, e = {}) {
    super(t), this._options = e, this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return no;
  }
  get activeImg() {
    return this._activeImg;
  }
  get currentImg() {
    return u.findOne(".active", this._galleryContent);
  }
  get options() {
    const t = {
      ...sb,
      ...a.getDataAttributes(this._element),
      ...this._options
    };
    return Y(no, t, ib), t;
  }
  // Public
  init() {
    this._initiated || (this._appendTemplate(), this._initiated = !0);
  }
  open(t = 0) {
    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then((e) => {
      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();
    });
  }
  close() {
    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed");
  }
  slide(t = "right") {
    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents("slide", "slid"), this._beforeSlideEvents(), t === "right" && this._slideHorizontally(t), t === "left" && this._slideHorizontally(t), t === "first" && this._slideToTarget(t), t === "last" && this._slideToTarget(t), this._afterSlideEvents());
  }
  zoomIn() {
    this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), a.style(this.currentImg.parentNode, { transform: `scale(${this._zoom})` }), this._updateZoomBtn());
  }
  zoomOut() {
    this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), a.style(this.currentImg.parentNode, { transform: `scale(${this._zoom})` }), this._updateZoomBtn(), this._updateImgPosition());
  }
  toggleFullscreen() {
    this._fullscreen === !1 ? (a.addClass(this._fullscreenBtn, "active"), this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (a.removeClass(this._fullscreenBtn, "active"), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);
  }
  reset() {
    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);
  }
  dispose() {
    h.off(document, Ie, eb, this.toggle), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), P.removeData(this._element, oo), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), this._element = null;
  }
  // Private
  _getImages() {
    const e = u.find("img", this._element).filter((s) => !s.classList.contains("lightbox-disabled"));
    this._images = e;
  }
  _getContainer() {
    this._container = u.findOne(this.options.container);
  }
  _setActiveImg(t) {
    this._activeImg = typeof t == "number" ? t : this._images.indexOf(t.target);
  }
  _appendTemplate() {
    this._gallery = O("div"), a.addClass(this._gallery, Wg), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);
  }
  _appendToolbar() {
    this._galleryToolbar = O("div"), this._imgCounter = O("p"), this._fullscreenBtn = O("button"), this._zoomBtn = O("button");
    const t = O("div"), e = O("div"), s = O("button");
    a.addClass(this._galleryToolbar, Yg), a.addClass(this._imgCounter, Kg), a.addClass(this._fullscreenBtn, zg), a.addClass(this._zoomBtn, Xg), a.addClass(t, jg), a.addClass(e, Ug), a.addClass(s, Gg), this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), s.setAttribute("aria-label", "Close"), h.on(this._fullscreenBtn, Ie, () => this.toggleFullscreen()), h.on(this._zoomBtn, Ie, () => this._toggleZoom()), h.on(s, Ie, () => this.close()), t.append(this._imgCounter), e.append(this._fullscreenBtn), e.append(this._zoomBtn), e.append(s), this._galleryToolbar.append(t), this._galleryToolbar.append(e), this._gallery.append(this._galleryToolbar);
  }
  _appendContent() {
    this._galleryContent = O("div"), a.addClass(this._galleryContent, Fg), this._gallery.append(this._galleryContent);
  }
  _appendLoader() {
    this._loader = O("div");
    const t = O("div"), e = O("span");
    a.addClass(this._loader, qg), a.addClass(t, "spinner-grow"), a.addClass(t, "text-light"), a.addClass(e, "sr-only"), t.setAttribute("role", "status"), e.innerHTML = "Loading...", t.append(e), this._loader.append(t), this._gallery.append(this._loader);
  }
  _appendArrows() {
    this._leftArrowWrapper = O("div"), a.addClass(this._leftArrowWrapper, Qg);
    const t = O("button");
    t.setAttribute("aria-label", "Previous"), h.on(t, Ie, () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = O("div"), a.addClass(this._rightArrowWrapper, Zg), this._rightArrow = O("button"), this._rightArrow.setAttribute("aria-label", "Next"), h.on(this._rightArrow, Ie, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));
  }
  _appendCaption() {
    const t = O("div"), e = O("p");
    a.addClass(t, Jg), a.addClass(e, ba), t.append(e), this._gallery.append(t);
  }
  _sortImages() {
    for (let t = 0; t < this._activeImg; t++)
      this._images.push(this._images.shift());
  }
  async _loadImages() {
    const t = [], e = [];
    this._galleryContent.innerHTML = "";
    let s = 0;
    return this._images.forEach((n, o) => {
      t.push(
        new Promise((r) => {
          const l = new Image(), c = O("div");
          a.addClass(c, tb), this._addImgStyles(l, c, s, o, n), c.append(l), this._galleryContent.append(c), l.onload = r, l.src = n.dataset.mdbImg || n.src, e.push(l), s += 100;
        })
      );
    }), await Promise.all(t), e;
  }
  _addImgStyles(t, e, s, n, o) {
    t.alt = o.alt, t.draggable = !1, a.style(e, { position: "absolute", left: `${s}%`, top: 0 }), (o.dataset.mdbCaption || o.dataset.mdbCaption === "") && (t.dataset.caption = o.dataset.mdbCaption), s === 0 ? (t.width < t.height && a.addClass(t, "vertical"), a.style(e, { opacity: 1 }), a.addClass(t, "active")) : a.removeClass(t, "active"), n === this._images.length - 1 && this._images.length > 1 && a.style(e, { left: "-100%" });
  }
  _resizeImages(t) {
    t.forEach((e) => {
      this._calculateImgSize(e);
    });
  }
  _calculateImgSize(t) {
    t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = "auto", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = "auto", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;
  }
  _onResize() {
    this._images = u.find("img", this._galleryContent), this._images.forEach((t) => {
      this._calculateImgSize(t);
    });
  }
  _onFullscreenChange() {
    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, a.removeClass(this._fullscreenBtn, "active"));
  }
  _beforeSlideEvents() {
    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();
  }
  _slideHorizontally(t) {
    this._images = u.find("img", this._galleryContent), this._images.forEach((e) => {
      let s;
      t === "right" ? (s = parseInt(e.parentNode.style.left, 10) - 100, s < -100 && (s = (this._images.length - 2) * 100)) : (s = parseInt(e.parentNode.style.left, 10) + 100, s === (this._images.length - 1) * 100 && (s = -100)), this._slideImg(e, s);
    }), this._updateActiveImg(t);
  }
  _slideImg(t, e) {
    e === 0 ? (a.addClass(t, "active"), a.style(t.parentNode, { opacity: 1, transform: "scale(1)" })) : (a.removeClass(t, "active"), a.style(t.parentNode, { opacity: 0, transform: "scale(0.25)" })), t.parentNode.style.left = `${e}%`;
  }
  _slideToTarget(t) {
    t === "first" && this._activeImg === 0 || t === "last" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === "first" ? 0 : this._images.length - 1, this._sortImages(), a.style(this.currentImg.parentNode, { transform: "scale(0.25)", opacity: 0 }), setTimeout(() => {
      this._loadImages().then((e) => {
        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
          a.style(this.currentImg.parentNode, { transform: "scale(1)", opacity: 1 });
        }, 10);
      });
    }, 400));
  }
  _updateActiveImg(t) {
    t === "right" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === "left" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);
  }
  _afterSlideEvents() {
    this._updateCounter(), this._updateCaption();
  }
  _updateCounter() {
    this._images.length <= 1 || setTimeout(() => {
      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;
    }, 200);
  }
  _updateCaption() {
    setTimeout(() => {
      let t = this.currentImg.alt;
      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === "") && (t = this.currentImg.dataset.caption), u.findOne(`.${ba}`, this._gallery).innerHTML = t;
    }, 200);
  }
  _toggleTemplate() {
    this._gallery.style.visibility === "visible" ? (a.style(this.currentImg.parentNode, { transform: "scale(0.25)" }), setTimeout(() => {
      this._hideGallery(), this._enableScroll(), this._showLoader();
    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());
  }
  _showLoader() {
    a.style(this._loader, { opacity: 1 });
  }
  _hideLoader() {
    a.style(this._loader, { opacity: 0 });
  }
  _hideGallery() {
    a.style(this._gallery, { opacity: 0, pointerEvents: "none", visibility: "hidden" });
  }
  _showGallery() {
    a.style(this._gallery, {
      opacity: 1,
      pointerEvents: "initial",
      visibility: "visible"
    }), setTimeout(() => {
      a.style(this.currentImg.parentNode, { transform: "scale(1)" });
    }, 50);
  }
  _toggleZoom() {
    this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn();
  }
  _updateZoomBtn() {
    this._zoom > 1 ? (a.addClass(this._zoomBtn, "active"), this._zoomBtn.setAttribute("aria-label", "Zoom out")) : (a.removeClass(this._zoomBtn, "active"), this._zoomBtn.setAttribute("aria-label", "Zoom in"));
  }
  _updateImgPosition() {
    this._zoom === 1 && this._restoreDefaultPosition();
  }
  _addEvents() {
    const t = u.find("img", this._galleryContent);
    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {
      h.on(e, "mousedown", this._onImgMousedown, { passive: !0 }), h.on(e, "touchstart", this._onImgMousedown, { passive: !0 }), h.on(e, "mousemove", this._onImgMousemove, { passive: !0 }), h.on(e, "touchmove", this._onImgMousemove, { passive: !0 }), h.on(e, "wheel", this._onImgWheel, { passive: !0 }), h.on(e, "dblclick", this._onImgDoubleClick, { passive: !0 });
    }), document.addEventListener("touchmove", this._onWindowTouchmove, { passive: !1 }), h.on(window, "touchstart", this._onWindowTouchstart), h.on(window, "mouseup", this._onImgMouseup), h.on(window, "touchend", this._onImgTouchend), h.on(window, "resize", this._onWindowResize), h.on(window, "orientationchange", this._onWindowResize), h.on(window, "keyup", this._onKeyupEvent), h.on(window, "fullscreenchange", this._onWindowFullscreenChange), h.on(this._gallery, "mousemove", this._onAnyImgAction), h.on(this._gallery, "click", this._onGalleryClick), h.on(this._rightArrow, "keydown", this._onRightArrowKeydownEvent), h.on(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent);
  }
  _removeEvents() {
    u.find("img", this._galleryContent).forEach((e) => {
      h.off(e, "mousedown", this._onImgMousedown), h.off(e, "touchstart", this._onImgMousedown), h.off(e, "mousemove", this._onImgMousemove), h.off(e, "touchmove", this._onImgMousemove), h.off(e, "wheel", this._onImgWheel), h.off(e, "dblclick", this._onImgDoubleClick);
    }), document.removeEventListener("touchmove", this._onWindowTouchmove, { passive: !1 }), h.off(window, "touchstart", this._onWindowTouchstart), h.off(window, "mouseup", this._onImgMouseup), h.off(window, "touchend", this._onImgTouchend), h.off(window, "resize", this._onWindowResize), h.off(window, "orientationchange", this._onWindowResize), h.off(window, "keyup", this._onKeyupEvent), h.off(window, "fullscreenchange", this._onWindowFullscreenChange), h.off(this._gallery, "mousemove", this._onAnyImgAction), h.off(this._gallery, "click", this._onGalleryClick), h.off(this._rightArrow, "keydown", this._onRightArrowKeydownEvent), h.off(this._fullscreenBtn, "keydown", this._onFullscreenBtnKeydownEvent);
  }
  _onMousedown(t) {
    const e = t.touches, s = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = s * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === "touchstart" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onMousemove(t) {
    if (!this._mousedown)
      return;
    const e = t.touches, s = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    if (e && this._resetToolsToggler(), !this._multitouch)
      if (this._zoom !== 1)
        this._positionX = s * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, a.style(this.currentImg, {
          left: `${this._positionX}px`,
          top: `${this._positionY}px`
        });
      else {
        if (this._images.length <= 1)
          return;
        this._positionX = s * (1 / this._zoom) - this._mousedownPositionX, a.style(this.currentImg, { left: `${this._positionX}px` });
      }
  }
  _onMouseup(t) {
    this._mousedown = !1, this._moveImg(t.target);
  }
  _onTouchend(t) {
    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));
  }
  _calculateTouchZoom(t) {
    const e = Math.hypot(
      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,
      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY
    ), s = Math.hypot(
      t.touches[1].pageX - t.touches[0].pageX,
      t.touches[1].pageY - t.touches[0].pageY
    ), n = Math.abs(e - s), o = t.view.screen.width;
    n > o * 0.03 && (e <= s ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);
  }
  _onWindowTouchstart(t) {
    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onWindowTouchmove(t) {
    t.preventDefault(), t.type === "touchmove" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);
  }
  _onRightArrowKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (t.shiftKey)
          break;
        t.preventDefault(), this._focusFullscreenBtn();
        break;
    }
  }
  _onFullscreenBtnKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (!t.shiftKey)
          break;
        t.preventDefault(), this._focusRightArrow();
        break;
    }
  }
  _onKeyup(t) {
    switch (this._resetToolsToggler(), t.keyCode) {
      case 39:
        B ? this.slide("left") : this.slide();
        break;
      case 37:
        B ? this.slide() : this.slide("left");
        break;
      case 27:
        this.close();
        break;
      case 36:
        this.slide("first");
        break;
      case 35:
        this.slide("last");
        break;
      case 38:
        this.zoomIn();
        break;
      case 40:
        this.zoomOut();
        break;
    }
  }
  _focusFullscreenBtn() {
    setTimeout(() => {
      this._fullscreenBtn.focus();
    }, 100);
  }
  _focusRightArrow() {
    this._rightArrow.focus();
  }
  _moveImg(t) {
    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)
      return;
    const e = this._positionX - this._originalPositionX;
    e > 0 ? B ? this.slide() : this.slide("left") : e < 0 && (B ? this.slide("left") : this.slide());
  }
  _checkDoubleTap(t) {
    clearTimeout(this._doubleTapTimer);
    const s = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;
    this._tapCounter > 0 && s < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;
    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());
  }
  _resetDoubleTap() {
    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);
  }
  _onDoubleClick(t) {
    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());
  }
  _onZoom(t) {
    if (t.deltaY > 0)
      this.zoomOut();
    else {
      if (this._zoom >= 3)
        return;
      this._setNewPositionOnZoomIn(t), this.zoomIn();
    }
  }
  _onBackdropClick(t) {
    this._resetToolsToggler(), t.target.tagName === "DIV" && this.close();
  }
  _setNewPositionOnZoomIn(t) {
    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {
      this.currentImg.style.transition = "none";
    }, 500);
  }
  _resetToolsToggler() {
    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();
  }
  _setToolsToggleTimout() {
    this._toolsToggleTimer = setTimeout(() => {
      this._hideTools(), clearTimeout(this._toolsToggleTimer);
    }, 4e3);
  }
  _hideTools() {
    a.style(this._galleryToolbar, { opacity: 0 }), a.style(this._leftArrowWrapper, { opacity: 0 }), a.style(this._rightArrowWrapper, { opacity: 0 });
  }
  _showTools() {
    a.style(this._galleryToolbar, { opacity: 1 }), a.style(this._leftArrowWrapper, { opacity: 1 }), a.style(this._rightArrowWrapper, { opacity: 1 });
  }
  _disableScroll() {
    a.addClass(document.body, "disabled-scroll"), document.documentElement.scrollHeight > document.documentElement.clientHeight && a.addClass(document.body, "replace-scrollbar");
  }
  _enableScroll() {
    setTimeout(() => {
      a.removeClass(document.body, "disabled-scroll"), a.removeClass(document.body, "replace-scrollbar");
    }, 300);
  }
  _animationStart() {
    this._animating = !0, setTimeout(() => {
      this._animating = !1;
    }, 400);
  }
  _restoreDefaultZoom() {
    this._zoom !== 1 && (this._zoom = 1, a.style(this.currentImg.parentNode, { transform: `scale(${this._zoom})` }), this._updateZoomBtn(), this._updateImgPosition());
  }
  _restoreDefaultFullscreen() {
    this._fullscreen && this.toggleFullscreen();
  }
  _restoreDefaultPosition() {
    clearTimeout(this._zoomTimer);
    const t = this.currentImg;
    a.style(this.currentImg.parentNode, { left: 0, top: 0 }), a.style(this.currentImg, { transition: "all 0.5s ease-out", left: 0, top: 0 }), this._calculateImgSize(t), setTimeout(() => {
      a.style(this.currentImg, { transition: "none" });
    }, 500);
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.mdb.lightbox`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.mdb.lightbox`);
    }, 505);
  }
  static toggle() {
    return function(t) {
      const e = u.closest(t.target, `.${Vg}`);
      (vs.getInstance(e) || new vs(e)).open(t);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, oo);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new vs(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const ro = "rating", Kh = `mdb.${ro}`, li = `.${Kh}`, nb = "ArrowLeft", ob = "ArrowRight", rb = {
  tooltip: "string",
  value: "(string|number)",
  readonly: "boolean",
  after: "string",
  before: "string",
  dynamic: "boolean"
}, ab = {
  tooltip: "top",
  value: "",
  readonly: !1,
  after: "",
  before: "",
  dynamic: !1
}, va = `scoreSelect${li}`, lb = `scoreHover${li}`, Ea = `keyup${li}`, Ta = `focusout${li}`, Ca = `keydown${li}`, ya = `mousedown${li}`;
class ao extends F {
  constructor(t, e) {
    super(t), this._icons = u.find("i", this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._fn = {}, this._tooltips = [], this._element && (this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return ro;
  }
  dispose() {
    this._options.readonly || (h.off(this._element, Ea), h.off(this._element, Ta), h.off(this._element, Ca), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
      h.off(t, ya), t.removeEventListener("mouseenter", this._fn.mouseenter[e]);
    }), this._tooltips.forEach((t) => {
      t._element.removeAttribute("data-mdb-toggle"), t.dispose();
    }), this._element.removeAttribute("tabIndex")), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost()), this._options.dynamic && this._saveOriginalClassList(), this._setCustomText(), this._setCustomColor(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...ab,
      ...e,
      ...t
    }, Y(ro, t, rb), t;
  }
  _bindMouseEnter() {
    this._fn.mouseenter = [], this._icons.forEach((t, e) => {
      t.addEventListener(
        "mouseenter",
        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose
        // prettier-ignore
        this._fn.mouseenter[e] = (s) => {
          this._index = this._icons.indexOf(s.target), this._updateRating(this._index), this._triggerEvents(t, lb);
        }
      );
    });
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      "mouseleave",
      // this._fn.mouseleave is needed to create reference and unpin events after call dispose
      // prettier-ignore
      this._fn.mouseleave = () => {
        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());
      }
    );
  }
  _bindMouseDown() {
    this._icons.forEach((t) => {
      h.on(t, ya, () => {
        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, va);
      });
    });
  }
  _bindKeyDown() {
    this._element.tabIndex = 0, h.on(this._element, Ca, (t) => this._updateAfterKeyDown(t));
  }
  _bindKeyUp() {
    h.on(this._element, Ea, () => this._setElementOutline("auto"));
  }
  _bindFocusLost() {
    h.on(this._element, Ta, () => this._setElementOutline("none"));
  }
  _setElementOutline(t) {
    this._element.style.outline = t;
  }
  _triggerEvents(t, e) {
    h.trigger(t, e, {
      value: this._index + 1
    });
  }
  _updateAfterKeyDown(t) {
    const e = this._icons.length - 1, s = this._index;
    t.key === ob && this._index < e && (this._index += 1), t.key === nb && this._index > -1 && (this._index -= 1), s !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], va));
  }
  _updateRating(t) {
    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, s) => {
      s <= t && (e.classList.add("fas", "active"), e.classList.remove("far"));
    });
  }
  _clearRating() {
    this._icons.forEach((t, e) => {
      this._options.dynamic ? t.classList = this._originalClassList[e] : (t.classList.remove("fas", "active"), t.classList.add("far"));
    });
  }
  _setToolTips() {
    this._icons.forEach((t, e) => {
      const s = a.getDataAttribute(t, "toggle");
      t.title && !s && (a.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new fm(t, { placement: this._options.tooltip }));
    });
  }
  _setCustomText() {
    this._icons.forEach((t) => {
      const e = a.getDataAttribute(t, "after"), s = a.getDataAttribute(t, "before");
      e && t.insertAdjacentHTML("afterEnd", e), s && t.insertAdjacentHTML("beforeBegin", s);
    });
  }
  _setCustomColor() {
    this._icons.forEach((t) => {
      const e = a.getDataAttribute(t, "color");
      e && (t.style.color = e);
    });
  }
  _saveOriginalClassList() {
    this._icons.forEach((t) => {
      const e = t.classList.value;
      this._originalClassList.push(e);
    });
  }
  _restoreOriginalIcon(t) {
    const e = this._originalClassList[t], s = a.getDataAttribute(this._icons[t], "color");
    this._icons.forEach((n, o) => {
      o <= t && (n.classList = e, n.style.color = s);
    });
  }
  // Static
  static autoInit(t) {
    return new ao(t);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Kh);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose|hide/.test(t)) && (s || (s = new ao(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
function Rt(i) {
  return getComputedStyle(i);
}
function ht(i, t) {
  for (const e in t) {
    let s = t[e];
    typeof s == "number" && (s = `${s}px`), i.style[e] = s;
  }
  return i;
}
function Gi(i) {
  const t = document.createElement("div");
  return t.className = i, t;
}
const Aa = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function te(i, t) {
  if (!Aa)
    throw new Error("No element matching method supported");
  return Aa.call(i, t);
}
function Ke(i) {
  i.remove ? i.remove() : i.parentNode && i.parentNode.removeChild(i);
}
function Sa(i, t) {
  return Array.prototype.filter.call(i.children, (e) => te(e, t));
}
const Q = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: (i) => `ps__thumb-${i}`,
    rail: (i) => `ps__rail-${i}`,
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: (i) => `ps--active-${i}`,
    scrolling: (i) => `ps--scrolling-${i}`
  }
}, zh = { x: null, y: null };
function Xh(i, t) {
  const e = i.element.classList, s = Q.state.scrolling(t);
  e.contains(s) ? clearTimeout(zh[t]) : e.add(s);
}
function jh(i, t) {
  zh[t] = setTimeout(
    () => i.isAlive && i.element.classList.remove(Q.state.scrolling(t)),
    i.settings.scrollingThreshold
  );
}
function cb(i, t) {
  Xh(i, t), jh(i, t);
}
let hb = class {
  constructor(t) {
    this.element = t, this.handlers = {};
  }
  bind(t, e) {
    typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
  }
  unbind(t, e) {
    this.handlers[t] = this.handlers[t].filter((s) => e && s !== e ? !0 : (this.element.removeEventListener(t, s, !1), !1));
  }
  unbindAll() {
    for (const t in this.handlers)
      this.unbind(t);
  }
  get isEmpty() {
    return Object.keys(this.handlers).every((t) => this.handlers[t].length === 0);
  }
}, db = class {
  constructor() {
    this.eventElements = [];
  }
  eventElement(t) {
    let e = this.eventElements.filter((s) => s.element === t)[0];
    return e || (e = new hb(t), this.eventElements.push(e)), e;
  }
  bind(t, e, s) {
    this.eventElement(t).bind(e, s);
  }
  unbind(t, e, s) {
    const n = this.eventElement(t);
    n.unbind(e, s), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
  }
  unbindAll() {
    this.eventElements.forEach((t) => t.unbindAll()), this.eventElements = [];
  }
  once(t, e, s) {
    const n = this.eventElement(t), o = (r) => {
      n.unbind(e, o), s(r);
    };
    n.bind(e, o);
  }
};
function qi(i) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(i);
  const t = document.createEvent("CustomEvent");
  return t.initCustomEvent(i, !1, !1, void 0), t;
}
function Qi(i, t, e, s = !0, n = !1) {
  let o;
  if (t === "top")
    o = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
  else if (t === "left")
    o = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
  else
    throw new Error("A proper axis should be provided");
  ub(i, e, o, s, n);
}
function ub(i, t, [e, s, n, o, r, l], c = !0, d = !1) {
  const p = i.element;
  i.reach[o] = null, p[n] < 1 && (i.reach[o] = "start"), p[n] > i[e] - i[s] - 1 && (i.reach[o] = "end"), t && (p.dispatchEvent(qi(`ps-scroll-${o}`)), t < 0 ? p.dispatchEvent(qi(`ps-scroll-${r}`)) : t > 0 && p.dispatchEvent(qi(`ps-scroll-${l}`)), c && cb(i, o)), i.reach[o] && (t || d) && p.dispatchEvent(qi(`ps-${o}-reach-${i.reach[o]}`));
}
function K(i) {
  return parseInt(i, 10) || 0;
}
function pb(i) {
  return te(i, "input,[contenteditable]") || te(i, "select,[contenteditable]") || te(i, "textarea,[contenteditable]") || te(i, "button,[contenteditable]");
}
function _b(i) {
  const t = Rt(i);
  return K(t.width) + K(t.paddingLeft) + K(t.paddingRight) + K(t.borderLeftWidth) + K(t.borderRightWidth);
}
const We = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Xt(i) {
  const t = i.element, e = Math.floor(t.scrollTop), s = t.getBoundingClientRect();
  i.containerWidth = Math.floor(s.width), i.containerHeight = Math.floor(s.height), i.contentWidth = t.scrollWidth, i.contentHeight = t.scrollHeight, t.contains(i.scrollbarXRail) || (Sa(t, Q.element.rail("x")).forEach((n) => Ke(n)), t.appendChild(i.scrollbarXRail)), t.contains(i.scrollbarYRail) || (Sa(t, Q.element.rail("y")).forEach((n) => Ke(n)), t.appendChild(i.scrollbarYRail)), !i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth ? (i.scrollbarXActive = !0, i.railXWidth = i.containerWidth - i.railXMarginWidth, i.railXRatio = i.containerWidth / i.railXWidth, i.scrollbarXWidth = wa(i, K(i.railXWidth * i.containerWidth / i.contentWidth)), i.scrollbarXLeft = K(
    (i.negativeScrollAdjustment + t.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
  )) : i.scrollbarXActive = !1, !i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight ? (i.scrollbarYActive = !0, i.railYHeight = i.containerHeight - i.railYMarginHeight, i.railYRatio = i.containerHeight / i.railYHeight, i.scrollbarYHeight = wa(
    i,
    K(i.railYHeight * i.containerHeight / i.contentHeight)
  ), i.scrollbarYTop = K(
    e * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
  )) : i.scrollbarYActive = !1, i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth && (i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth), i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight && (i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight), fb(t, i), i.scrollbarXActive ? t.classList.add(Q.state.active("x")) : (t.classList.remove(Q.state.active("x")), i.scrollbarXWidth = 0, i.scrollbarXLeft = 0, t.scrollLeft = i.isRtl === !0 ? i.contentWidth : 0), i.scrollbarYActive ? t.classList.add(Q.state.active("y")) : (t.classList.remove(Q.state.active("y")), i.scrollbarYHeight = 0, i.scrollbarYTop = 0, t.scrollTop = 0);
}
function wa(i, t) {
  return i.settings.minScrollbarLength && (t = Math.max(t, i.settings.minScrollbarLength)), i.settings.maxScrollbarLength && (t = Math.min(t, i.settings.maxScrollbarLength)), t;
}
function fb(i, t) {
  const e = { width: t.railXWidth }, s = Math.floor(i.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth - t.contentWidth : e.left = i.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - s : e.top = t.scrollbarXTop + s, ht(t.scrollbarXRail, e);
  const n = { top: s, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + i.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - i.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + i.scrollLeft, ht(t.scrollbarYRail, n), ht(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ht(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function mb(i) {
  i.event.bind(i.scrollbarY, "mousedown", (t) => t.stopPropagation()), i.event.bind(i.scrollbarYRail, "mousedown", (t) => {
    const s = t.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += s * i.containerHeight, Xt(i), t.stopPropagation();
  }), i.event.bind(i.scrollbarX, "mousedown", (t) => t.stopPropagation()), i.event.bind(i.scrollbarXRail, "mousedown", (t) => {
    const s = t.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += s * i.containerWidth, Xt(i), t.stopPropagation();
  });
}
function gb(i) {
  Oa(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Oa(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Oa(i, [
  t,
  e,
  s,
  n,
  o,
  r,
  l,
  c,
  d
]) {
  const p = i.element;
  let f = null, m = null, g = null;
  function _(v) {
    v.touches && v.touches[0] && (v[s] = v.touches[0].pageY), p[l] = f + g * (v[s] - m), Xh(i, c), Xt(i), v.stopPropagation(), v.preventDefault();
  }
  function b() {
    jh(i, c), i[d].classList.remove(Q.state.clicking), i.event.unbind(i.ownerDocument, "mousemove", _);
  }
  function C(v, T) {
    f = p[l], T && v.touches && (v[s] = v.touches[0].pageY), m = v[s], g = (i[e] - i[t]) / (i[n] - i[r]), T ? i.event.bind(i.ownerDocument, "touchmove", _) : (i.event.bind(i.ownerDocument, "mousemove", _), i.event.once(i.ownerDocument, "mouseup", b), v.preventDefault()), i[d].classList.add(Q.state.clicking), v.stopPropagation();
  }
  i.event.bind(i[o], "mousedown", (v) => {
    C(v);
  }), i.event.bind(i[o], "touchstart", (v) => {
    C(v, !0);
  });
}
function bb(i) {
  const t = i.element, e = () => te(t, ":hover"), s = () => te(i.scrollbarX, ":focus") || te(i.scrollbarY, ":focus");
  function n(o, r) {
    const l = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!i.scrollbarYActive)
        return !1;
      if (l === 0 && r > 0 || l >= i.contentHeight - i.containerHeight && r < 0)
        return !i.settings.wheelPropagation;
    }
    const c = t.scrollLeft;
    if (r === 0) {
      if (!i.scrollbarXActive)
        return !1;
      if (c === 0 && o < 0 || c >= i.contentWidth - i.containerWidth && o > 0)
        return !i.settings.wheelPropagation;
    }
    return !0;
  }
  i.event.bind(i.ownerDocument, "keydown", (o) => {
    if (o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented || !e() && !s())
      return;
    let r = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (r) {
      if (r.tagName === "IFRAME")
        r = r.contentDocument.activeElement;
      else
        for (; r.shadowRoot; )
          r = r.shadowRoot.activeElement;
      if (pb(r))
        return;
    }
    let l = 0, c = 0;
    switch (o.which) {
      case 37:
        o.metaKey ? l = -i.contentWidth : o.altKey ? l = -i.containerWidth : l = -30;
        break;
      case 38:
        o.metaKey ? c = i.contentHeight : o.altKey ? c = i.containerHeight : c = 30;
        break;
      case 39:
        o.metaKey ? l = i.contentWidth : o.altKey ? l = i.containerWidth : l = 30;
        break;
      case 40:
        o.metaKey ? c = -i.contentHeight : o.altKey ? c = -i.containerHeight : c = -30;
        break;
      case 32:
        o.shiftKey ? c = i.containerHeight : c = -i.containerHeight;
        break;
      case 33:
        c = i.containerHeight;
        break;
      case 34:
        c = -i.containerHeight;
        break;
      case 36:
        c = i.contentHeight;
        break;
      case 35:
        c = -i.contentHeight;
        break;
      default:
        return;
    }
    i.settings.suppressScrollX && l !== 0 || i.settings.suppressScrollY && c !== 0 || (t.scrollTop -= c, t.scrollLeft += l, Xt(i), n(l, c) && o.preventDefault());
  });
}
function vb(i) {
  const t = i.element;
  function e(r, l) {
    const c = Math.floor(t.scrollTop), d = t.scrollTop === 0, p = c + t.offsetHeight === t.scrollHeight, f = t.scrollLeft === 0, m = t.scrollLeft + t.offsetWidth === t.scrollWidth;
    let g;
    return Math.abs(l) > Math.abs(r) ? g = d || p : g = f || m, g ? !i.settings.wheelPropagation : !0;
  }
  function s(r) {
    let l = r.deltaX, c = -1 * r.deltaY;
    return (typeof l > "u" || typeof c > "u") && (l = -1 * r.wheelDeltaX / 6, c = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (l *= 10, c *= 10), l !== l && c !== c && (l = 0, c = r.wheelDelta), r.shiftKey ? [-c, -l] : [l, c];
  }
  function n(r, l, c) {
    if (!We.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    let d = r;
    for (; d && d !== t; ) {
      if (d.classList.contains(Q.element.consuming))
        return !0;
      const p = Rt(d);
      if (c && p.overflowY.match(/(scroll|auto)/)) {
        const f = d.scrollHeight - d.clientHeight;
        if (f > 0 && (d.scrollTop > 0 && c < 0 || d.scrollTop < f && c > 0))
          return !0;
      }
      if (l && p.overflowX.match(/(scroll|auto)/)) {
        const f = d.scrollWidth - d.clientWidth;
        if (f > 0 && (d.scrollLeft > 0 && l < 0 || d.scrollLeft < f && l > 0))
          return !0;
      }
      d = d.parentNode;
    }
    return !1;
  }
  function o(r) {
    const [l, c] = s(r);
    if (n(r.target, l, c))
      return;
    let d = !1;
    i.settings.useBothWheelAxes ? i.scrollbarYActive && !i.scrollbarXActive ? (c ? t.scrollTop -= c * i.settings.wheelSpeed : t.scrollTop += l * i.settings.wheelSpeed, d = !0) : i.scrollbarXActive && !i.scrollbarYActive && (l ? t.scrollLeft += l * i.settings.wheelSpeed : t.scrollLeft -= c * i.settings.wheelSpeed, d = !0) : (t.scrollTop -= c * i.settings.wheelSpeed, t.scrollLeft += l * i.settings.wheelSpeed), Xt(i), d = d || e(l, c), d && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
  }
  typeof window.onwheel < "u" ? i.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && i.event.bind(t, "mousewheel", o);
}
function Eb(i) {
  if (!We.supportsTouch && !We.supportsIePointer)
    return;
  const t = i.element;
  function e(_, b) {
    const C = Math.floor(t.scrollTop), v = t.scrollLeft, T = Math.abs(_), E = Math.abs(b);
    if (E > T) {
      if (b < 0 && C === i.contentHeight - i.containerHeight || b > 0 && C === 0)
        return window.scrollY === 0 && b > 0 && We.isChrome;
    } else if (T > E && (_ < 0 && v === i.contentWidth - i.containerWidth || _ > 0 && v === 0))
      return !0;
    return !0;
  }
  function s(_, b) {
    t.scrollTop -= b, t.scrollLeft -= _, Xt(i);
  }
  let n = {}, o = 0, r = {}, l = null;
  function c(_) {
    return _.targetTouches ? _.targetTouches[0] : _;
  }
  function d(_) {
    return _.pointerType && _.pointerType === "pen" && _.buttons === 0 ? !1 : !!(_.targetTouches && _.targetTouches.length === 1 || _.pointerType && _.pointerType !== "mouse" && _.pointerType !== _.MSPOINTER_TYPE_MOUSE);
  }
  function p(_) {
    if (!d(_))
      return;
    const b = c(_);
    n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), l !== null && clearInterval(l);
  }
  function f(_, b, C) {
    if (!t.contains(_))
      return !1;
    let v = _;
    for (; v && v !== t; ) {
      if (v.classList.contains(Q.element.consuming))
        return !0;
      const T = Rt(v);
      if (C && T.overflowY.match(/(scroll|auto)/)) {
        const E = v.scrollHeight - v.clientHeight;
        if (E > 0 && (v.scrollTop > 0 && C < 0 || v.scrollTop < E && C > 0))
          return !0;
      }
      if (b && T.overflowX.match(/(scroll|auto)/)) {
        const E = v.scrollWidth - v.clientWidth;
        if (E > 0 && (v.scrollLeft > 0 && b < 0 || v.scrollLeft < E && b > 0))
          return !0;
      }
      v = v.parentNode;
    }
    return !1;
  }
  function m(_) {
    if (d(_)) {
      const b = c(_), C = { pageX: b.pageX, pageY: b.pageY }, v = C.pageX - n.pageX, T = C.pageY - n.pageY;
      if (f(_.target, v, T))
        return;
      s(v, T), n = C;
      const E = (/* @__PURE__ */ new Date()).getTime(), y = E - o;
      y > 0 && (r.x = v / y, r.y = T / y, o = E), e(v, T) && _.preventDefault();
    }
  }
  function g() {
    i.settings.swipeEasing && (clearInterval(l), l = setInterval(function() {
      if (i.isInitialized) {
        clearInterval(l);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(l);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(l);
        return;
      }
      s(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  We.supportsTouch ? (i.event.bind(t, "touchstart", p), i.event.bind(t, "touchmove", m), i.event.bind(t, "touchend", g)) : We.supportsIePointer && (window.PointerEvent ? (i.event.bind(t, "pointerdown", p), i.event.bind(t, "pointermove", m), i.event.bind(t, "pointerup", g)) : window.MSPointerEvent && (i.event.bind(t, "MSPointerDown", p), i.event.bind(t, "MSPointerMove", m), i.event.bind(t, "MSPointerUp", g)));
}
const Tb = () => ({
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollingThreshold: 1e3,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  suppressScrollX: !1,
  suppressScrollY: !1,
  swipeEasing: !0,
  useBothWheelAxes: !1,
  wheelPropagation: !0,
  wheelSpeed: 1
}), Cb = {
  "click-rail": mb,
  "drag-thumb": gb,
  keyboard: bb,
  wheel: vb,
  touch: Eb
};
let Uh = class {
  constructor(t, e = {}) {
    if (typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
      throw new Error("no element is specified to initialize PerfectScrollbar");
    this.element = t, t.classList.add(Q.main), this.settings = Tb();
    for (const l in e)
      this.settings[l] = e[l];
    this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
    const s = () => t.classList.add(Q.state.focus), n = () => t.classList.remove(Q.state.focus);
    this.isRtl = Rt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(Q.rtl), this.isNegativeScroll = (() => {
      const l = t.scrollLeft;
      let c = null;
      return t.scrollLeft = -1, c = t.scrollLeft < 0, t.scrollLeft = l, c;
    })(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new db(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = Gi(Q.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = Gi(Q.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", s), this.event.bind(this.scrollbarX, "blur", n), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
    const o = Rt(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(o.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = K(o.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = K(o.borderLeftWidth) + K(o.borderRightWidth), ht(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = K(o.marginLeft) + K(o.marginRight), ht(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = Gi(Q.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = Gi(Q.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", s), this.event.bind(this.scrollbarY, "blur", n), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
    const r = Rt(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(r.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = K(r.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? _b(this.scrollbarY) : null, this.railBorderYWidth = K(r.borderTopWidth) + K(r.borderBottomWidth), ht(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = K(r.marginTop) + K(r.marginBottom), ht(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
      x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
      y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    }, this.isAlive = !0, this.settings.handlers.forEach((l) => Cb[l](this)), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", (l) => this.onScroll(l)), Xt(this);
  }
  update() {
    this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ht(this.scrollbarXRail, { display: "block" }), ht(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = K(Rt(this.scrollbarXRail).marginLeft) + K(Rt(this.scrollbarXRail).marginRight), this.railYMarginHeight = K(Rt(this.scrollbarYRail).marginTop) + K(Rt(this.scrollbarYRail).marginBottom), ht(this.scrollbarXRail, { display: "none" }), ht(this.scrollbarYRail, { display: "none" }), Xt(this), Qi(this, "top", 0, !1, !0), Qi(this, "left", 0, !1, !0), ht(this.scrollbarXRail, { display: "" }), ht(this.scrollbarYRail, { display: "" }));
  }
  onScroll(t) {
    this.isAlive && (Xt(this), Qi(this, "top", this.element.scrollTop - this.lastScrollTop), Qi(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
  }
  destroy() {
    this.isAlive && (this.event.unbindAll(), Ke(this.scrollbarX), Ke(this.scrollbarY), Ke(this.scrollbarXRail), Ke(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
  }
  removePsClasses() {
    this.element.className = this.element.className.split(" ").filter((t) => !t.match(/^ps([-_].+|)$/)).join(" ");
  }
};
class Fo {
  constructor(t, e = {}, s) {
    this._element = t, this._toggler = s, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && n.target === this._lastElement && (n.preventDefault(), this._firstElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Kt(e))
        return !1;
      const s = u.parents(e, "*");
      for (let n = 0; n < s.length; n++) {
        const o = window.getComputedStyle(s[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    const t = u.find(this._selector, this._element);
    this._focusableElements = t.filter((e) => {
      const s = e.getAttribute("data-mdb-disabled") === "true" || e.hasAttribute("disabled");
      return e.disabled || s ? null : e;
    }), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
const Ue = 37, tt = 38, Ge = 39, J = 40, ve = 36, Ee = 35, Tn = 33, Cn = 34, ot = 13, Es = 32, Ae = 27, Se = 9, yb = 8, Ab = 46, Sb = {
  threshold: 10,
  direction: "all"
};
let wb = class {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...Sb,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), s = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(s);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      h.trigger(this._element, `swipe${r}`), h.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (h.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}, Ob = class {
  constructor(t, e = "swipe", s = {}) {
    this._element = t, this._event = e, this.swipe = new wb(t, s), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener("touchstart", (t) => this._handleTouchStart(t)), this._element.addEventListener("touchmove", (t) => this._handleTouchMove(t)), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
};
const $a = "sidenav", Da = "mdb.sidenav", yn = "rotate-icon", $b = "sidenav-backdrop", Na = '[data-mdb-toggle="sidenav"]', Db = "[data-mdb-collapse-init]", Nb = '[data-mdb-slim="true"]', Lb = '[data-mdb-slim="false"]', Ib = ".sidenav-menu", ke = ".sidenav-collapse", _i = ".sidenav-link", kb = B ? 100 : -100, Mb = B ? -100 : 100;
let La = 0;
const xb = {
  accordion: "(boolean)",
  backdrop: "(boolean)",
  backdropClass: "(null|string)",
  closeOnEsc: "(boolean)",
  color: "(string)",
  content: "(null|string)",
  expandable: "(boolean)",
  expandOnHover: "(boolean)",
  focusTrap: "(boolean)",
  hidden: "(boolean)",
  mode: "(string)",
  scrollContainer: "(null|string)",
  slim: "(boolean)",
  slimCollapsed: "(boolean)",
  slimWidth: "(number)",
  position: "(string)",
  right: "(boolean)",
  transitionDuration: "(number)",
  width: "(number)"
}, Rb = {
  accordion: !1,
  backdrop: !0,
  backdropClass: null,
  closeOnEsc: !0,
  color: "primary",
  content: null,
  expandable: !0,
  expandOnHover: !1,
  focusTrap: !0,
  hidden: !0,
  mode: "over",
  scrollContainer: null,
  slim: !1,
  slimCollapsed: !1,
  slimWidth: 77,
  position: "fixed",
  right: !1,
  transitionDuration: 300,
  width: 240
};
class Ts extends F {
  constructor(t, e = {}) {
    super(t), this._options = e, La++, this._ID = La, this._backdrop = null, this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this.escHandler = (s) => {
      s.keyCode === Ae && this.toggler && Kt(this.toggler) && (this._update(!1), h.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && this._setup(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return $a;
  }
  get container() {
    if (this.options.position === "fixed")
      return u.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("position-relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.position !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: s } = this._element.getBoundingClientRect();
    if (this.options.right && !B || !this.options.right && B) {
      let n = 0;
      if (this.container.scrollHeight > this.container.clientHeight && (n = this.container.offsetWidth - this.container.clientWidth), this.container.tagName === "BODY") {
        const o = document.documentElement.clientWidth;
        n = Math.abs(window.innerWidth - o);
      }
      return Math.abs(s + n - e) > 10;
    }
    return Math.abs(s - t) < 10;
  }
  get links() {
    return u.find(_i, this._element);
  }
  get navigation() {
    return u.find(Ib, this._element);
  }
  get options() {
    const t = {
      ...Rb,
      ...a.getDataAttributes(this._element),
      ...this._options
    };
    return Y($a, t, xb), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.position === "fixed" ? "100vh" : "100%",
      position: this.options.position,
      transitionDuration: this.transitionDuration,
      transitionProperty: "transform, width, padding, margin",
      transitionTimingFunction: "linear"
    };
  }
  get toggler() {
    return u.find(Na).find((e) => {
      const s = a.getDataAttribute(e, "target");
      return u.findOne(s) === this._element;
    });
  }
  get transitionDuration() {
    return `${this.options.transitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.right ? Mb : kb;
  }
  get width() {
    return this._slimCollapsed ? this.options.slimWidth : this.options.width;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    this._backdrop && this._removeBackdrop(), h.off(window, "keydown", this.escHandler), h.off(window, "hashchange", this.hashHandler), this._touch.dispose(), P.removeData(this._element, Da), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  hide() {
    this._setVisibility(!1), this._update(!1);
  }
  show() {
    this._setVisibility(!0), this._update(!0);
  }
  toggle() {
    this._setVisibility(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  // Private
  _appendArrow(t) {
    const e = O("i");
    ["fas", "fa-angle-down", yn].forEach((s) => {
      a.addClass(e, s);
    }), u.find(`.${yn}`, t).length === 0 && t.appendChild(e);
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      u.find(ke, t).forEach((s) => {
        gi.getInstance(s).hide();
      });
    });
  }
  _setupBackdrop() {
    const t = [];
    this.options.backdropClass && t.push(this.options.backdropClass);
    const e = {
      transition: `opacity ${this.transitionDuration} ease-out`,
      position: this.options.position,
      width: this.options.position === "fixed" ? "100vw" : "100%",
      height: this.options.position === "fixed" ? "100vh" : "100%"
    };
    if (!this._backdrop) {
      const s = O("div");
      t.push($b), e.opacity = 0, h.on(s, "click", () => {
        this._setVisibility(!1), this._update(!1);
      }), this._backdrop = s;
    }
    this._backdrop.classList.add(...t), a.style(this._backdrop, e);
  }
  _getOffsetValue(t, { index: e, property: s, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[s].property]
    ), r = t ? n[s].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, s) => s === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.slim && this.options.expandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.slim || !this.options.expandable ? this.toggler && Kt(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return u.find(Db, this._element).filter(
      (s) => s.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return u.find(ke, this._element).filter((t) => Kt(t)).length === 0;
  }
  _setup() {
    this._setupTouch(), this.options.focusTrap && this._setupFocusTrap(), this.options.backdrop && (this._setupBackdrop(), !this.options.hidden && this.options.mode === "over" && this._appendBackdrop()), this._setupCollapse(), this.options.slimCollapsed && a.addClass(this._element, "sidenav-slim"), this.options.slim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.content && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.hidden || (this.options.right && this.show(), this._updateOffsets(!0, !0));
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      h.on(t, "click", () => this._setActiveElements(t)), h.on(t, "keydown", (e) => {
        e.keyCode === ot && this._setActiveElements(t);
      });
    }), h.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      u.find(ke, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: s, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.classList.add("collapse"), t.setAttribute("id", o);
    const [r] = u.prev(t, _i);
    a.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const l = gi.getInstance(t) || new gi(t, {
      toggle: !1,
      parent: this.options.accordion ? s : t
    });
    this._appendArrow(r), a.hasClass(t, "show") && this._rotateArrow(r, 180), h.on(r, "click", (c) => {
      this._toggleCategory(c, l, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.mode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(t, "show.bs.collapse", () => this._rotateArrow(r, 180)), h.on(t, "hide.bs.collapse", () => this._rotateArrow(r, 0)), h.on(t, "shown.bs.collapse", () => {
      this.options.mode === "over" && this._focusTrap && this._focusTrap.update();
    }), h.on(t, "hidden.bs.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.mode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = u.find(this.options.content), this._initialContentStyle || (this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: s, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: s, marginLeft: n, marginRight: o, transition: r };
    }));
  }
  _setupFocusTrap() {
    this._focusTrap = new Fo(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === Se,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), a.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.scrollContainer) {
      t = u.findOne(this.options.scrollContainer, this._element);
      const s = au(t.parentNode.children).filter((n) => n !== t).reduce((n, o) => n + o.clientHeight, 0);
      a.style(t, {
        maxHeight: `calc(100% - ${s}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new Uh(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
  }
  _setupSlim() {
    this._slimCollapsed = this.options.slimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.expandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = ks.getInstance(t);
      if (e && e._options.color !== this.options.color)
        e.dispose();
      else if (e)
        return;
      e = new ks(t, { rippleColor: this.options.color });
    });
  }
  _setupTouch() {
    this._touch = new Ob(this._element, "swipe", { threshold: 20 }), this._touch.init(), h.on(this._element, "swipeleft", (t) => this._handleSwipe(t, this.options.right)), h.on(this._element, "swiperight", (t) => this._handleSwipe(t, !this.options.right));
  }
  _setActive(t, e) {
    a.addClass(t, "active"), this._activeNode && this._activeNode.classList.remove("active"), this._activeNode = t;
    const [s] = u.parents(this._activeNode, ke);
    if (!s) {
      this._setActiveCategory();
      return;
    }
    const [n] = u.prev(s, _i);
    this._setActiveCategory(n), !e && !this._slimCollapsed && gi.getInstance(s).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      u.find(ke, e).forEach((n) => {
        const [o] = u.prev(n, _i);
        o !== t ? o.classList.remove("active") : a.addClass(o, "active");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      u.find(_i, e).filter((n) => u.next(n, ke).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    });
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { color: e } = this.options, s = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), a.addClass(this._element, `sidenav-${s}`);
  }
  _setContentOffsets(t, e, s) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, { index: o, property: "padding", offsets: e }), l = this._getOffsetValue(t, { index: o, property: "margin", offsets: e }), c = {};
      if (s || (c.transition = `all ${this.transitionDuration} linear`), c[e.padding.property] = `${r}px`, c[e.margin.property] = `${l}px`, a.style(n, c), !!t) {
        if (s) {
          a.style(n, { transition: this._initialContentStyle[o].transition });
          return;
        }
        h.on(n, "transitionend", () => {
          a.style(n, { transition: this._initialContentStyle[o].transition });
        });
      }
    });
  }
  _setMode(t) {
    this.options.mode !== t && (this._options.mode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t ? (this._collapseItems(), a.addClass(this._element, "sidenav-slim")) : a.removeClass(this._element, "sidenav-slim"), this._slimCollapsed = t, this._toggleSlimDisplay(t), a.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 1 : -1;
    });
  }
  _setVisibility(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [s] = u.children(t, `.${yn}`);
    s && a.style(s, {
      transform: `rotate(${e}deg)`
    });
  }
  async _toggleBackdrop(t) {
    t && this.options.mode === "over" ? this._appendBackdrop() : (a.style(this._backdrop, { opacity: 0 }), await setTimeout(() => {
      this._removeBackdrop();
    }, this.options.transitionDuration));
  }
  _removeBackdrop() {
    this._backdrop.parentNode === this.container && this.container.removeChild(this._backdrop);
  }
  _appendBackdrop() {
    this.container.appendChild(this._backdrop), setTimeout(() => a.style(this._backdrop, { opacity: 1 }), 0);
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.expandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = u.find(Nb, this._element), s = u.find(Lb, this._element), n = () => {
      e.forEach((o) => {
        a.style(o, { display: this._slimCollapsed ? "unset" : "none" });
      }), s.forEach((o) => {
        a.style(o, { display: this._slimCollapsed ? "none" : "unset" });
      });
    };
    t ? setTimeout(() => n(), this.options.transitionDuration) : n();
  }
  async _triggerEvents(t, e) {
    h.trigger(this._element, `${t}.mdb.sidenav`), e && await setTimeout(() => {
      h.trigger(this._element, `${e}.mdb.sidenav`);
    }, this.options.transitionDuration + 5);
  }
  _update(t) {
    this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.backdrop && this._toggleBackdrop(t), this._updateOffsets(t), t && this.options.closeOnEsc && this.options.mode !== "side" && h.on(window, "keydown", this.escHandler), this.options.focusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    a.style(this._element, { transform: `translateX(${e}%)` });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.mode === "over" && this.options.focusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [s, n] = this.options.right && !B || !this.options.right && B ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", s),
      value: this.options.mode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.mode === "push" ? -1 * this.width : 0
    };
    h.trigger(this._element, "update.mdb.sidenav", { margin: r, padding: o }), this._content && this._setContentOffsets(t, { padding: o, margin: r }, e);
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = u.closest(t.target, Na), s = a.getDataAttributes(e).target;
      u.find(s).forEach((n) => {
        (Ts.getInstance(n) || new Ts(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Da);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Ts(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Pb = "alert", Hb = "bs.alert", Gh = `.${Hb}`, Bb = `close${Gh}`, Vb = `closed${Gh}`, Wb = "fade", Yb = "show";
let Fb = class qh extends Nt {
  // Getters
  static get NAME() {
    return Pb;
  }
  // Public
  close() {
    if (A.trigger(this._element, Bb).defaultPrevented)
      return;
    this._element.classList.remove(Yb);
    const e = this._element.classList.contains(Wb);
    this._queueCallback(() => this._destroyElement(), this._element, e);
  }
  // Private
  _destroyElement() {
    this._element.remove(), A.trigger(this._element, Vb), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = qh.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
};
const Kb = "Stack", zb = {
  position: "top",
  container: null,
  refresh: 1e3,
  filter: (i) => i
}, Xb = {
  position: "string",
  container: "(undefined|null|string)",
  refresh: "number",
  filter: "function"
};
class Qh {
  constructor(t, e, s) {
    this._element = t, this._selector = e, this._options = this._getConfig(s), this._offset = null, this._options.container && (this._parent = u.findOne(this._options.container));
  }
  get stackableElements() {
    return u.find(this._selector).filter((t, e) => this._options.filter(t, e)).map((t) => ({ el: t, rect: t.getBoundingClientRect() })).filter(({ el: t, rect: e }) => {
      const s = t !== this._element && Kt(t);
      return this._offset === null ? s : s && this._getBoundryOffset(e) < this._offset;
    }).sort((t, e) => this._getBoundryOffset(e.rect) - this._getBoundryOffset(t.rect));
  }
  get nextElements() {
    return u.find(this._selector).filter((t) => t !== this._element).filter((t, e) => this._options.filter(t, e)).filter((t) => (this._offset = null, this._getBoundryOffset(t.getBoundingClientRect()) > this._offset));
  }
  _getConfig(t) {
    const e = {
      ...zb,
      ...t
    };
    return Y(Kb, e, Xb), e;
  }
  _getBoundryOffset(t) {
    const { position: e } = this._options;
    let s = 0, n = window.innerHeight;
    if (this._parent) {
      const o = this._parent.getBoundingClientRect();
      s = o.top, n = o.bottom;
    }
    return e === "top" ? t.top - s : n - t.bottom;
  }
  calculateOffset() {
    const [t] = this.stackableElements;
    return t ? this._offset = this._getBoundryOffset(t.rect) + t.rect.height : this._offset = 0, this._offset;
  }
}
const Ia = "alert", jb = ".alert", Ub = {
  position: "(string || null)",
  delay: "number",
  autohide: "boolean",
  width: "(string || null)",
  offset: "number",
  stacking: "boolean",
  hidden: "boolean",
  appendToBody: "boolean",
  color: "(string || null)",
  container: "(string|null)"
}, Gb = {
  position: null,
  delay: 1e3,
  autohide: !1,
  width: null,
  offset: 10,
  stacking: !1,
  hidden: !1,
  appendToBody: !1,
  color: null,
  container: null
}, qb = "close.bs.alert", Qb = "closed.bs.alert", Zb = [{ name: "close" }, { name: "closed" }];
class lo extends Fb {
  constructor(t, e = {}) {
    super(t, e), this._options = this._getConfig(e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    h.off(this._element, qb), h.off(this._element, Qb), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Getters
  get verticalOffset() {
    return this._options.stacking ? this.stackUtil.calculateOffset() : 0;
  }
  get parent() {
    const [t] = u.parents(this._element, this._options.container);
    return t;
  }
  get position() {
    const [t, e] = this._options.position.split("-");
    return { y: t, x: e };
  }
  // Public
  update(t = {}) {
    this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), this._options = this._getConfig(t), this._setup();
  }
  hide() {
    if (this._element && this._element.classList.contains("show")) {
      a.toggleClass(this._element, "show");
      const t = (e) => {
        a.style(e.target, {
          display: "none"
        }), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), this._options.stacking && this._updateAlertStack(), h.off(e.target, "transitionend", t);
      };
      h.on(this._element, "transitionend", t);
    }
  }
  show() {
    if (this._options.autohide && this._setupAutohide(), !this._element.classList.contains("show") && (a.style(this._element, {
      display: "block"
    }), Kt(this._element))) {
      const t = (e) => {
        a.style(e.target, {
          display: "block"
        }), h.off(e.target, "transitionend", t);
      };
      a.toggleClass(this._element, "show"), this._options.position && this._setupAlignment(), h.on(this._element, "transitionend", t);
    }
  }
  // Private
  _init() {
    this._options.hidden && a.style(this._element, {
      display: "none"
    }), this._bindMdbEvents(), this._setup();
  }
  _setup() {
    this._options.color && this._setColor(), this._options.stacking && this._setupStacking(), this._options.autohide && this._setupAutohide(), this._options.width && this._setupWidth(), this._options.appendToBody && this._appendToBody(), this._options.position && (this._setupAlignment(), this._setupPosition());
  }
  _setupStacking() {
    this.stackUtil = new Qh(this._element, jb, {
      position: this.position.y,
      offset: this._options.offset,
      container: this._options.container,
      filter: (t) => {
        const e = lo.getInstance(t);
        return e ? e._options.container === this._options.container && e._options.position === this._options.position : !1;
      }
    }), h.on(this._element, "closed.bs.alert", () => {
      this._updateAlertStack();
    });
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], e = t.includes(this._options.color) ? this._options.color : "primary";
    t.forEach((s) => {
      this._element.classList.remove(`alert-${s}`);
    }), a.addClass(this._element, `alert-${e}`);
  }
  _setupWidth() {
    a.style(this._element, {
      width: this._options.width
    });
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._options.delay);
  }
  _setupAlignment() {
    const t = this.position.y === "top" ? "bottom" : "top", e = this.position.x === "left" ? "right" : "left";
    this.position.x === "center" ? a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._options.offset}px`,
      [t]: "unset",
      left: "50%",
      transform: "translate(-50%)"
    }) : a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._options.offset}px`,
      [this.position.x]: `${this._options.offset}px`,
      [t]: "unset",
      [e]: "unset",
      transform: "unset"
    });
  }
  _setupPosition() {
    this._options.container ? (a.addClass(this.parent, "parent-alert-relative"), a.addClass(this._element, "alert-absolute")) : a.addClass(this._element, "alert-fixed");
  }
  _appendToBody() {
    this._element.parentNode.removeChild(this._element), document.body.appendChild(this._element);
  }
  _getConfig(t) {
    const e = {
      ...Gb,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(Ia, e, Ub), e;
  }
  _bindMdbEvents() {
    h.extend(this._element, Zb, Ia);
  }
  _updatePosition() {
    a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._options.offset}px`
    });
  }
  _updateAlertStack() {
    this.stackUtil.nextElements.forEach((t) => {
      const e = lo.getInstance(t);
      e && e._updatePosition();
    });
  }
}
const Jb = "toast", tv = "bs.toast", le = `.${tv}`, ev = `mouseover${le}`, iv = `mouseout${le}`, sv = `focusin${le}`, nv = `focusout${le}`, ov = `hide${le}`, rv = `hidden${le}`, av = `show${le}`, lv = `shown${le}`, cv = "fade", ka = "hide", Zi = "show", Ji = "showing", hv = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, dv = {
  animation: !0,
  autohide: !0,
  delay: 5e3
};
let uv = class Zh extends Nt {
  constructor(t, e) {
    super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
  }
  // Getters
  static get Default() {
    return dv;
  }
  static get DefaultType() {
    return hv;
  }
  static get NAME() {
    return Jb;
  }
  // Public
  show() {
    if (A.trigger(this._element, av).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && this._element.classList.add(cv);
    const e = () => {
      this._element.classList.remove(Ji), A.trigger(this._element, lv), this._maybeScheduleHide();
    };
    this._element.classList.remove(ka), Oi(this._element), this._element.classList.add(Zi, Ji), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown() || A.trigger(this._element, ov).defaultPrevented)
      return;
    const e = () => {
      this._element.classList.add(ka), this._element.classList.remove(Ji, Zi), A.trigger(this._element, rv);
    };
    this._element.classList.add(Ji), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this.isShown() && this._element.classList.remove(Zi), super.dispose();
  }
  isShown() {
    return this._element.classList.contains(Zi);
  }
  // Private
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = e;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = e;
        break;
      }
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const s = t.relatedTarget;
    this._element === s || this._element.contains(s) || this._maybeScheduleHide();
  }
  _setListeners() {
    A.on(this._element, ev, (t) => this._onInteraction(t, !0)), A.on(this._element, iv, (t) => this._onInteraction(t, !1)), A.on(this._element, sv, (t) => this._onInteraction(t, !0)), A.on(this._element, nv, (t) => this._onInteraction(t, !1));
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Zh.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
};
const Ma = "toast", pv = ".toast", _v = ".toast-header", xa = "show.bs.toast", fv = "shown.bs.toast", mv = "hide.bs.toast", Ra = "hidden.bs.toast", gv = "show.mdb.toast", bv = "hidden.mdb.toast", vv = [{ name: "shown" }, { name: "hide" }], Ev = {
  position: "(string|null)",
  animation: "boolean",
  autohide: "boolean",
  width: "(string || null)",
  color: "(string|null)",
  delay: "(boolean|number)",
  offset: "number",
  appendToBody: "boolean",
  stacking: "boolean"
}, Tv = {
  position: null,
  animation: !0,
  autohide: !0,
  width: null,
  color: null,
  delay: 500,
  offset: 10,
  appendToBody: !1,
  stacking: !0
};
class vi extends uv {
  constructor(t, e = {}) {
    super(t, e), this._config = this._getConfig(e), this._setup(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  get parent() {
    const [t] = u.parents(this._element, this._config.container);
    return t;
  }
  get position() {
    if (!this._config.position)
      return null;
    const [t, e] = this._config.position.split("-");
    return { y: t, x: e };
  }
  get verticalOffset() {
    return !this._config.stacking || !this.position ? 0 : this.stackUtil.calculateOffset();
  }
  // Public
  update(t = {}) {
    this._config = this._getConfig(t), this._setupColor(), this._config.position && (this._config.stacking && (this._setupStacking(), h.on(this._element, "hidden.bs.toast", () => {
      setTimeout(() => this._updateToastStack(), 150);
    })), this._setupPosition(), this._setupAlignment());
  }
  dispose() {
    h.off(this._element, xa), h.off(this._element, fv), h.off(this._element, mv), h.off(this._element, Ra), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _setup() {
    this._setupColor(), this._config.width && this._setupWidth(), this._config.position && (this._config.stacking && (this._setupStacking(), h.on(this._element, "hidden.bs.toast", () => {
      setTimeout(() => this._updateToastStack(), 150);
    })), this._setupPosition(), this._setupDisplay(), !this._config.container && this._config.appendToBody && this._appendToBody(), this._bindMdbEvents());
  }
  _setupStacking() {
    this.stackUtil = new Qh(this._element, pv, {
      position: this.position.y,
      offset: this._config.offset,
      container: this._config.container,
      filter: (t) => {
        const e = vi.getInstance(t);
        return e ? e._config.container === this._config.container && e._config.position === this._config.position : !1;
      }
    }), h.on(this._element, "closed.bs.alert", () => {
      this._updateAlertStack();
    });
  }
  _setupColor() {
    if (!this._config.color)
      return;
    const t = u.findOne(_v, this._element), e = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], s = e.includes(this._config.color) ? this._config.color : "primary";
    e.forEach((n) => {
      this._element.classList.remove(`toast-${n}`), t && t.classList.remove(`toast-${n}`);
    }), a.addClass(this._element, `toast-${s}`), t && a.addClass(t, `toast-${s}`);
  }
  _setupWidth() {
    a.style(this._element, {
      width: this._config.width
    });
  }
  _setupPosition() {
    this._config.container ? (a.addClass(this.parent, "parent-toast-relative"), a.addClass(this._element, "toast-absolute")) : a.addClass(this._element, "toast-fixed");
  }
  _setupAlignment() {
    const t = this.position.y === "top" ? "bottom" : "top", e = this.position.x === "left" ? "right" : "left";
    this.position.x === "center" ? a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._config.offset}px`,
      [t]: "unset",
      left: "50%",
      transform: "translate(-50%)"
    }) : a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._config.offset}px`,
      [this.position.x]: `${this._config.offset}px`,
      [t]: "unset",
      [e]: "unset",
      transform: "unset"
    });
  }
  _setupDisplay() {
    this._element.classList.contains("show") || a.style(this._element, {
      display: "none"
    }), h.on(this._element, Ra, () => {
      h.trigger(this._element, bv), a.style(this._element, {
        display: "none"
      });
    }), h.on(this._element, xa, () => {
      h.trigger(this._element, gv).defaultPrevented || (this._setupAlignment(), a.style(this._element, {
        display: "block"
      }));
    });
  }
  _bindMdbEvents() {
    h.extend(this._element, vv, Ma);
  }
  _getConfig(t) {
    const e = {
      ...Tv,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(Ma, e, Ev), e;
  }
  _appendToBody() {
    this._element.parentNode.removeChild(this._element), document.body.appendChild(this._element);
  }
  _updatePosition() {
    a.style(this._element, {
      [this.position.y]: `${this.verticalOffset + this._config.offset}px`
    });
  }
  _updateToastStack() {
    this.stackUtil.nextElements.forEach((t) => {
      const e = vi.getInstance(t);
      e && e._updatePosition();
    });
  }
  // Static
  static jQueryInterface(t, e = {}) {
    return this.each(function() {
      let s;
      if (typeof t == "object" ? s = new vi(this, t) : s = vi.getOrCreateInstance(this, t), typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Cv = ({
  format24: i,
  okLabel: t,
  cancelLabel: e,
  headId: s,
  footerId: n,
  bodyId: o,
  pickerId: r,
  clearLabel: l,
  inline: c,
  showClearBtn: d,
  amLabel: p,
  pmLabel: f
}) => {
  const m = `<div id='${r}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column position-fixed'>
               <div class="d-flex align-items-center justify-content-center flex-column timepicker-container">
                  <div class="d-flex flex-column timepicker-elements justify-content-around">
                  <div id='${s}' class='timepicker-head d-flex flex-row align-items-center justify-content-center'
                  style='padding-right:${i ? 50 : 0}px'>
                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly'>
                      <div class="timepicker-current-wrapper">
                        <span class="position-relative h-100">
                          <button type='button' class='timepicker-current timepicker-hour active ripple' tabindex="0">21</button>
                        </span>
                        <button type='button' class='timepicker-dot' disabled>:</button>
                      <span class="position-relative h-100">
                        <button type='button' class='timepicker-current timepicker-minute ripple' tabindex="0">21</button>
                      </span>
                      </div>
                      ${i ? "" : `<div class="d-flex flex-column justify-content-center timepicker-mode-wrapper">
                              <button type='button' class="timepicker-hour-mode timepicker-am ripple" tabindex="0">${p}</button>
                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">${f}</button>
                            </div>`}
                  </div>
                </div>
                ${c ? "" : `<div id='${o}' class='timepicker-clock-wrapper d-flex justify-content-center flex-column align-items-center'>
                        <div class='timepicker-clock'>
                          <span class='timepicker-middle-dot position-absolute'></span>
                          <div class='timepicker-hand-pointer position-absolute'>
                            <div class='timepicker-circle position-absolute'></div>
                          </div>
                          ${i ? '<div class="timepicker-clock-inner"></div>' : ""}
                         </div>
                      </div>`}

              </div>
                <div id='${n}' class='timepicker-footer'>
                  <div class="w-100 d-flex justify-content-between">
                    ${d ? `<button type='button' class='timepicker-button timepicker-clear ripple' tabindex="0">${l}</button>` : ""}
                    <button type='button' class='timepicker-button timepicker-cancel ripple' tabindex="0">${e}</button>
                    <button type='button' class='timepicker-button timepicker-submit ripple' tabindex="0">${t}</button>
                  </div>
                </div>
              </div>
        </div>`, g = `<div id='${r}' class='timepicker-wrapper h-100 d-flex align-items-center justify-content-center flex-column timepicker-wrapper-inline'>
               <div class="d-flex align-items-center justify-content-center flex-column timepicker-container">
                  <div class="d-flex flex-column timepicker-elements justify-content-around timepicker-elements-inline">
                  <div id='${s}' class='timepicker-head d-flex flex-row align-items-center justify-content-center timepicker-head-inline'
                  style='padding-right:0px'>
                  <div class='timepicker-head-content d-flex w-100 justify-content-evenly align-items-center'>
                      <div class="timepicker-current-wrapper">
                        <span class="position-relative h-100 timepicker-inline-hour-icons">
                          <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-hour"></i>
                          <button type='button' class='timepicker-current timepicker-hour active ripple timepicker-current-inline' tabindex="0">21</button>
                          <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-hour"></i>
                        </span>
                        <button type='button' class='timepicker-dot timepicker-current-inline' disabled>:</button>
                      <span class="position-relative h-100  timepicker-inline-minutes-icons">
                        <i class="fas fa-chevron-up position-absolute text-white timepicker-icon-up timepicker-icon-inline-minute"></i>
                        <button type='button' class='timepicker-current timepicker-minute ripple timepicker-current-inline' tabindex="0">21</button>
                        <i class="fas fa-chevron-down position-absolute text-white timepicker-icon-down timepicker-icon-inline-minute"></i>
                      </span>
                      </div>
                      ${i ? "" : `<div class="d-flex justify-content-center timepicker-mode-wrapper">
                              <button type='button' class="timepicker-hour-mode timepicker-am ripple me-2 ms-4" tabindex="0">${p}</button>
                              <button class="timepicker-hour-mode timepicker-pm ripple" tabindex="0">${f}</button>
                              <button type='button' class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex="0">${t}</button>
                            </div>`}
                      ${i ? `<button class='timepicker-button timepicker-submit timepicker-submit-inline ripple py-1 px-2 mb-0' tabindex="0">${t}</button>` : ""}
                  </div>
                </div>
              </div>
           </div>
        </div>
  `;
  return c ? g : m;
}, yv = (i, t) => {
  const { iconClass: e } = i;
  return `
  <button id="${t}" tabindex="0" type="button" class="timepicker-toggle-button" data-mdb-toggle="timepicker"  >
    <i class="${e}"></i>
  </button>
`;
}, se = (i) => {
  if (i === "")
    return;
  let t, e, s, n;
  return Jh(i) ? (t = i.getHours(), n = t, e = i.getMinutes(), t %= 12, t === 0 ? s = "AM" : t > 12 && (s = "PM"), t = t || 12, s === void 0 && (s = t >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, s] = W(i, !1), n = t, t %= 12, t === 0 && s === void 0 && (s = "AM"), t = t || 12, s === void 0 && (s = n >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: s
  };
}, Jh = (i) => i && Object.prototype.toString.call(i) === "[object Date]" && !isNaN(i), An = (i) => {
  if (i === "")
    return;
  let t, e;
  return Jh(i) ? (t = i.getHours(), e = i.getMinutes()) : [t, e] = W(i, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, Av = (i, t) => h.on(document, i, t, ({ target: e }) => {
  a.hasClass(e, "active") || (document.querySelectorAll(t).forEach((n) => {
    a.hasClass(n, "active") && a.removeClass(n, "active");
  }), a.addClass(e, "active"));
}), Pa = ({ clientX: i, clientY: t, touches: e }, s, n = !1) => {
  const { left: o, top: r } = s.getBoundingClientRect();
  let l = {};
  return !n || !e ? l = {
    x: i - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (l = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), l;
}, ts = () => {
  let i = !1;
  return (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) && (i = !0), i;
}, W = (i, t = !0) => {
  let e;
  return t ? e = i.value.replace(/:/gi, " ") : e = i.replace(/:/gi, " "), e.split(" ");
}, td = (i, t) => {
  const [e, s, n] = W(i, !1), [o, r, l] = W(t, !1), c = n == l;
  if (n == "PM" && l == "AM")
    return 1;
  if (n == "AM" && l == "PM")
    return 2;
  if (c && e > o)
    return 1;
  if (e < o)
    return 2;
  if (s > r)
    return 1;
  if (s < r)
    return 2;
}, ed = () => {
  const i = /* @__PURE__ */ new Date(), t = i.getHours();
  let e = String(i.getMinutes());
  return e.length === 1 && (e = `0${e}`), `${t}:${e}`;
}, Zt = (i, t, e) => {
  if (!t)
    return i;
  let s = ed();
  return e && (s = `${se(s).hours}:${se(s).minutes} ${se(s).amOrPm}`), (i != "" && td(s, i) == 1 || i === "") && (i = s), i;
}, Jt = (i, t, e) => {
  if (!t)
    return i;
  let s = ed();
  return e && (s = `${se(s).hours}:${se(s).minutes} ${se(s).amOrPm}`), (i != "" && td(s, i) == 2 || i === "") && (i = s), i;
}, Sv = ({ format12: i, maxTime: t, minTime: e, disablePast: s, disableFuture: n }, o, r, l) => {
  const c = W(o)[1];
  e = Zt(e, s, i), t = Jt(t, n, i);
  const [d, p, f] = W(t, !1), [m, g, _] = W(e, !1);
  if (f === void 0 && _ === void 0) {
    if (f === void 0) {
      if (d !== "" && m === "") {
        if (Number(r) > Number(d) || p !== "" && g === void 0 && Number(r) > Number(d))
          return;
      } else if (d === "" && m !== "" && p === void 0 && g !== "" && (Number(r) < Number(m) || Number(r) < Number(m) && l < Number(g)))
        return;
    } else if (_ === void 0) {
      if (d !== "" && m === "") {
        if (Number(r) > Number(d) || p !== "" && g === void 0 && (Number(r) > Number(d) || l > Number(p)))
          return;
      } else if (d === "" && m !== "" && p === void 0 && g !== "" && (Number(r) < Number(m) || l < Number(g)))
        return;
    }
  }
  return [r, c];
}, Ha = (i, t) => {
  i.forEach((e) => {
    (e.textContent === "00" || Number(e.textContent) > t) && a.addClass(e, "disabled");
  });
}, Ba = (i, t) => {
  i.forEach((e) => {
    e.textContent !== "00" && Number(e.textContent) < t && a.addClass(e, "disabled");
  });
}, wv = (i, t, e, s) => {
  i.forEach((n) => {
    Number(n.textContent) > t && Number(s) == e && a.addClass(n, "disabled");
  });
}, Ov = (i, t, e, s) => {
  i.forEach((n) => {
    Number(n.textContent) < t && Number(s) == e && a.addClass(n, "disabled");
  });
}, $v = (i) => {
  let t;
  return i.startsWith("0") ? t = Number(i.slice(1)) : t = Number(i), t;
}, H = "timepicker", id = `mdb.${H}`, Lt = `.${id}`, Vt = ".data-api", Va = `click${Lt}${Vt}`, es = `keydown${Lt}${Vt}`, Wa = `mousedown${Lt}${Vt}`, Ya = `mouseup${Lt}${Vt}`, Fa = `mousemove${Lt}${Vt}`, Ka = `mouseleave${Lt}${Vt}`, za = `mouseover${Lt}${Vt}`, Xa = `touchmove${Lt}${Vt}`, ja = `touchend${Lt}${Vt}`, Ua = `touchstart${Lt}${Vt}`, Dv = `valueChanged${Lt}`, j = "active", Nv = `${H}-am`, Sn = `${H}-cancel`, Ga = `${H}-clear`, qa = `${H}-submit`, wn = `${H}-circle`, Lv = `${H}-clock-animation`, ue = `${H}-clock`, is = `${H}-clock-inner`, Qa = `${H}-clock-wrapper`, On = `.${H}-current`, Iv = `${H}-current-inline`, kv = "fade-in", Mv = "fade-out", $n = `${H}-hand-pointer`, ss = `${H}-hour`, ns = `${H}-hour-mode`, Za = `${H}-icon-down`, xv = `${H}-icon-inline-hour`, Rv = `${H}-icon-inline-minute`, Ja = `${H}-icon-up`, tl = `${H}-inline-hour-icons`, el = `${H}-middle-dot`, il = `${H}-minute`, sl = `${H}-modal`, Pv = `${H}-pm`, Dn = `${H}-tips-element`, et = `${H}-time-tips-hours`, nl = `${H}-tips-inner-element`, Tt = `${H}-time-tips-inner`, it = `${H}-time-tips-minutes`, Nn = `${H}-transform`, Ln = `${H}-wrapper`, Hv = `${H}-input`, Bv = {
  bodyId: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  focusInputAfterApprove: !1,
  footerId: "",
  format12: !0,
  format24: !1,
  headId: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalId: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerId: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconClass: "far fa-clock fa-sm timepicker-icon",
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, Vv = {
  bodyId: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  footerId: "string",
  format12: "boolean",
  format24: "boolean",
  headId: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalId: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerId: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconClass: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
};
class Ko extends F {
  constructor(e, s = {}) {
    super(e);
    It(this, "_toggleAmPm", (e) => {
      e == "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : e == "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    It(this, "_toggleBackgroundColorCircle", (e) => {
      if (this._modal.querySelector(`.${e}.${j}`) !== null) {
        a.addClass(this._circle, "active");
        return;
      }
      a.removeClass(this._circle, "active");
    });
    It(this, "_toggleClassActive", (e, { textContent: s }, n) => {
      const o = [...e].find((r) => Number(r) === Number(s));
      return n.forEach((r) => {
        a.hasClass(r, "disabled") || (r.textContent === o ? a.addClass(r, j) : a.removeClass(r, j));
      });
    });
    It(this, "_makeMinutesDegrees", (e, s) => {
      const { increment: n } = this._options;
      return e < 0 ? (s = Math.round(360 + e / 6) % 60, e = 360 + Math.round(e / 6) * 6) : (s = Math.round(e / 6) % 60, e = Math.round(e / 6) * 6), n && (e = Math.round(e / 30) * 30, s = Math.round(e / 6) * 6 / 6, s === 60 && (s = "00")), e >= 360 && (e = 0), {
        degrees: e,
        minute: s,
        addDegrees: n ? 30 : 6
      };
    });
    It(this, "_makeHourDegrees", (e, s, n) => {
      if (e)
        return this._hasTargetInnerClass(e) ? s < 0 ? (n = Math.round(360 + s / 30) % 24, s = 360 + s) : (n = Math.round(s / 30) + 12, n === 12 && (n = "00")) : s < 0 ? (n = Math.round(360 + s / 30) % 12, s = 360 + s) : (n = Math.round(s / 30) % 12, (n === 0 || n > 12) && (n = 12)), s >= 360 && (s = 0), {
          degrees: s,
          hour: n,
          addDegrees: 30
        };
    });
    It(this, "_makeInnerHoursDegrees", (e, s) => (e < 0 ? (s = Math.round(360 + e / 30) % 24, e = 360 + e) : (s = Math.round(e / 30) + 12, s === 12 && (s = "00")), {
      degrees: e,
      hour: s,
      addDegrees: 30
    }));
    It(this, "_getAppendClock", (e = [], s = `.${ue}`, n) => {
      let { minTime: o, maxTime: r } = this._options;
      const { inline: l, format12: c, disablePast: d, disableFuture: p } = this._options;
      o = Zt(o, d, c), r = Jt(r, p, c);
      const [f, m, g] = W(r, !1), [_, b, C] = W(o, !1);
      l || c && this._isInvalidTimeFormat && !a.hasClass(this._AM, "active") && a.addClass(this._PM, "active");
      const v = u.findOne(s), T = 360 / e.length;
      function E(D) {
        return D * (Math.PI / 180);
      }
      if (v === null)
        return;
      const y = (v.offsetWidth - 32) / 2, S = (v.offsetHeight - 32) / 2, w = y - 4;
      setTimeout(() => {
        let D;
        c && (D = u.findOne(`.${ns}.${j}`).textContent), this._handleDisablingTipsMinTime(D, C, b, _), this._handleDisablingTipsMaxTime(D, g, m, f);
      }, 0), [...e].forEach((D, L) => {
        const $ = E(L * T), N = O("span"), I = O("span");
        I.innerHTML = D, a.addClass(N, n);
        const k = N.offsetWidth, x = N.offsetHeight;
        return a.addStyle(N, {
          left: `${y + Math.sin($) * w - k}px`,
          bottom: `${S + Math.cos($) * w - x}px`
        }), e.includes("05") && a.addClass(N, `${it}`), e.includes("13") ? I.classList.add(nl) : I.classList.add(Dn), N.appendChild(I), v.appendChild(N);
      });
    });
    this._document = document, this._options = this._getConfig(s), this._currentTime = null, this._toggleButtonId = this._element.id ? `timepicker-toggle-${this._element.id}` : Ot("timepicker-toggle-"), this.hoursArray = ["12", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"], this.innerHours = ["00", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"], this.minutesArray = ["00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"], this.input = u.findOne("input", this._element), this.dataWithIcon = e.dataset.withIcon, this.dataToggle = e.dataset.toggle, this.customIcon = u.findOne(".timepicker-toggle-button", this._element), this._checkToggleButton(), this.inputFormatShow = u.findOne("[data-mdb-timepicker-format24]", this._element), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = u.findOne("[data-mdb-toggle]", this._element), this.toggleElement = Object.values(e.querySelector("[data-mdb-toggle]").dataset)[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = An(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = se(this._inputValue)), this._options.readOnly && this.input.setAttribute("readonly", !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = An(this._inputValue)), this._scrollBar = new Ze(), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return H;
  }
  // Public
  init() {
    const { format12: e, format24: s } = this._options;
    let n, o, r;
    if (a.addClass(this.input, Hv), this._currentTime !== void 0) {
      const { hours: l, minutes: c, amOrPm: d } = this._currentTime;
      n = Number(l) < 10 ? 0 : "", o = `${n}${Number(l)}:${c}`, r = d, e ? this.input.value = `${o} ${r}` : s && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && a.addClass(this.input, "active"), (this._options !== null || this._element !== null) && (this._listenToUserInput(), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), h.off(this._document, "click", `[data-mdb-toggle='${this.toggleElement}']`), h.off(this._element, "keydown", `[data-mdb-toggle='${this.toggleElement}']`), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), setTimeout(() => {
      super.dispose();
    }, 350 + 5);
  }
  update(e = {}) {
    this._options = this._getConfig({ ...this._options, ...e });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const e = yv(this._options, this._toggleButtonId);
    this.input.insertAdjacentHTML("afterend", e);
  }
  _getDomElements() {
    this._hour = u.findOne(`.${ss}`), this._minutes = u.findOne(`.${il}`), this._AM = u.findOne(`.${Nv}`), this._PM = u.findOne(`.${Pv}`), this._wrapper = u.findOne(`.${Ln}`), this._modal = u.findOne(`.${sl}`), this._hand = u.findOne(`.${$n}`), this._circle = u.findOne(`.${wn}`), this._clock = u.findOne(`.${ue}`), this._clockInner = u.findOne(`.${is}`);
  }
  _handlerMaxMinHoursOptions(e, s, n, o, r, l) {
    if (!s && !n)
      return !0;
    const { format24: c, format12: d, disablePast: p, disableFuture: f } = this._options, { _isAmEnabled: m, _isPmEnabled: g } = this, _ = l.keyCode, b = l.target.classList.contains("timepicker-clock-inner") || l.target.classList.contains("timepicker-time-tips-inner") || l.target.classList.contains("timepicker-tips-inner-element");
    n = Zt(n, p, d), s = Jt(s, f, d);
    let C = s !== "" ? s * 30 : "", v = n !== "" ? n * 30 : "";
    e <= 0 && (e = 360 + e);
    const T = () => {
      const L = document.querySelectorAll(".timepicker-tips-element"), $ = document.querySelectorAll(".timepicker-tips-inner-element");
      let N = $v(this._hour.innerText), I, k, x;
      return _ === tt ? k = 1 : _ === J && (k = -1), N === 12 && _ === tt ? x = 1 : N === 0 && _ === tt ? x = 13 : N === 0 && _ === J ? x = 23 : N === 13 && _ === J ? x = 0 : N === 1 && _ === J ? x = 12 : x = N + k, L.forEach((X) => {
        X.textContent == x && (I = X);
      }), $.forEach((X) => {
        X.textContent == x && (I = X);
      }), !I.parentElement.classList.contains("disabled");
    }, E = (L) => {
      let $ = n !== "" && n > 12 ? (n - 12) * 30 : "", N = s !== "" && s > 12 ? (s - 12) * 30 : "";
      if (!($ && e < $ || N && e > N || s && s < 12))
        return !0;
    };
    if (c && l.type !== "keydown" && b)
      return E();
    if (l.type === "keydown")
      return T();
    const y = !r || r === "PM" && g || n !== "" && r === "AM" && m, S = !o || o === "PM" && g || s !== "" && o === "AM" && m, w = () => {
      if (n) {
        if (r === "PM" && m || y && e < v)
          return;
      } else
        return !0;
      return !0;
    }, D = () => {
      if (s) {
        if (o === "AM" && g || S && e > C)
          return;
      } else
        return !0;
      return !0;
    };
    if (w() && D())
      return !0;
  }
  _handleKeyboard() {
    h.on(this._document, es, "", (e) => {
      let s, n, o, { increment: r, maxTime: l, minTime: c, format12: d, disablePast: p, disableFuture: f } = this._options, [m, g] = W(c, !1), [_, b] = W(l, !1);
      m = Zt(m, p, d), _ = Jt(_, f, d);
      const C = u.findOne(`.${it}`) === null, v = u.findOne(`.${Tt}`) !== null, T = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), E = u.find(`.${it}`, this._modal), y = u.find(`.${et}`, this._modal), S = u.find(`.${Tt}`, this._modal);
      let w = this._makeHourDegrees(e.target, T, s).hour;
      const { degrees: D, addDegrees: L } = this._makeHourDegrees(
        e.target,
        T,
        s
      );
      let { minute: $, degrees: N } = this._makeMinutesDegrees(
        T,
        n
      );
      const I = this._makeMinutesDegrees(T, n).addDegrees;
      let { hour: k } = this._makeInnerHoursDegrees(T, o);
      if (e.keyCode === Ae) {
        const x = u.findOne(`.${Sn}`, this._modal);
        h.trigger(x, "click");
      } else if (C) {
        if (v && (e.keyCode === Ge && (this._isInner = !1, a.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(w > 12 ? 1 : w), this._toggleClassActive(this.hoursArray, this._hour, y), this._toggleClassActive(this.innerHours, this._hour, S)), e.keyCode === Ue && (this._isInner = !0, a.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          k >= 24 || k === "00" ? 0 : k
        ), this._toggleClassActive(this.innerHours, this._hour, S), this._toggleClassActive(this.hoursArray, this._hour - 1, y))), e.keyCode === tt) {
          if (!this._handlerMaxMinHoursOptions(
            D + 30,
            _,
            m,
            b,
            g,
            e
          ))
            return;
          (() => a.addStyle(this._hand, {
            transform: `rotateZ(${D + L}deg)`
          }))(), this._isInner ? (k += 1, k === 24 ? k = 0 : (k === 25 || k === "001") && (k = 13), this._hour.textContent = this._setHourOrMinute(k), this._toggleClassActive(this.innerHours, this._hour, S)) : (w += 1, this._hour.textContent = this._setHourOrMinute(w > 12 ? 1 : w), this._toggleClassActive(this.hoursArray, this._hour, y));
        }
        if (e.keyCode === J) {
          if (!this._handlerMaxMinHoursOptions(
            D - 30,
            _,
            m,
            b,
            g,
            e
          ))
            return;
          (() => a.addStyle(this._hand, {
            transform: `rotateZ(${D - L}deg)`
          }))(), this._isInner ? (k -= 1, k === 12 ? k = 0 : k === -1 && (k = 23), this._hour.textContent = this._setHourOrMinute(k), this._toggleClassActive(this.innerHours, this._hour, S)) : (w -= 1, this._hour.textContent = this._setHourOrMinute(w === 0 ? 12 : w), this._toggleClassActive(this.hoursArray, this._hour, y));
        }
      } else
        e.keyCode === tt && (N += I, a.addStyle(this._hand, {
          transform: `rotateZ(${N}deg)`
        }), $ += 1, r && ($ += 4, $ === "0014" && ($ = 5)), this._minutes.textContent = this._setHourOrMinute(
          $ > 59 ? 0 : $
        ), this._toggleClassActive(this.minutesArray, this._minutes, E), this._toggleBackgroundColorCircle(`${it}`)), e.keyCode === J && (N -= I, a.addStyle(this._hand, {
          transform: `rotateZ(${N}deg)`
        }), r ? $ -= 5 : $ -= 1, $ === -1 ? $ = 59 : $ === -5 && ($ = 55), this._minutes.textContent = this._setHourOrMinute($), this._toggleClassActive(this.minutesArray, this._minutes, E), this._toggleBackgroundColorCircle(`${it}`));
    });
  }
  _setActiveClassToTipsOnOpen(e, ...s) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const n = u.find(`.${et}`, this._modal), o = u.find(`.${Tt}`, this._modal);
        this._addActiveClassToTip(n, e), this._addActiveClassToTip(o, e);
      } else {
        [...s].filter((o) => (o.toLowerCase() === "pm" ? a.addClass(this._PM, j) : o.toLowerCase() === "am" ? a.addClass(this._AM, j) : (a.removeClass(this._AM, j), a.removeClass(this._PM, j)), o));
        const n = u.find(`.${et}`, this._modal);
        this._addActiveClassToTip(n, e);
      }
  }
  _setTipsAndTimesDependOnInputValue(e, s) {
    const { inline: n, format12: o } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", n || a.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), o && a.addClass(this._PM, j);
    else {
      const r = e > 12 ? e * 30 - 360 : e * 30;
      this._hour.textContent = e, this._minutes.textContent = s, n || (a.addStyle(this._hand, {
        transform: `rotateZ(${r}deg)`
      }), a.addClass(this._circle, "active"), (Number(e) > 12 || e === "00") && a.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    h.on(this._element, "keydown", `[data-mdb-toggle='${this.toggleElement}']`, (e) => {
      e.keyCode === ot && (e.preventDefault(), h.trigger(this.elementToggle, "click"));
    });
  }
  _handleOpen() {
    const e = this._getContainer();
    ut.on(
      this._element,
      "click",
      `[data-mdb-toggle='${this.toggleElement}']`,
      (s) => {
        if (this._options === null)
          return;
        const n = a.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          a.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let o;
          W(this.input)[0] === "" || this._isInvalidTimeFormat ? o = ["12", "00", "PM"] : o = W(this.input);
          const { modalId: r, inline: l, format12: c } = this._options, [d, p, f] = o, m = O("div");
          if ((Number(d) > 12 || d === "00") && (this._isInner = !0), this.input.blur(), s.target.blur(), m.innerHTML = Cv(this._options), a.addClass(m, sl), m.setAttribute("role", "dialog"), m.setAttribute("tabIndex", "-1"), m.setAttribute("id", r), l ? (this._popper = ae(this.input, m, {
            placement: "bottom-start"
          }), e.appendChild(m)) : (e.appendChild(m), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : a.addClass(this._wrapper, "opacity-100"), this._setActiveClassToTipsOnOpen(d, p, f), this._appendTimes(), this._setActiveClassToTipsOnOpen(d, p, f), this._setTipsAndTimesDependOnInputValue(d, p), this.input.value === "") {
            const g = u.find(`.${et}`, this._modal);
            c && a.addClass(this._PM, j), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(g, Number(this._hour.textContent));
          }
          this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), l ? (this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks()) : (this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard(), a.addStyle(this._hour, {
            pointerEvents: "none"
          }), a.addStyle(this._minutes, {
            pointerEvents: ""
          })), this._focusTrap = new Fo(this._wrapper, {
            event: "keydown",
            condition: ({ key: g }) => g === "Tab"
          }), this._focusTrap.trap();
        }, n);
      }
    );
  }
  _handleInlineClicks() {
    let e, s;
    const n = (_) => {
      let b = _;
      return b > 59 ? b = 0 : b < 0 && (b = 59), b;
    }, o = (_) => {
      let b = _;
      return this._options.format24 ? (b > 24 ? b = 1 : b < 0 && (b = 23), b > 23 && (b = 0)) : (b > 12 ? b = 1 : b < 1 && (b = 12), b > 12 && (b = 1)), b;
    }, r = (_) => {
      const b = o(_);
      this._hour.textContent = this._setHourOrMinute(b);
    }, l = (_) => {
      const b = n(_);
      this._minutes.textContent = this._setHourOrMinute(b);
    }, c = () => {
      e = o(e) + 1, r(e);
    }, d = () => {
      s = n(s) + 1, l(s);
    }, p = () => {
      e = o(e) - 1, r(e);
    }, f = () => {
      s = n(s) - 1, l(s);
    }, m = () => {
      clearInterval(this._interval), clearTimeout(this._timeoutInterval);
    }, g = (_) => {
      m(), this._timeoutInterval = setTimeout(() => {
        this._interval = setInterval(_, 100);
      }, 500);
    };
    ut.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `.${Ja}, .${Za}`,
      (_) => {
        e = Number(this._hour.textContent), s = Number(this._minutes.textContent);
        const { target: b, type: C } = _, v = C === "mousedown" || C === "touchstart";
        a.hasClass(b, Ja) ? a.hasClass(b.parentNode, tl) ? v ? g(c) : C === "mouseup" || C === "touchend" || C === "contextmenu" ? m() : c() : v ? g(d) : C === "mouseup" || C === "touchend" || C === "contextmenu" ? m() : d() : a.hasClass(b, Za) && (a.hasClass(b.parentNode, tl) ? v ? g(p) : C === "mouseup" || C === "touchend" ? m() : p() : v ? g(f) : C === "mouseup" || C === "touchend" ? m() : f());
      }
    ), h.on(window, es, (_) => {
      const b = _.code, C = document.activeElement.classList.contains("timepicker-hour"), v = document.activeElement.classList.contains("timepicker-minute"), T = document.activeElement === document.body;
      switch (e = Number(this._hour.textContent), s = Number(this._minutes.textContent), b) {
        case "ArrowUp":
          _.preventDefault(), T || C ? (this._hour.focus(), c()) : v && d();
          break;
        case "ArrowDown":
          _.preventDefault(), T || C ? (this._hour.focus(), p()) : v && f();
          break;
      }
    });
  }
  _handleClose() {
    h.on(
      this._modal,
      "click",
      `.${Ln}, .${Sn}, .${Ga}`,
      ({ target: e }) => {
        const { closeModalOnBackdropClick: s } = this._options, n = () => {
          a.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), this._focusTrap.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (a.hasClass(e, Ga)) {
          this._toggleAmPm("PM"), this.input.value = "", a.removeClass(this.input, "active");
          let o;
          W(this.input)[0] === "" ? o = ["12", "00", "PM"] : o = W(this.input);
          const [r, l, c] = o;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(r, l, c), this._hour.click();
        } else
          (a.hasClass(e, Sn) || a.hasClass(e, Ln) && s) && n();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    ut.on(this._modal, "click", `.${qa}`, () => {
      let { maxTime: e, minTime: s } = this._options;
      const { format12: n, format24: o, readOnly: r, focusInputAfterApprove: l, disablePast: c, disableFuture: d } = this._options, p = this._document.querySelector(`.${ns}.${j}`), f = `${this._hour.textContent}:${this._minutes.textContent}`, m = Number(this._hour.textContent), g = Number(this._minutes.textContent);
      s = Zt(s, c, n), e = Jt(e, d, n);
      const [_, b, C] = W(e, !1), [v, T, E] = W(s, !1), y = m < Number(v), S = m > Number(_);
      let w = !0;
      p && (w = C === p.textContent);
      let D = !0;
      p && (D = E === p.textContent);
      const L = g > b && m === Number(_), $ = g < T && m === Number(v);
      if (a.addClass(this.input, "active"), a.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), e !== "") {
        if (w && (S || L))
          return;
        if (C === "AM" && p.textContent === "PM")
          return;
      }
      s !== "" && (D && (y || $) || E === "PM" && p.textContent === "AM") || Sv(
        this._options,
        this.input,
        this._hour.textContent,
        this._minutes.textContent
      ) !== void 0 && (this._isInvalidTimeFormat && a.removeClass(this.input, "is-invalid"), !r && l && this.input.focus(), a.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), o ? this.input.value = f : p === null ? this.input.value = `${f} PM` : this.input.value = `${f} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), h.trigger(this.input, Dv));
    });
  }
  _handleHoverInlineBtn() {
    ut.on(
      this._modal,
      "mouseover mouseleave",
      `.${Iv}`,
      ({ type: e, target: s }) => {
        const n = u.find(`.${xv}`, this._modal), o = u.find(
          `.${Rv}`,
          this._modal
        );
        e === "mouseover" ? a.hasClass(s, ss) ? n.forEach((r) => a.addClass(r, j)) : o.forEach((r) => a.addClass(r, j)) : a.hasClass(s, ss) ? n.forEach((r) => a.removeClass(r, j)) : o.forEach((r) => a.removeClass(r, j));
      }
    );
  }
  _handleDocumentClickInline() {
    h.on(document, Va, ({ target: e }) => {
      this._modal && !this._modal.contains(e) && !a.hasClass(e, "timepicker-icon") && (clearInterval(this._interval), a.addStyle(this.elementToggle, {
        pointerEvents: "auto"
      }), this._removeModal());
    });
  }
  _handleSwitchHourMinute() {
    Av("click", On), h.on(this._modal, "click", On, () => {
      const { format24: e } = this._options, s = u.find(On, this._modal), n = u.find(`.${it}`, this._modal), o = u.find(`.${et}`, this._modal), r = u.find(`.${Tt}`, this._modal), l = Number(this._hour.textContent), c = Number(this._minutes.textContent), d = (p, f) => {
        o.forEach((g) => g.remove()), n.forEach((g) => g.remove()), a.addClass(this._hand, Nn), setTimeout(() => {
          a.removeClass(this._hand, Nn);
        }, 401), this._getAppendClock(p, `.${ue}`, f);
        const m = () => {
          const g = u.find(`.${et}`, this._modal), _ = u.find(`.${it}`, this._modal);
          this._addActiveClassToTip(g, l), this._addActiveClassToTip(_, c);
        };
        if (!e)
          setTimeout(() => {
            m();
          }, 401);
        else {
          const g = u.find(`.${Tt}`, this._modal);
          setTimeout(() => {
            this._addActiveClassToTip(g, l), m();
          }, 401);
        }
      };
      s.forEach((p) => {
        a.hasClass(p, j) && (a.hasClass(p, il) ? (a.addClass(this._hand, Nn), a.addStyle(this._hand, {
          transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
          height: "calc(40% + 1px)"
        }), e && r.length > 0 && r.forEach((f) => f.remove()), d(this.minutesArray, `${it}`), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : a.hasClass(p, ss) && (a.addStyle(this._hand, {
          transform: `rotateZ(${this._hour.textContent * 30}deg)`
        }), Number(this._hour.textContent) > 12 ? (a.addStyle(this._hand, {
          transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
          height: "21.5%"
        }), Number(this._hour.textContent) > 12 && a.addStyle(this._hand, {
          height: "21.5%"
        })) : a.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), e && this._getAppendClock(
          this.innerHours,
          `.${is}`,
          Tt
        ), r.length > 0 && r.forEach((f) => f.remove()), d(this.hoursArray, `${et}`), a.addStyle(this._hour, {
          pointerEvents: "none"
        }), a.addStyle(this._minutes, {
          pointerEvents: ""
        })));
      });
    });
  }
  _handleDisablingTipsMaxTime(e, s, n, o) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const r = u.find(`.${et}`), l = u.find(`.${Tt}`), c = u.find(`.${it}`);
    if (!s || s === e) {
      Ha(l, o), Ha(r, o), wv(
        c,
        n,
        o,
        this._hour.textContent
      );
      return;
    }
    s === "AM" && e === "PM" && (r.forEach((d) => {
      a.addClass(d, "disabled");
    }), c.forEach((d) => {
      a.addClass(d, "disabled");
    }));
  }
  _handleDisablingTipsMinTime(e, s, n, o) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const r = u.find(`.${et}`), l = u.find(`.${Tt}`), c = u.find(`.${it}`);
    !s || s === e ? (Ba(r, o), Ba(l, o), Ov(
      c,
      n,
      o,
      this._hour.textContent
    )) : s === "PM" && e === "AM" && (r.forEach((d) => a.addClass(d, "disabled")), c.forEach((d) => a.addClass(d, "disabled")));
  }
  _handleSwitchTimeMode() {
    h.on(document, "click", `.${ns}`, ({ target: e }) => {
      let { maxTime: s, minTime: n } = this._options;
      const { disablePast: o, disableFuture: r, format12: l } = this._options;
      n = Zt(n, o, l), s = Jt(s, r, l);
      let [c, d, p] = W(s, !1), [f, m, g] = W(n, !1);
      const _ = u.find(`.${et}`), b = u.find(`.${it}`);
      (() => {
        _.forEach((v) => {
          a.removeClass(v, "disabled");
        }), b.forEach((v) => {
          a.removeClass(v, "disabled");
        });
      })(), this._handleDisablingTipsMinTime(
        e.textContent,
        g,
        m,
        f
      ), this._handleDisablingTipsMaxTime(
        e.textContent,
        p,
        d,
        c
      ), this._toggleAmPm(e.textContent), a.hasClass(e, j) || (u.find(`.${ns}`).forEach((T) => {
        a.hasClass(T, j) && a.removeClass(T, j);
      }), a.addClass(e, j));
    });
  }
  _handleClockClick() {
    let { maxTime: e, minTime: s } = this._options;
    const { disablePast: n, disableFuture: o, format12: r } = this._options;
    s = Zt(s, n, r), e = Jt(e, o, r);
    const l = W(e, !1)[2], c = W(s, !1)[2], d = W(e, !1)[0], p = W(s, !1)[0], f = u.findOne(`.${Qa}`);
    ut.on(
      document,
      `${Wa} ${Ya} ${Fa} ${Ka} ${za} ${Ua} ${Xa} ${ja}`,
      "",
      (m) => {
        ts() || m.preventDefault();
        const { type: g, target: _ } = m, { closeModalOnMinutesClick: b, switchHoursToMinutesOnClick: C } = this._options, v = u.findOne(`.${it}`, this._modal) !== null, T = u.findOne(`.${et}`, this._modal) !== null, E = u.findOne(`.${Tt}`, this._modal) !== null, y = u.find(`.${it}`, this._modal), S = Pa(m, f), w = f.offsetWidth / 2;
        let D = Math.atan2(S.y - w, S.x - w);
        if (ts()) {
          const I = Pa(m, f, !0);
          D = Math.atan2(I.y - w, I.x - w);
        }
        let L = null, $ = null, N = null;
        if (g === "mousedown" || g === "mousemove" || g === "touchmove" || g === "touchstart")
          (g === "mousedown" || g === "touchstart" || g === "touchmove") && (this._hasTargetInnerClass(_) || a.hasClass(_, Qa) || a.hasClass(_, ue) || a.hasClass(_, it) || a.hasClass(_, et) || a.hasClass(_, wn) || a.hasClass(_, $n) || a.hasClass(_, el) || a.hasClass(_, Dn)) && (this._isMouseMove = !0, ts() && m.touches && (L = m.touches[0].clientX, $ = m.touches[0].clientY, N = document.elementFromPoint(L, $)));
        else if (g === "mouseup" || g === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(_) || a.hasClass(_, ue) || a.hasClass(_, et) || a.hasClass(_, wn) || a.hasClass(_, $n) || a.hasClass(_, el) || a.hasClass(_, Dn)) {
            if ((T || E) && C) {
              const I = Number(this._hour.textContent) > d || Number(this._hour.textContent) < p;
              if (this._options.format24 && d != "" && p != "" && I)
                return;
              if (this._options.format24 && d != "" && this._hour.textContent > d)
                return;
              if (this._options.format24 && p != "" && this._hour.textContent < p)
                return;
            }
            a.hasClass(this._minutes, j) || h.trigger(this._minutes, "click");
          }
          if (v && b) {
            const I = u.findOne(`.${qa}`, this._modal);
            h.trigger(I, "click");
          }
        }
        if (v) {
          let I;
          const k = Math.trunc(D * 180 / Math.PI) + 90, { degrees: x, minute: X } = this._makeMinutesDegrees(
            k,
            I
          );
          if (this._handlerMaxMinMinutesOptions(x, X) === void 0)
            return;
          const { degrees: lt, minute: q } = this._handlerMaxMinMinutesOptions(
            x,
            X
          );
          if (this._isMouseMove) {
            if (a.addStyle(this._hand, {
              transform: `rotateZ(${lt}deg)`
            }), q === void 0)
              return;
            const ft = () => q >= 10 || q === "00" ? q : `0${q}`;
            this._minutes.textContent = ft(), this._toggleClassActive(this.minutesArray, this._minutes, y), this._toggleBackgroundColorCircle(`${it}`), this._objWithDataOnChange.degreesMinutes = lt, this._objWithDataOnChange.minutes = q;
          }
        }
        if (T || E) {
          let I, k = Math.trunc(D * 180 / Math.PI) + 90;
          if (k = Math.round(k / 30) * 30, a.addClass(this._circle, "active"), this._makeHourDegrees(_, k, I) === void 0)
            return;
          const x = () => {
            if (ts() && k && N) {
              const { degrees: X, hour: lt } = this._makeHourDegrees(
                N,
                k,
                I
              );
              return this._handleMoveHand(N, lt, X);
            } else {
              const { degrees: X, hour: lt } = this._makeHourDegrees(
                _,
                k,
                I
              );
              return this._handleMoveHand(_, lt, X);
            }
          };
          this._objWithDataOnChange.degreesHours = k, this._handlerMaxMinHoursOptions(
            k,
            d,
            p,
            l,
            c,
            m
          ) && x();
        }
        m.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(e) {
    return a.hasClass(e, is) || a.hasClass(e, Tt) || a.hasClass(e, nl);
  }
  _handleMoveHand(e, s, n) {
    const o = u.find(`.${et}`, this._modal), r = u.find(`.${Tt}`, this._modal);
    this._isMouseMove && (this._hasTargetInnerClass(e) ? a.addStyle(this._hand, {
      height: "21.5%"
    }) : a.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), a.addStyle(this._hand, {
      transform: `rotateZ(${n}deg)`
    }), this._hour.textContent = s >= 10 || s === "00" ? s : `0${s}`, this._toggleClassActive(this.hoursArray, this._hour, o), this._toggleClassActive(this.innerHours, this._hour, r), this._objWithDataOnChange.hour = s >= 10 || s === "00" ? s : `0${s}`);
  }
  _handlerMaxMinMinutesOptions(e, s) {
    let { maxTime: n, minTime: o } = this._options;
    const { format12: r, increment: l, disablePast: c, disableFuture: d } = this._options;
    o = Zt(o, c, r), n = Jt(n, d, r);
    const p = W(n, !1)[1], f = W(o, !1)[1], m = W(n, !1)[0], g = W(o, !1)[0], _ = W(n, !1)[2], b = W(o, !1)[2], C = p !== "" ? p * 6 : "", v = f !== "" ? f * 6 : "", T = Number(this._hour.textContent);
    if (!_ && !b) {
      if (n !== "" && o !== "") {
        if (m == T && e > C || g == T && e < v)
          return e;
      } else if (o !== "" && T <= Number(g)) {
        if (e <= v - 6)
          return e;
      } else if (n !== "" && T >= Number(m) && e >= C + 6)
        return e;
    } else {
      if (o !== "") {
        if (b === "PM" && this._isAmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (T < Number(g))
            return;
          if (T <= Number(g) && e <= v - 6)
            return e;
        } else if (b === "AM" && this._isAmEnabled) {
          if (T < Number(g))
            return;
          if (T <= Number(g) && e <= v - 6)
            return e;
        }
      }
      if (n !== "") {
        if (_ === "AM" && this._isPmEnabled)
          return;
        if (_ === "PM" && this._isPmEnabled) {
          if (T >= Number(m) && e >= C + 6)
            return e;
        } else if (_ === "AM" && this._isAmEnabled && T >= Number(m) && e >= C + 6)
          return e;
      }
    }
    return l && (e = Math.round(e / 30) * 30), e <= 0 ? e = 360 + e : e >= 360 && (e = 0), {
      degrees: e,
      minute: s
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), ut.off(
      this._document,
      `${Va} ${es} ${Wa} ${Ya} ${Fa} ${Ka} ${za} ${Ua} ${Xa} ${ja}`
    ), h.off(window, es);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(e = !1) {
    e ? (a.addClass(this._wrapper, "animation"), a.addClass(this._wrapper, Mv), this._wrapper.style.animationDuration = "300ms") : (a.addClass(this._wrapper, "animation"), a.addClass(this._wrapper, kv), this._wrapper.style.animationDuration = "300ms", this._options.inline || a.addClass(this._clock, Lv));
  }
  _addActiveClassToTip(e, s) {
    e.forEach((n) => {
      Number(n.textContent) === Number(s) && a.addClass(n, j);
    });
  }
  _setHourOrMinute(e) {
    return e < 10 ? `0${e}` : e;
  }
  _appendTimes() {
    const { format24: e } = this._options;
    e ? (this._getAppendClock(this.hoursArray, `.${ue}`, `${et}`), this._getAppendClock(this.innerHours, `.${is}`, Tt)) : this._getAppendClock(this.hoursArray, `.${ue}`, `${et}`);
  }
  _getConfig(e) {
    const s = a.getDataAttributes(this._element);
    return e = {
      ...Bv,
      ...s,
      ...e
    }, Y(H, e, Vv), e;
  }
  _getContainer() {
    return u.findOne(this._options.container);
  }
  _listenToUserInput() {
    h.on(this.input, "input", (e) => {
      this._handleUserInput(e.target.value);
    });
  }
  _handleUserInput(e) {
    const { format24: s, format12: n } = this._options;
    if (this.input.value === "")
      return;
    const o = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/, r = /^(?:[01]\d|2[0-3]):[0-5]\d$/, l = o.test(e);
    r.test(e) === !0 && s ? (this._isInvalidTimeFormat = !1, this._inputValue = this.input.value, this._currentTime = An(this._inputValue)) : l === !0 && n ? (this._isInvalidTimeFormat = !1, this._inputValue = this.input.value, this._currentTime = se(this._inputValue)) : this._isInvalidTimeFormat = !0;
  }
  // Static
  static jQueryInterface(e) {
    return this.each(function() {
      let s = P.getData(this, id);
      const n = typeof e == "object" && e;
      if (!(!s && /dispose|hide/.test(e)) && (s || (s = new Ko(this, n)), typeof e == "string")) {
        if (typeof s[e] > "u")
          throw new TypeError(`No method named "${e}"`);
        s[e]();
      }
    });
  }
}
const Wv = "navbar";
class GS extends F {
  // Getters
  static get NAME() {
    return Wv;
  }
  // Public
  init() {
    this._onScroll(), this._addEvent(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  dispose() {
    this._removeEvent(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _addEvent() {
    h.on(window, "scroll", () => this._onScroll());
  }
  _removeEvent() {
    h.off(window, "scroll");
  }
  _onScroll() {
    window.scrollY > 0 ? a.addClass(this._element, "navbar-scrolled") : a.removeClass(this._element, "navbar-scrolled");
  }
}
const co = "infiniteScroll", sd = `mdb.${co}`, Yv = `.${sd}`, Fv = `completed${Yv}`, Kv = {
  infiniteDirection: "y"
}, zv = {
  infiniteDirection: "string"
};
class nd extends F {
  constructor(t, e) {
    super(t), this._element = t, this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init(), this._element !== window && (a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return co;
  }
  get rect() {
    return this._element.getBoundingClientRect();
  }
  get condition() {
    return this._element === window ? Math.abs(window.scrollY + window.innerHeight - document.documentElement.scrollHeight) < 1 : this._options.infiniteDirection === "x" ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight;
  }
  // Public
  dispose() {
    h.off(this._element, "scroll"), this._element !== window && a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    h.on(this._element, "scroll", () => this._scrollHandler());
  }
  _scrollHandler() {
    this.condition && h.trigger(this._element, Fv), h.off(this._element, "scroll", this.scrollHandler);
  }
  _getConfig(t) {
    const e = {
      ...Kv,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(co, e, zv), e;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, sd);
      const s = typeof t == "object" && t;
      if (e || (e = new nd(this, s)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ol = "lazyLoad", od = "mdb.lazyLoad", rl = "lazy", Xv = ".lazy", al = ["img", "video"], rd = `.${od}`, jv = `contentLoaded${rd}`, Uv = `loadingError${rd}`, Gv = {
  lazySrc: "(string|null)",
  lazyDelay: "number",
  lazyAnimation: "string",
  lazyOffset: "number",
  lazyPlaceholder: "(string|undefined)",
  lazyError: "(string|undefined)"
}, qv = {
  lazySrc: null,
  lazyDelay: 500,
  lazyAnimation: "fade-in",
  lazyOffset: 0
};
class ho extends F {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return ol;
  }
  get offsetValues() {
    return this._element.getBoundingClientRect();
  }
  get inViewport() {
    if (this.parent) {
      const t = this.parent.getBoundingClientRect();
      return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight;
    }
    return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0;
  }
  get parent() {
    const [t] = u.parents(this._element, Xv);
    return t;
  }
  get node() {
    return this._element.nodeName;
  }
  get isContainer() {
    return !u.matches(this._element, al);
  }
  // Public
  dispose() {
    h.off(this._element, "load"), h.off(this._element, "error", this.errorHandler), h.off(window, "scroll", this.scrollHandler), this._animation && (this._animation.dispose(), this._animation = null), this._childrenInstances && this._childrenInstances.forEach((t) => t.dispose()), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _init() {
    if (a.addClass(this._element, rl), this.isContainer) {
      this._setupContainer();
      return;
    }
    this._setupElement();
  }
  _setupElement() {
    h.one(this._element, "error", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new Yo(this._element, {
      animation: this._options.lazyAnimation,
      animationStart: "onLoad"
    }), h.one(this._element, "load", () => this._scrollHandler()), this.parent && h.on(this.parent, "scroll", this.scrollHandler), h.on(window, "scroll", this.scrollHandler);
  }
  _scrollHandler() {
    this.inViewport && (this._timeout = setTimeout(() => {
      this._setSrc(), this._element.classList.remove(rl), this._removeAttrs(), this._animation.init();
    }, this._options.lazyDelay), this.parent && h.off(this.parent, "scroll", this.scrollHandler), h.off(window, "scroll", this.scrollHandler));
  }
  _setElementError() {
    !this._options.lazyError || this._element.src === this._options.lazyError ? this._element.alt = "404 not found" : this._element.setAttribute("src", this._options.lazyError), h.trigger(this._element, Uv);
  }
  _setSrc() {
    this._element.setAttribute("src", this._options.lazySrc), h.trigger(this._element, jv);
  }
  _setPlaceholder() {
    this.node === "IMG" ? this._element.setAttribute("src", this._options.lazyPlaceholder) : this.node === "VIDEO" && this._element.setAttribute("poster", this._options.lazyPlaceholder);
  }
  _removeAttrs() {
    ["src", "delay", "animation", "placeholder", "offset", "error"].forEach((t) => {
      a.removeDataAttribute(this._element, `lazy-${t}`);
    });
  }
  _setupContainer() {
    this._childrenInstances = u.children(this._element, al).map(
      (t) => new ho(t, this._options)
    );
  }
  _getConfig(t) {
    const e = {
      ...qv,
      ...t,
      ...a.getDataAttributes(this._element)
    };
    return Y(ol, e, Gv), e;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, od);
      const s = typeof t == "object" && t;
      if (e || (e = new ho(this, s)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
function nt(i) {
  return i.getDate();
}
function Cs(i) {
  return i.getDay();
}
function G(i) {
  return i.getMonth();
}
function V(i) {
  return i.getFullYear();
}
function Qv(i, t, e) {
  const s = e.startDay, n = s > 0 ? 7 - s : 0, r = new Date(i, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function uo(i) {
  return Zv(i).getDate();
}
function Zv(i) {
  return $t(i.getFullYear(), i.getMonth() + 1, 0);
}
function qe() {
  return /* @__PURE__ */ new Date();
}
function ct(i, t) {
  return dt(i, t * 12);
}
function dt(i, t) {
  const e = $t(i.getFullYear(), i.getMonth() + t, i.getDate()), s = nt(i), n = nt(e);
  return s !== n && e.setDate(0), e;
}
function Me(i, t) {
  return $t(i.getFullYear(), i.getMonth(), i.getDate() + t);
}
function $t(i, t, e) {
  const s = new Date(i, t, e);
  return i >= 0 && i < 100 && s.setFullYear(s.getFullYear() - 1900), s;
}
function ll(i) {
  const t = i.split("-"), e = t[0], s = t[1], n = t[2];
  return $t(e, s, n);
}
function Jv(i) {
  return !Number.isNaN(i.getTime());
}
function ze(i, t) {
  return V(i) - V(t) || G(i) - G(t) || nt(i) - nt(t);
}
function fe(i, t) {
  return i.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), i.getTime() === t.getTime();
}
function ys(i, t) {
  const s = V(i) - eE();
  return tE(s, t);
}
function tE(i, t) {
  return (i % t + t) % t;
}
function eE(i, t, e) {
  let s = 0;
  return e ? s = V(e) - i + 1 : t && (s = V(t)), s;
}
function yi(i, t, e, s, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const l = t && ze(i, t) <= -1, c = e && ze(i, e) >= 1, d = n && ze(i, r) <= -1, p = o && ze(i, r) >= 1, f = s && s(i) === !1;
  return l || c || f || d || p;
}
function ad(i, t, e, s, n, o) {
  const r = /* @__PURE__ */ new Date(), l = s && V(s), c = s && G(s), d = e && V(e), p = e && G(e), f = V(r), m = G(r), g = c && l && (t > l || t === l && i > c), _ = p && d && (t < d || t === d && i < p), b = n && (t < f || t === f && i < m), C = o && (t > f || t === f && i > m);
  return g || _ || b || C;
}
function po(i, t, e, s, n) {
  const o = t && V(t), r = e && V(e), l = V(/* @__PURE__ */ new Date()), c = r && i > r, d = o && i < o, p = s && i < l, f = n && i > l;
  return c || d || p || f;
}
function iE(i, t, e, s, n, o, r, l) {
  const c = /* @__PURE__ */ new Date();
  return c.setHours(0, 0, 0, 0), (i && o && ze(o, c) < 0 || i) && (o = c), o && Ai(
    t,
    o,
    e,
    s,
    n,
    o,
    r,
    l
  );
}
function sE(i, t, e, s, n, o, r, l) {
  const c = /* @__PURE__ */ new Date();
  return c.setHours(0, 0, 0, 0), (i && n && ze(n, c) < 0 || i) && (n = c), n && Ai(
    t,
    n,
    e,
    s,
    n,
    o,
    r,
    l
  );
}
function Ai(i, t, e, s, n, o, r, l) {
  return e === "days" ? V(i) === V(t) && G(i) === G(t) : e === "months" ? V(i) === V(t) : e === "years" ? V(t) >= l && V(t) <= r : !1;
}
function nE(i, t, e, s, n, o, r, l, c) {
  const d = G(i), p = V(i), f = nt(i), m = Cs(i), g = O("div"), _ = `
        ${cl(
    i,
    d,
    p,
    t,
    e,
    s,
    n,
    o,
    r,
    l
  )}
    `, b = `
      ${rE(f, m, d, n, i)}
      ${cl(
    i,
    d,
    p,
    t,
    e,
    s,
    n,
    o,
    r,
    l
  )}
    `;
  return n.inline ? (a.addClass(g, "datepicker-dropdown-container"), a.addClass(g, `datepicker-dropdown-container-${c}`), g.innerHTML = _) : (a.addClass(g, "datepicker-modal-container"), a.addClass(g, `datepicker-modal-container-${c}`), g.innerHTML = b), g;
}
function oE() {
  const i = O("div");
  return a.addClass(i, "datepicker-backdrop"), i;
}
function ld(i, t, e, s, n) {
  const { weekdaysShort: o, weekdaysFull: r, monthsShort: l, headerTemplateModifier: c, headerTemplate: d } = n, p = c ? c(s) : s;
  return d.replaceAll("[day]", i).replaceAll("[weekday]", o[t]).replaceAll("[weekdayFull]", r[t]).replaceAll("[month]", l[e]).replaceAll("[selected]", p);
}
function rE(i, t, e, s, n) {
  return `
      <div class="datepicker-header">
      ${s.headerTemplate ? ld(i, t, e, n, s) : `
        <div class="datepicker-title">
          <span class="datepicker-title-text">${s.title}</span>
        </div>
        <div class="datepicker-date">
          <span class="datepicker-date-text">${s.weekdaysShort[t]}, ${s.monthsShort[e]} ${i}</span>
        </div>
        `}
      </div>
    `;
}
function cl(i, t, e, s, n, o, r, l, c, d) {
  let p;
  return r.inline ? p = `
    <div class="datepicker-main">
      ${dl(t, e, r)}
      <div class="datepicker-view" tabindex="0">
        ${hl(
    i,
    e,
    s,
    n,
    o,
    r,
    l,
    c,
    d
  )}
      </div>
    </div>
  ` : p = `
      <div class="datepicker-main">
        ${dl(t, e, r)}
        <div class="datepicker-view" tabindex="0">
          ${hl(
    i,
    e,
    s,
    n,
    o,
    r,
    l,
    c,
    d
  )}
        </div>
        ${aE(r)}
      </div>
    `, p;
}
function hl(i, t, e, s, n, o, r, l, c) {
  let d;
  return o.view === "days" ? d = As(i, e, o) : o.view === "months" ? d = Ss(t, s, n, o, r) : d = ws(i, s, o, l, c), d;
}
function dl(i, t, e) {
  return `
    <div class="datepicker-date-controls">
      <button class="datepicker-view-change-button" aria-label="${e.switchToMultiYearViewLabel}">
        ${e.monthsFull[i]} ${t}
      </button>
      <div class="datepicker-arrow-controls">
        <button class="datepicker-previous-button" aria-label="${e.prevMonthLabel}"></button>
        <button class="datepicker-next-button" aria-label="${e.nextMonthLabel}"></button>
      </div>
    </div>
    `;
}
function aE(i) {
  const t = `<button class="datepicker-footer-btn datepicker-ok-btn" aria-label="${i.okBtnLabel}">${i.okBtnText}</button>`, e = `<button class="datepicker-footer-btn datepicker-cancel-btn" aria-label="${i.cancelBtnLabel}">${i.cancelBtnText}</button>`, s = `<button class="datepicker-footer-btn datepicker-clear-btn" aria-label="${i.clearBtnLabel}">${i.clearBtnText}</button>`;
  return `
        <div class="datepicker-footer">
          ${i.removeClearBtn ? "" : s}
          ${i.removeCancelBtn ? "" : e}
          ${i.removeOkBtn ? "" : t}
        </div>
      `;
}
function As(i, t, e) {
  const s = lE(i, t, e), o = `
      <tr>
        ${e.weekdaysNarrow.map((l, c) => `<th class="datepicker-day-heading" scope="col" aria-label="${e.weekdaysFull[c]}">${l}</th>`).join("")}
      </tr>
    `, r = s.map((l) => `
        <tr>
          ${l.map((c) => `
              <td
              class="datepicker-cell datepicker-small-cell datepicker-day-cell
              ${c.currentMonth ? "" : "disabled"} ${c.disabled ? "disabled" : ""}
              ${c.isToday && "current"} ${c.isSelected && "selected"}"
              data-mdb-date="${V(c.date)}-${G(c.date)}-${nt(c.date)}"
              aria-label="${c.date}"
              aria-selected="${c.isSelected}">
                <div
                  class="datepicker-cell-content datepicker-small-cell-content"
                  style="${c.currentMonth ? "display: block" : "display: none"}">
                  ${c.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="datepicker-table">
        <thead>
          ${o}
        </thead>
        <tbody class="datepicker-table-body">
         ${r}
        </tbody>
      </table>
    `;
}
function lE(i, t, e) {
  const s = [], n = G(i), o = G(dt(i, -1)), r = G(dt(i, 1)), l = V(i), c = Qv(l, n, e), d = uo(i), p = uo(dt(i, -1)), f = 7;
  let m = 1, g = !1;
  for (let _ = 1; _ < f; _++) {
    const b = [];
    if (_ === 1) {
      const C = p - c + 1;
      for (let T = C; T <= p; T++) {
        const E = $t(l, o, T);
        b.push({
          date: E,
          currentMonth: g,
          isSelected: t && fe(E, t),
          isToday: fe(E, qe()),
          dayNumber: nt(E),
          disabled: yi(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        });
      }
      g = !0;
      const v = f - b.length;
      for (let T = 0; T < v; T++) {
        const E = $t(l, n, m);
        b.push({
          date: E,
          currentMonth: g,
          isSelected: t && fe(E, t),
          isToday: fe(E, qe()),
          dayNumber: nt(E),
          disabled: yi(
            E,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), m++;
      }
    } else
      for (let C = 1; C < 8; C++) {
        m > d && (m = 1, g = !1);
        const v = $t(l, g ? n : r, m);
        b.push({
          date: v,
          currentMonth: g,
          isSelected: t && fe(v, t),
          isToday: fe(v, qe()),
          dayNumber: nt(v),
          disabled: yi(
            v,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), m++;
      }
    s.push(b);
  }
  return s;
}
function Ss(i, t, e, s, n) {
  const o = cE(s, n), r = G(qe()), l = V(qe());
  return `
      <table class="datepicker-table">
        <tbody class="datepicker-table-body">
         ${`
      ${o.map((d) => `
          <tr>
            ${d.map((p) => {
    const f = s.monthsShort.indexOf(p);
    return `
                <td class="datepicker-cell datepicker-large-cell datepicker-month-cell ${ad(
      f,
      i,
      s.min,
      s.max,
      s.disablePast,
      s.disableFuture
    ) ? "disabled" : ""} ${f === e && i === t ? "selected" : ""} ${f === r && i === l ? "current" : ""}" data-mdb-month="${f}" data-mdb-year="${i}" aria-label="${p}, ${i}">
                  <div class="datepicker-cell-content datepicker-large-cell-content">${p}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `}
        </tbody>
      </table>
    `;
}
function cE(i, t) {
  const e = [];
  let s = [];
  for (let n = 0; n < i.monthsShort.length; n++)
    if (s.push(i.monthsShort[n]), s.length === t) {
      const o = s;
      e.push(o), s = [];
    }
  return e;
}
function ws(i, t, e, s, n) {
  const o = hE(i, s, n), r = V(qe());
  return `
      <table class="datepicker-table">
        <tbody class="datepicker-table-body">
        ${`
    ${o.map((c) => `
        <tr>
          ${c.map((d) => `
              <td class="datepicker-cell datepicker-large-cell datepicker-year-cell ${po(
    d,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "disabled" : ""} ${d === t ? "selected" : ""} ${d === r ? "current" : ""}" aria-label="${d}" data-mdb-year="${d}">
                <div class="datepicker-cell-content datepicker-large-cell-content">${d}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `}
        </tbody>
      </table>
    `;
}
function hE(i, t, e) {
  const s = [], n = V(i), o = ys(i, t), r = n - o;
  let l = [];
  for (let c = 0; c < t; c++)
    if (l.push(r + c), l.length === e) {
      const d = l;
      s.push(d), l = [];
    }
  return s;
}
function dE(i) {
  return `
    <button id="${i}" type="button" class="datepicker-toggle-button" data-mdb-toggle="datepicker">
      <i class="far fa-calendar datepicker-toggle-icon"></i>
    </button>
  `;
}
const wt = 24, os = 4, rs = 4, _o = "datepicker", cd = `mdb.${_o}`, uE = ".data-api", zs = `.${cd}`, pE = `close${zs}`, _E = `open${zs}`, fE = `valueChanged${zs}`, as = `click${zs}${uE}`, mE = "fade-in", gE = "fade-out", bE = "fade-in", vE = "fade-out", EE = "form-icon-trailing", ls = '[data-mdb-toggle="datepicker"]', TE = ".datepicker-modal-container", CE = ".datepicker-dropdown-container", yE = ".datepicker-view-change-button", AE = ".datepicker-previous-button", SE = ".datepicker-next-button", wE = ".datepicker-ok-btn", OE = ".datepicker-cancel-btn", $E = ".datepicker-clear-btn", DE = ".datepicker-view", NE = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdaysFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Switch to year list",
  switchToDayViewLabel: "Switch to day list",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1,
  headerTemplate: null,
  headerTemplateModifier: null
}, LE = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  switchToMultiYearViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  min: "(null|date|string)",
  max: "(null|date|string)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean",
  headerTemplate: "(null|string)",
  headerTemplateModifier: "(null|function)"
};
class zo extends F {
  constructor(t, e) {
    super(t), this._input = u.findOne("input", this._element), this._options = this._getConfig(e), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = this._element.id ? `datepicker-toggle-${this._element.id}` : Ot("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new Ze(), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true"), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return _o;
  }
  get container() {
    return u.findOne(`${TE}-${this._toggleButtonId}`) || u.findOne(`${CE}-${this._toggleButtonId}`);
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return nt(this._activeDate);
  }
  get activeMonth() {
    return G(this._activeDate);
  }
  get activeYear() {
    return V(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - ys(this._activeDate, wt);
  }
  get lastYearInView() {
    return this.firstYearInView + wt - 1;
  }
  get viewChangeButton() {
    return u.findOne(yE, this.container);
  }
  get previousButton() {
    return u.findOne(AE, this.container);
  }
  get nextButton() {
    return u.findOne(SE, this.container);
  }
  get okButton() {
    return u.findOne(wE, this.container);
  }
  get cancelButton() {
    return u.findOne(OE, this.container);
  }
  get clearButton() {
    return u.findOne($E, this.container);
  }
  get datesContainer() {
    return u.findOne(DE, this.container);
  }
  get toggleButton() {
    return u.findOne(".datepicker-toggle-button", this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    if (t = {
      ...NE,
      ...e,
      ...t
    }, Y(_o, t, LE), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const s = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = s;
    }
    return t;
  }
  _getContainer() {
    return u.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, s = t.weekdaysNarrow;
    return s.slice(e).concat(s.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = dE(this._toggleButtonId);
    this._element.insertAdjacentHTML("beforeend", t), a.addClass(this._input, EE);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = h.trigger(this._element, _E);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = oE(), s = nE(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      rs,
      wt,
      os,
      this._toggleButtonId
    );
    this._options.inline ? this._openDropdown(s) : (this._openModal(e, s), this._scrollBar.hide()), this._animations && (a.addClass(this.container, "animation"), a.addClass(this.container, bE), this.container.style.animationDuration = "300ms", a.addClass(e, "animation"), a.addClass(e, mE), e.style.animationDuration = "150ms"), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = ae(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const s = this._getContainer();
    s.appendChild(t), s.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new Fo(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    h.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    h.on(this._element, as, ls, (t) => {
      t.preventDefault(), this.open();
    });
  }
  _listenToToggleKeydown() {
    h.on(this._element, "keydown", ls, (t) => {
      t.keyCode === ot && !this._isOpen && this.open();
    });
  }
  _listenToDateSelection() {
    h.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, s = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.mdbDate && this._pickDay(e.mdbDate, s), e.mdbMonth && e.mdbYear) {
      const n = parseInt(e.mdbMonth, 10), o = parseInt(e.mdbYear, 10);
      this._pickMonth(n, o);
    }
    if (e.mdbYear && !e.mdbMonth) {
      const n = parseInt(e.mdbYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, s) {
    const n = u.findOne(".datepicker-date-text", this.container), o = G(t), r = nt(t), l = Cs(t), c = u.findOne(".datepicker-header", this.container);
    if (this._options.headerTemplate && c) {
      c.innerHTML = ld(
        r,
        l,
        o,
        t,
        this._options
      );
      return;
    }
    n.innerHTML = `${s[l]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    h.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), h.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), h.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    h.on(this.okButton, "click", () => this.handleOk()), h.on(this.cancelButton, "click", () => this.handleCancel()), h.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    h.on(document, as, (t) => {
      const e = t.target === this.container, s = this.container && this.container.contains(t.target);
      !e && !s && this.close();
    });
  }
  _listenToEscapeClick() {
    h.on(document, "keydown", (t) => {
      t.keyCode === Ae && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    h.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    h.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    h.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell;
    switch (t.keyCode) {
      case Ue:
        this._activeDate = Me(this._activeDate, B ? 1 : -1);
        break;
      case Ge:
        this._activeDate = Me(this._activeDate, B ? -1 : 1);
        break;
      case tt:
        this._activeDate = Me(this._activeDate, -7);
        break;
      case J:
        this._activeDate = Me(this._activeDate, 7);
        break;
      case ve:
        this._activeDate = Me(this._activeDate, 1 - nt(this._activeDate));
        break;
      case Ee:
        this._activeDate = Me(
          this._activeDate,
          uo(this._activeDate) - nt(this._activeDate)
        );
        break;
      case Tn:
        this._activeDate = dt(this._activeDate, -1);
        break;
      case Cn:
        this._activeDate = dt(this._activeDate, 1);
        break;
      case ot:
      case Es:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      wt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && a.addClass(t, "focused");
  }
  _removeHighlightFromCell(t) {
    t && t.classList.remove("focused");
  }
  _getActiveDayCell() {
    const t = u.find("td", this.datesContainer);
    return Array.from(t).find((s) => {
      const n = ll(s.dataset.mdbDate);
      return fe(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell;
    switch (t.keyCode) {
      case Ue:
        this._activeDate = dt(this._activeDate, B ? 1 : -1);
        break;
      case Ge:
        this._activeDate = dt(this._activeDate, B ? -1 : 1);
        break;
      case tt:
        this._activeDate = dt(this._activeDate, -4);
        break;
      case J:
        this._activeDate = dt(this._activeDate, 4);
        break;
      case ve:
        this._activeDate = dt(this._activeDate, -this.activeMonth);
        break;
      case Ee:
        this._activeDate = dt(this._activeDate, 11 - this.activeMonth);
        break;
      case Tn:
        this._activeDate = ct(this._activeDate, -1);
        break;
      case Cn:
        this._activeDate = ct(this._activeDate, 1);
        break;
      case ot:
      case Es:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      wt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = u.find("td", this.datesContainer);
    return Array.from(t).find((s) => {
      const n = parseInt(s.dataset.mdbYear, 10), o = parseInt(s.dataset.mdbMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, s = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Ue:
        this._activeDate = ct(this._activeDate, B ? 1 : -1);
        break;
      case Ge:
        this._activeDate = ct(this._activeDate, B ? -1 : 1);
        break;
      case tt:
        this._activeDate = ct(this._activeDate, -n);
        break;
      case J:
        this._activeDate = ct(this._activeDate, n);
        break;
      case ve:
        this._activeDate = ct(
          this._activeDate,
          -ys(this._activeDate, o)
        );
        break;
      case Ee:
        this._activeDate = ct(
          this._activeDate,
          o - ys(this._activeDate, o) - 1
        );
        break;
      case Tn:
        this._activeDate = ct(this._activeDate, -o);
        break;
      case Cn:
        this._activeDate = ct(this._activeDate, o);
        break;
      case ot:
      case Es:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    Ai(
      e,
      this._activeDate,
      this._view,
      wt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(s), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = u.find("td", this.datesContainer);
    return Array.from(t).find((s) => parseInt(s.dataset.mdbYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = h.trigger(this._element, pE);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && (a.addClass(this.container, "animation"), a.addClass(this.container, vE)), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = u.findOne(".datepicker-dropdown-container"), e = this._getContainer();
    this._animations ? t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }) : (t && e.removeChild(t), this._popper && this._popper.destroy()), this._removeFocusTrap();
  }
  _closeModal() {
    const t = u.findOne(".datepicker-backdrop"), e = u.findOne(".datepicker-modal-container");
    !e || !t || (this._animations && (a.addClass(t, "animation"), a.addClass(t, gE)), this._animations ? t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    }) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const s = this._getContainer();
    s.removeChild(t), s.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    h.off(this.nextButton, "click"), h.off(this.previousButton, "click"), h.off(this.viewChangeButton, "click"), h.off(this.okButton, "click"), h.off(this.cancelButton, "click"), h.off(this.clearButton, "click"), h.off(this.datesContainer, "click"), h.off(this.datesContainer, "keydown"), h.off(this.datesContainer, "focus"), h.off(this.datesContainer, "blur"), h.off(document, as);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = u.findOne(`#${this._toggleButtonId}`);
    t && this._element.removeChild(t), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  _removeInputAndToggleListeners() {
    h.off(this._input, "input"), h.off(this._element, as, ls), h.off(this._element, "keydown", ls);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: s, max: n, filter: o, disablePast: r, disableFuture: l } = this._options;
    yi(t, s, n, o, r, l) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = V(t), this._selectedMonth = G(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.classList.remove("selected");
  }
  _addSelectedStyles(t) {
    t && a.addClass(t, "selected");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, a.addClass(this._input, "active"), h.trigger(this._element, fE, { date: t });
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._input.classList.remove("active"), this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = u.findOne(".selected", this.container);
    t && t.classList.remove("selected");
  }
  _removeCurrentFocusStyles() {
    const t = u.findOne(".focused", this.container);
    t && t.classList.remove("focused");
  }
  formatDate(t) {
    const e = nt(t), s = this._addLeadingZero(nt(t)), n = this._options.weekdaysShort[Cs(t)], o = this._options.weekdaysFull[Cs(t)], r = G(t) + 1, l = this._addLeadingZero(G(t) + 1), c = this._options.monthsShort[G(t)], d = this._options.monthsFull[G(t)], p = V(t).toString().length === 2 ? V(t) : V(t).toString().slice(2, 4), f = V(t), m = this._options.format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
    let g = "";
    return m.forEach((_) => {
      switch (_) {
        case "dddd":
          _ = _.replace(_, o);
          break;
        case "ddd":
          _ = _.replace(_, n);
          break;
        case "dd":
          _ = _.replace(_, s);
          break;
        case "d":
          _ = _.replace(_, e);
          break;
        case "mmmm":
          _ = _.replace(_, d);
          break;
        case "mmm":
          _ = _.replace(_, c);
          break;
        case "mm":
          _ = _.replace(_, l);
          break;
        case "m":
          _ = _.replace(_, r);
          break;
        case "yyyy":
          _ = _.replace(_, f);
          break;
        case "yy":
          _ = _.replace(_, p);
          break;
      }
      g += _;
    }), g;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const s = ll(t), { min: n, max: o, filter: r, disablePast: l, disableFuture: c } = this._options;
    yi(s, n, o, r, l, c) || (this._activeDate = s, this._selectDate(s, e));
  }
  _pickYear(t) {
    const { min: e, max: s, disablePast: n, disableFuture: o } = this._options;
    if (po(t, e, s, n, o))
      return;
    const r = $t(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: s, max: n, disablePast: o, disableFuture: r } = this._options;
    if (ad(t, e, s, n, o, r) || po(e, s, n, o, r))
      return;
    const l = $t(e, t, this.activeDay);
    this._activeDate = l, this._selectMonth(t);
  }
  nextMonth() {
    const t = dt(this._activeDate, 1), e = As(t, this._headerDate, this._options);
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = dt(this._activeDate, -1);
    this._activeDate = t;
    const e = As(t, this._headerDate, this._options);
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = ct(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`;
    const e = Ss(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      rs
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = ct(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`;
    const e = Ss(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      rs
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = ct(this._activeDate, 24);
    this._activeDate = t;
    const e = ws(
      t,
      this._selectedYear,
      this._options,
      wt,
      os
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = ct(this._activeDate, -24);
    this._activeDate = t;
    const e = ws(
      t,
      this._selectedYear,
      this._options,
      wt,
      os
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = As(
      this._activeDate,
      this._headerDate,
      this._options
    )), t === "months" && (this.datesContainer.innerHTML = Ss(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      rs
    )), t === "years" && (this.datesContainer.innerHTML = ws(
      this._activeDate,
      this._selectedYear,
      this._options,
      wt,
      os
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToMultiYearViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMonthLabel), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.setAttribute("aria-label", this._options.switchToDayViewLabel), this.previousButton.setAttribute("aria-label", this._options.prevMultiYearLabel), this.nextButton.setAttribute("aria-label", this._options.nextMultiYearLabel));
  }
  _updateControlsDisabledState() {
    iE(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      wt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, sE(
      this._options.disablePast,
      this._activeDate,
      this._view,
      wt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), s = this._parseDate(t, this._options.format, e);
    Jv(s) ? (this._activeDate = s, this._selectedDate = s, this._selectedYear = V(s), this._selectedMonth = G(s), this._headerDate = s) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, s) {
    let n;
    s[0] !== s[1] ? n = s[0] + s[1] : n = s[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), l = e.split(o), c = e.indexOf("mmm") !== -1, d = [];
    for (let b = 0; b < l.length; b++)
      l[b].indexOf("yy") !== -1 && (d[0] = { value: r[b], format: l[b] }), l[b].indexOf("m") !== -1 && (d[1] = { value: r[b], format: l[b] }), l[b].indexOf("d") !== -1 && l[b].length <= 2 && (d[2] = { value: r[b], format: l[b] });
    let p;
    e.indexOf("mmmm") !== -1 ? p = this._options.monthsFull : p = this._options.monthsShort;
    const f = Number(d[0].value), m = c ? this.getMonthNumberByMonthName(d[1].value, p) : Number(d[1].value) - 1, g = Number(d[2].value);
    return $t(f, m, g);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((s) => s === t);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, cd);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new zo(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const ul = "popconfirm", hd = "mdb.popconfirm", IE = ".popconfirm", dd = `.${hd}`, kE = `cancel${dd}`, ME = `confirm${dd}`, xE = {
  popconfirmMode: "string",
  message: "string",
  cancelText: "string",
  okText: "string",
  okClass: "string",
  popconfirmIcon: "string",
  cancelLabel: "string",
  confirmLabel: "string"
}, RE = {
  popconfirmMode: "inline",
  message: "Are you sure?",
  cancelText: "Cancel",
  okText: "OK",
  okClass: "btn-primary",
  popconfirmIcon: "",
  cancelLabel: "Cancel",
  confirmLabel: "Confirm"
};
class ud extends F {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this._cancelButtonTemplate = this._getCancelButtonTemplate(), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : Ot("popconfirm-"), this._clickHandler = this.open.bind(this), h.on(this._element, "click", this._clickHandler), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return ul;
  }
  get container() {
    return u.findOne(`#${this._uid}`);
  }
  get popconfirmBody() {
    return u.findOne(IE, this.container);
  }
  // Public
  dispose() {
    (this._isOpen || this.container !== null) && this.close(), h.off(this._element, "click", this._clickHandler), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  open() {
    this._isOpen || (this._options.popconfirmMode === "inline" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());
  }
  close() {
    if (this._isOpen) {
      if (this._popper !== null || u.findOne(".popconfirm-popover") !== null)
        h.on(
          this.popconfirmBody,
          "transitionend",
          this._handlePopconfirmTransitionEnd.bind(this)
        ), a.removeClass(this.popconfirmBody, "show");
      else {
        const t = u.findOne(".popconfirm-backdrop");
        a.removeClass(this.popconfirmBody, "show"), document.body.removeChild(t), this._isOpen = !1;
      }
      h.off(document, "click", this._handleOutsideClick.bind(this)), h.off(document, "keydown", this._handleEscapeKey.bind(this));
    }
  }
  _handlePopconfirmTransitionEnd(t) {
    if (t.target !== this.popconfirmBody)
      return;
    const e = u.findOne(".popconfirm-popover");
    h.off(this.popconfirmBody, "transitionend"), this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);
  }
  // Private
  _getPopoverTemplate() {
    const t = O("div"), e = this._getPopconfirmTemplate();
    return a.addClass(t, "popconfirm-popover"), a.addClass(t, "shadow-2"), t.id = this._uid, t.innerHTML = e, t;
  }
  _getModalTemplate() {
    const t = O("div"), e = this._getPopconfirmTemplate();
    return a.addClass(t, "popconfirm-modal"), a.addClass(t, "shadow-2"), t.id = this._uid, t.innerHTML = e, t;
  }
  _getPopconfirmTemplate() {
    return `<div class="popconfirm">
      <p class="popconfirm-message">
      ${this._getMessageIcon()}
      <span class="popconfirm-message-text">${this._options.message}</span>
      </p>
      <div class="popconfirm-buttons-container">
      ${this._cancelButtonTemplate}
      <button type="button" id="popconfirm-button-confirm" data-mdb-ripple-init
      aria-label="${this._options.confirmLabel}"
      class="btn ${this._options.okClass} btn-sm">${this._options.okText}</button>
      </div>
    </div>`;
  }
  _getConfig(t) {
    return t = {
      ...RE,
      ...a.getDataAttributes(this._element),
      ...t
    }, Y(ul, t, xE), t;
  }
  _getCancelButtonTemplate() {
    return this._options.cancelText === "" || this._options.cancelText === " " ? "" : `<button type="button" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"
    class="btn btn-secondary btn-sm" data-mdb-ripple-init >${this._options.cancelText}</button>`;
  }
  _getMessageIcon() {
    return this._options.popconfirmIcon === "" ? "" : `<span class="popconfirm-icon-container"><i class="${this._options.popconfirmIcon}"></i></span>`;
  }
  _openPopover(t) {
    this._popper = ae(this._element, t, {
      placement: this._translatePositionValue(),
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    }), document.body.appendChild(t), setTimeout(() => {
      a.addClass(this.popconfirmBody, "fade"), a.addClass(this.popconfirmBody, "show"), this._isOpen = !0;
    }, 0);
  }
  _openModal(t) {
    const e = O("div");
    a.addClass(e, "popconfirm-backdrop"), document.body.appendChild(e), e.appendChild(t), a.addClass(this.popconfirmBody, "show"), this._isOpen = !0;
  }
  _handleCancelButtonClick() {
    const t = this.container;
    this._cancelButton = u.findOne("#popconfirm-button-cancel", t), this._cancelButton !== null && h.on(this._cancelButton, "click", () => {
      this.close(), h.trigger(this._element, kE);
    });
  }
  _handleConfirmButtonClick() {
    const t = this.container;
    this._confirmButton = u.findOne("#popconfirm-button-confirm", t), h.on(this._confirmButton, "click", () => {
      this.close(), h.trigger(this._element, ME);
    });
  }
  _listenToEscapeKey() {
    h.on(document, "keydown", this._handleEscapeKey.bind(this));
  }
  _handleEscapeKey(t) {
    t.keyCode === Ae && this.close();
  }
  _listenToOutsideClick() {
    h.on(document, "click", this._handleOutsideClick.bind(this));
  }
  _handleOutsideClick(t) {
    const e = this.container, s = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);
    !s && !n && !o && !r && this.close();
  }
  _translatePositionValue() {
    switch (this._options.position) {
      case "top left":
        return B ? "top-start" : "top-end";
      case "top":
        return "top";
      case "top right":
        return B ? "top-end" : "top-start";
      case "bottom left":
        return B ? "bottom-start" : "bottom-end";
      case "bottom":
        return "bottom";
      case "bottom right":
        return B ? "bottom-end" : "bottom-start";
      case "left":
        return B ? "right" : "left";
      case "left top":
        return B ? "right-end" : "left-end";
      case "left bottom":
        return B ? "right-start" : "left-start";
      case "right":
        return B ? "left" : "right";
      case "right top":
        return B ? "left-end" : "right-end";
      case "right bottom":
        return B ? "left-start" : "right-start";
      case void 0:
        return "bottom";
      default:
        return this._options.position;
    }
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const s = P.getData(this, hd), n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t))) {
        if (!s)
          return new ud(this, n);
        if (typeof t == "string") {
          if (typeof s[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          s[t](e);
        }
      }
    });
  }
}
const PE = ({ text: i, entries: t, entriesOptions: e, fullPagination: s, rowsText: n, allText: o }, r) => {
  const l = e.map((c) => c === "All" ? `<option value="${c}" ${c === t ? "selected" : ""}>${o}</option>` : `<option value="${c}" ${c === t ? "selected" : ""}>${c}</option>`).join(`
`);
  return `
<div class="datatable-pagination">
  <div class="datatable-select-wrapper">
    <p class="datatable-select-text">${n}</p>
    <select name="entries"
      ${r ? 'data-mdb-disabled="true"' : ""} class="datatable-select select">
      ${l}
    </select>
  </div>
  <div class="datatable-pagination-nav">
  ${i}
  </div>
  <div class="datatable-pagination-buttons">
    ${s ? '<button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-start"><i class="fa fa-angle-double-left"></i></button>' : ""}
    <button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-left"><i class="fa fa-chevron-${B ? "right" : "left"}"></i></button>
    <button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-right"><i class="fa fa-chevron-${B ? "left" : "right"}"></i></button>
    ${s ? '<button data-mdb-ripple-color="dark" data-mdb-ripple-init class="btn btn-link datatable-pagination-button datatable-pagination-end"><i class="fa fa-angle-double-right"></i></button>' : ""}
  </div>
</div>
`;
}, HE = (i, t, e) => {
  const s = e ? `
<th scope="col">
  <div class="form-check d-flex align-items-center mb-0">
    <input class="datatable-header-checkbox form-check-input" type="checkbox">
  </div>
</th>
` : '<th scope="col"></th>', n = i.map((o, r) => {
    const l = o.fixed ? i.filter((c, d) => c.fixed === o.fixed && d < r).reduce((c, d) => c + d.width, 0) : null;
    return `<th style="${o.fixed ? `${o.fixed === "right" ? "right" : "left"}: ${l}px;` : ""}" ${o.fixed ? 'class="fixed-cell"' : ""} scope="col">${o.sort ? `<i data-mdb-sort="${o.field}" class="datatable-sort-icon fas fa-arrow-up"></i>` : ""} ${o.label}</th>`;
  });
  return [t ? s : "", ...n].join(`
`);
}, BE = ({ rows: i, columns: t, noFoundMessage: e, edit: s, selectable: n, loading: o }) => {
  const r = i.map((l) => {
    const c = `
    <td data-mdb-field="checkbox">
      <div class="form-check">
        <input data-mdb-row-index="${l.rowIndex}" class="datatable-row-checkbox form-check-input" type="checkbox">
      </div>
    </td>
    `, d = t.map((p, f) => {
      const m = {};
      if (p.width && (m["min-width"] = `${p.width - 1}px`, m["max-width"] = `${p.width}px`, m.width = `${p.width}px`), p.fixed) {
        const _ = t.filter((b, C) => b.fixed === p.fixed && C < f).reduce((b, C) => b + C.width, 0);
        m[p.fixed === "right" ? "right" : "left"] = `${_}px`;
      }
      return `<td style="${Object.keys(m).map((_) => `${_}: ${m[_]}`).join("; ")}" class="${p.fixed ? "fixed-cell" : ""}" data-mdb-field="${p.field}" ${s && 'contenteditable="true"'}>${l[p.field]}</td>`;
    }).join("");
    return `<tr scope="row" data-mdb-index="${l.rowIndex}">${n ? c : ""}${d}</tr>`;
  });
  return i.length > 0 || o ? r.join(`
`) : `<tr><td>${e}</td></tr>`;
}, pl = ({
  columns: i,
  rows: t,
  noFoundMessage: e,
  edit: s,
  multi: n,
  selectable: o,
  loading: r,
  loadingMessage: l,
  loaderClass: c,
  pagination: d
}) => {
  const p = BE({ rows: t, columns: i, noFoundMessage: e, edit: s, loading: r, selectable: o }), f = HE(i, o, n);
  return { table: `
<div class="datatable-inner table-responsive">
  <table class="table datatable-table">
    <thead class="datatable-header">
      <tr>
        ${f}
      </tr>
    </thead>
    <tbody class="datatable-body">
      ${r ? "" : p}
    </tbody>
  </table>
</div>
  ${r ? `
  <div class="datatable-loader bg-light}">
    <span class="datatable-loader-inner"><span class="datatable-progress ${c}"></span></span>
  </div>
  <p class="text-center text-muted my-4">${l}</p>
` : ""}
  ${d.enable ? PE(d, r) : ""}
  `, rows: p, column: f };
}, VE = ({ rows: i, field: t, order: e }) => i.sort((n, o) => {
  let r = n[t], l = o[t];
  return typeof r == "string" && (r = r.toLowerCase()), typeof l == "string" && (l = l.toLowerCase()), r < l ? e === "desc" ? 1 : -1 : r > l ? e === "desc" ? -1 : 1 : 0;
}), WE = (i, t, e) => {
  if (!t)
    return i;
  const s = (n) => {
    const o = document.createElement("div");
    return o.innerHTML = n, n = o.textContent || o.innerText || "", n.toString().toLowerCase().match(t.toLowerCase());
  };
  return i.filter((n) => {
    if (e && typeof e == "string")
      return s(n[e]);
    let o = Object.values(n);
    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => s(r)).length > 0;
  });
}, _l = ({ rows: i, entries: t, activePage: e }) => {
  const s = e * t;
  return i.slice(s, s + Number(t));
}, fl = ".form-check-input", cs = "selected", ml = "active";
class gl {
  constructor(t, e, s, n, o, r, l, c, d, p, f) {
    this.id = t, this.nativeOption = e, this.multiple = s, this.value = n, this.label = o, this.selected = r, this.disabled = l, this.hidden = c, this.secondaryText = d, this.groupId = p, this.icon = f, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (a.addClass(this.node, cs), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = u.findOne(fl, this.node);
      t.checked = !0, a.addClass(this.node, cs), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (a.removeClass(this.node, cs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = u.findOne(fl, this.node);
      t.checked = !1, a.removeClass(this.node, cs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    !this.active && !this.multiple && (this.active = !0, a.addClass(this.node, ml));
  }
  removeActiveStyles() {
    this.active && (this.active = !1, a.removeClass(this.node, ml));
  }
}
class YE {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex((s) => t === s);
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function fo(i) {
  return i.filter((t) => !t.disabled).every((t) => t.selected);
}
const FE = (i) => {
  i.code === "Tab" || i.code === "Esc" || i.preventDefault();
};
function KE(i, t, e) {
  const s = document.createElement("div");
  s.setAttribute("id", i), s.classList.add("select-wrapper");
  const n = O("div");
  a.addClass(n, "form-outline"), n.setAttribute("data-mdb-input-init", ""), t.formWhite && a.addClass(n, "form-white");
  const o = O("input"), r = t.filter ? "combobox" : "listbox", l = t.multiple ? "true" : "false", c = t.disabled ? "true" : "false";
  a.addClass(o, "form-control"), a.addClass(o, "select-input"), t.size === "sm" && a.addClass(o, "form-control-sm"), t.size === "lg" && a.addClass(o, "form-control-lg"), o.setAttribute("type", "text"), o.setAttribute("role", r), o.setAttribute("aria-multiselectable", l), o.setAttribute("aria-disabled", c), o.setAttribute("aria-haspopup", "true"), o.setAttribute("aria-expanded", !1), t.tabIndex && o.setAttribute("tabIndex", t.tabIndex), t.disabled && o.setAttribute("disabled", ""), t.placeholder !== "" && o.setAttribute("placeholder", t.placeholder), t.validation ? (a.addStyle(o, { "pointer-events": "none", "caret-color": "transparent" }), a.addStyle(n, { cursor: "pointer" })) : o.setAttribute("readonly", "true"), t.validation && (o.setAttribute("required", "true"), o.setAttribute("aria-required", "true"), o.addEventListener("keydown", FE));
  const d = O("div");
  a.addClass(d, "valid-feedback");
  const p = document.createTextNode(`${t.validFeedback}`);
  d.appendChild(p);
  const f = O("div");
  a.addClass(f, "invalid-feedback");
  const m = document.createTextNode(`${t.invalidFeedback}`);
  f.appendChild(m);
  const g = O("span");
  a.addClass(g, "select-clear-btn");
  const _ = document.createTextNode("✕");
  g.appendChild(_), g.setAttribute("tabindex", "0");
  const b = O("span");
  return a.addClass(b, "select-arrow"), n.appendChild(o), e && n.appendChild(e), t.validation && (n.appendChild(d), n.appendChild(f)), t.clearButton && n.appendChild(g), n.appendChild(b), s.appendChild(n), s;
}
function bl(i, t, e, s, n, o, r) {
  const l = document.createElement("div");
  l.classList.add("select-dropdown-container"), l.setAttribute("id", `${i}`), l.style.width = `${e}px`;
  const c = document.createElement("div");
  c.setAttribute("tabindex", 0), c.classList.add("select-dropdown");
  const d = O("div");
  a.addClass(d, "select-options-wrapper"), d.style.maxHeight = `${s}px`;
  const p = pd(o, n, t);
  return d.appendChild(p), t.filter && c.appendChild(zE(t.searchPlaceholder)), c.appendChild(d), r && c.appendChild(r), l.appendChild(c), l;
}
function pd(i, t, e) {
  const s = O("div");
  a.addClass(s, "select-options-list");
  let n;
  return e.multiple ? n = jE(i, t, e) : n = XE(i, e), n.forEach((o) => {
    s.appendChild(o);
  }), s;
}
function zE(i) {
  const t = O("div");
  a.addClass(t, "input-group");
  const e = O("input");
  return a.addClass(e, "form-control"), a.addClass(e, "select-filter-input"), e.placeholder = i, e.setAttribute("role", "searchbox"), e.setAttribute("type", "text"), t.appendChild(e), t;
}
function XE(i, t) {
  return _d(i, t);
}
function jE(i, t, e) {
  let s = null;
  e.selectAll && (s = UE(t, i, e));
  const n = _d(i, e);
  return s ? [s, ...n] : n;
}
function _d(i, t) {
  const e = [];
  return i.forEach((s) => {
    if (s.hasOwnProperty("options")) {
      const o = ZE(s, t);
      e.push(o);
    } else
      e.push(fd(s, t));
  }), e;
}
function UE(i, t, e) {
  const s = fo(t), n = O("div");
  return a.addClass(n, "select-option"), a.addClass(n, "select-all-option"), a.addStyle(n, { height: `${e.optionHeight}px` }), n.setAttribute("role", "option"), n.setAttribute("aria-selected", s), s && a.addClass(n, "selected"), n.appendChild(md(i, e)), i.setNode(n), n;
}
function fd(i, t) {
  if (i.node)
    return i.node;
  const e = O("div");
  return a.addClass(e, "select-option"), a.addStyle(e, { height: `${t.optionHeight}px` }), a.setDataAttribute(e, "id", i.id), e.setAttribute("role", "option"), e.setAttribute("aria-selected", i.selected), e.setAttribute("aria-disabled", i.disabled), i.selected && a.addClass(e, "selected"), i.disabled && a.addClass(e, "disabled"), i.hidden && a.addClass(e, "d-none"), e.appendChild(md(i, t)), i.icon && e.appendChild(QE(i)), i.setNode(e), e;
}
function md(i, t) {
  const e = O("span");
  a.addClass(e, "select-option-text");
  const s = document.createTextNode(i.label);
  return t.multiple && e.appendChild(qE(i)), e.appendChild(s), (i.secondaryText || typeof i.secondaryText == "number") && e.appendChild(GE(i.secondaryText)), e;
}
function GE(i) {
  const t = O("span");
  a.addClass(t, "select-option-secondary-text");
  const e = document.createTextNode(i);
  return t.appendChild(e), t;
}
function qE(i) {
  const t = O("input");
  t.setAttribute("type", "checkbox"), a.addClass(t, "form-check-input");
  const e = O("label");
  return i.selected && t.setAttribute("checked", !0), i.disabled && t.setAttribute("disabled", !0), t.appendChild(e), t;
}
function QE(i) {
  const t = O("span");
  a.addClass(t, "select-option-icon-container");
  const e = O("img");
  return a.addClass(e, "select-option-icon"), a.addClass(e, "rounded-circle"), e.src = i.icon, t.appendChild(e), t;
}
function ZE(i, t) {
  const e = O("div");
  a.addClass(e, "select-option-group"), e.setAttribute("role", "group"), e.setAttribute("id", i.id), i.hidden && a.addClass(e, "d-none");
  const s = O("label");
  return a.addClass(s, "select-option-group-label"), a.addStyle(s, { height: `${t.optionHeight}px` }), s.setAttribute("for", i.id), s.textContent = i.label, e.appendChild(s), i.options.forEach((n) => {
    e.appendChild(fd(n, t));
  }), e;
}
function JE(i) {
  const t = O("div");
  return t.textContent = i, a.addClass(t, "form-label"), a.addClass(t, "select-fake-value"), t;
}
const tT = {
  autoSelect: !1,
  container: "body",
  clearButton: !1,
  disabled: !1,
  displayedLabels: 5,
  formWhite: !1,
  multiple: !1,
  optionsSelectedLabel: "options selected",
  optionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  searchPlaceholder: "Search...",
  size: "default",
  visibleOptions: 5,
  filter: !1,
  filterDebounce: 300,
  noResultText: "No results",
  validation: !1,
  validFeedback: "Valid",
  invalidFeedback: "Invalid",
  placeholder: "",
  filterFn: null
}, eT = {
  autoSelect: "boolean",
  container: "string",
  clearButton: "boolean",
  disabled: "boolean",
  displayedLabels: "number",
  formWhite: "boolean",
  multiple: "boolean",
  optionsSelectedLabel: "string",
  optionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  searchPlaceholder: "string",
  size: "string",
  visibleOptions: "number",
  filter: "boolean",
  filterDebounce: "number",
  noResultText: "string",
  validation: "boolean",
  validFeedback: "string",
  invalidFeedback: "string",
  placeholder: "",
  filterFn: "(function|null)"
}, vl = "select", gd = "mdb.select", Oe = `.${gd}`, iT = `close${Oe}`, sT = `open${Oe}`, El = `optionSelected${Oe}`, Tl = `optionDeselected${Oe}`, nT = `valueChanged${Oe}`, oT = "change", rT = `opened${Oe}`, aT = `closed${Oe}`, lT = ".select-label", Cl = ".select-input", cT = ".select-filter-input", hT = ".select-dropdown", dT = ".select-options-wrapper", yl = ".select-options-list", uT = ".select-option", pT = ".select-clear-btn", _T = ".select-custom-content", fT = ".select-no-results", Al = ".form-outline", mT = "[data-mdb-toggle]", In = "select-initialized", Sl = "open", Ft = "active", wl = "focused", gT = "select-option-group-label", bT = "select-all-option", vT = 200;
class Xo extends F {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new YE(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = this._element.id ? `select-wrapper-${this._element.id}` : Ot("select-wrapper-"), this._dropdownContainerId = this._element.id ? `select-dropdown-container-${this._element.id}` : Ot("select-dropdown-container-"), this._selectAllId = this._element.id ? `select-all-${this._element.id}` : Ot("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.optionHeight * this._config.visibleOptions, this._popper = null, this._input = null, this._label = u.next(this._element, lT)[0], this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = u.next(t, _T)[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  static get NAME() {
    return vl;
  }
  get filterInput() {
    return u.findOne(cT, this._dropdownContainer);
  }
  get dropdown() {
    return u.findOne(hT, this._dropdownContainer);
  }
  get optionsList() {
    return u.findOne(yl, this._dropdownContainer);
  }
  get optionsWrapper() {
    return u.findOne(dT, this._dropdownContainer);
  }
  get clearButton() {
    return u.findOne(pT, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...tT,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), Y(vl, t, eT), t;
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: n.id ? `group-${n.id}` : Ot("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((l) => {
          l.nodeName === "OPTION" && o.options.push(this._createOptionObject(l, o));
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!u.findOne("optgroup", this._element))
      return t;
    const s = [];
    return t.forEach((n) => {
      n.hasOwnProperty("options") ? n.options.forEach((r) => {
        s.push(r);
      }) : s.push(n);
    }), s;
  }
  _createOptionObject(t, e = {}) {
    const s = t.id ? `option-${t.id}` : Ot("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute("selected"), l = t.hasAttribute("disabled") || o, c = t.hasAttribute("hidden") || e && e.hidden, d = this.multiple, p = t.value, f = t.label, m = a.getDataAttribute(t, "secondaryText"), g = a.getDataAttribute(t, "icon");
    return new gl(
      s,
      t,
      d,
      p,
      f,
      r,
      l,
      c,
      m,
      n,
      g
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = u.findOne(`#${this._wrapperId}`), this._input = u.findOne(Cl, this._wrapper), this._element.getAttribute("autocomplete") === "off" && this._input.setAttribute("autocomplete", "off");
    const t = this._config.container;
    t === "body" ? this._container = document.body : this._container = u.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = bl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent
    ), this._setFirstActiveOption();
  }
  _renderMaterialWrapper() {
    const t = KE(this._wrapperId, this._config, this._label);
    this._element.parentNode.insertBefore(t, this._element), a.addClass(this._element, In), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = u.findOne(Al, this._wrapper);
    new Wo(t).init();
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    h.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.filter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, s = e === Ae || e === tt && t.altKey || e === Se;
    if (e === Se && this._config.autoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), s) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case J:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case tt:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case ve:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Ee:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case ot:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === ot && t.preventDefault(), (e === ot || e === J && t.altKey || e === J && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case J:
          this.open();
          break;
        case tt:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case J:
          if (t.altKey)
            return;
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case tt:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case ve:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Ee:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const s = this.options.filter((p) => !p.hidden);
    this.hasSelectAll ? e = s.indexOf(t) + 1 : e = s.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, l = r.offsetHeight, c = this._config.optionHeight, d = r.scrollTop;
    if (e > -1) {
      const p = o * c, f = p + c > d + l;
      p < d ? r.scrollTop = p : f ? r.scrollTop = p - l + c : r.scrollTop = d;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), s = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && s[o] && s[o].id && e[r].groupId === s[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const s = this._activeOption;
    s && s.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    h.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    h.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    h.on(this.clearButton, "keydown", (t) => {
      t.keyCode === ot && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    h.on(this.optionsWrapper, "click", (t) => {
      if (t.target.classList.contains(gT))
        return;
      const s = t.target.nodeName === "DIV" ? t.target : u.closest(t.target, uT);
      if (s.classList.contains(bT)) {
        this._handleSelectAll();
        return;
      }
      const o = s.dataset.mdbId, r = this.options.find((l) => l.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute("selected", !1), h.trigger(this._element, Tl, { value: e.value })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), h.trigger(this._element, El, { value: t.value }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute("selected", !1), h.trigger(this._element, Tl, { value: t.value })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute("selected", !0), h.trigger(this._element, El, { value: t.value })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    h.trigger(this._element, nT, { value: t });
  }
  _emitNativeChangeEvent() {
    h.trigger(this._element, oT);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.displayedLabels !== -1 && this._selectionModel.selections.length > this._config.displayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.optionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = JE(t), u.findOne(Al, this._wrapper).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = a.hasClass(this._element, In), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? a.addClass(this._label, Ft) : a.removeClass(this._label, Ft));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? a.addClass(this._label, Ft) : a.removeClass(this._label, Ft));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this.hasSelection && (this._fakeValue.textContent = this.hasSelection.label), this._input.value === "" && this._fakeValue.innerHTML !== "" ? (this._isFakeValueActive = !0, a.addClass(this._fakeValue, Ft)) : (this._isFakeValueActive = !1, a.removeClass(this._fakeValue, Ft)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? a.addStyle(this.clearButton, { display: "block" }) : a.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = fo(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = h.trigger(this._element, sT);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.filter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, h.trigger(this._element, rT), this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = ae(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      a.addClass(this.dropdown, Sl);
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    a.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const s = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    s ? (this._activeOption = s, s.setActiveStyles(), this._activeOptionIndex = t.findIndex((n) => n === s)) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    a.addClass(this._input, wl);
  }
  _listenToWindowResize() {
    h.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, s = this._config.filterDebounce;
      this._debounceFilter(e, s);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [], s = this._config.filterFn;
    this._optionsToRender.forEach((r) => {
      const l = r.hasOwnProperty("options"), c = !l && r.label.toLowerCase().includes(t.toLowerCase()), d = {};
      l && (d.label = r.label, d.options = this._filter(t, r.options), d.options.length > 0 && e.push(d)), s && !l ? s(t, r) && e.push(r) : c && e.push(r);
    });
    const n = this._config.noResultText !== "", o = e.length !== 0;
    if (o)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!o && n) {
      const r = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = r;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = u.findOne(yl, this._dropdownContainer) || u.findOne(fT, this._dropdownContainer), s = pd(
      t,
      this._selectAllOption,
      this._config
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(s);
  }
  _getNoResultTemplate() {
    return `<div class="select-no-results" style="height: ${this._config.optionHeight}px">${this._config.noResultText}</div>`;
  }
  _filter(t, e) {
    const s = this._config.filterFn;
    if (s)
      return e.filter((o) => s(t, o));
    const n = t.toLowerCase();
    return e.filter((o) => o.label.toLowerCase().includes(n));
  }
  _listenToDropdownKeydown() {
    h.on(this.dropdown, "keydown", this._handleOpenKeydown.bind(this));
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), h.on(document, "click", this._outsideClick);
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), s = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = u.find(mT)), this._elementToggle && this._elementToggle.forEach((r) => {
      const l = a.getDataAttribute(r, "toggle");
      (l === this._element.id || this._element.classList.contains(l)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !s && !n && !o && this.close();
  }
  close() {
    const t = h.trigger(this._element, iT);
    !this._isOpen || t.defaultPrevented || (this._config.filter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), a.removeClass(this.dropdown, Sl), setTimeout(() => {
      a.removeClass(this._input, wl), this._label && !this.hasSelection && (a.removeClass(this._label, Ft), a.removeClass(this._input, Ft)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, h.off(this.dropdown, "transitionend"), h.trigger(this._element, aT);
    }, vT));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    h.off(document, "click", this._outsideClick), this._config.filter && h.off(this.dropdown, "keydown"), h.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = bl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent
    );
  }
  _updateDisabledState() {
    const t = u.findOne(Cl, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", "")) : (this._config.disabled = !1, t.removeAttribute("disabled"));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this._mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, s = !0, n = "select-all", o = this._config.selectAllLabel, r = fo(this.options), l = !1, c = !1, d = null, p = null, f = null;
    return new gl(
      t,
      e,
      s,
      n,
      o,
      r,
      l,
      c,
      d,
      p,
      f
    );
  }
  dispose() {
    this._disconnectMutationObserver(), this._removeComponentEvents(), this._disconnectMutationObserver(), this._destroyMaterialSelect(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  _removeComponentEvents() {
    h.off(this.input, "click"), h.off(this.wrapper, this._handleKeydown.bind(this)), h.off(this.clearButton, "click"), h.off(this.clearButton, "keydown"), h.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = u.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((s) => {
      t.appendChild(s);
    }), e.forEach((s) => {
      a.removeClass(s, Ft);
    }), a.removeClass(this._element, In), this._customContent && t.appendChild(this._customContent), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((s) => s.selected).forEach((s) => s.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((s) => {
      this._selectByValue(s);
    }) : this._selectByValue(t), this._updateSelections();
  }
  _selectByValue(t) {
    const e = this.options.find((s) => s.value === t);
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, gd);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Xo(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const mo = "datatable", bd = `mdb.${mo}`, ET = "datatable", Ol = "fixed-cell", TT = ".datatable-inner", kn = "td", CT = ".datatable-header th", yT = ".datatable-header-checkbox", AT = ".datatable-pagination-right", ST = ".datatable-pagination-left", wT = ".datatable-pagination-start", OT = ".datatable-pagination-end", $T = ".datatable-pagination-nav", DT = ".datatable-select", Mn = ".datatable-sort-icon", fi = ".datatable-body tr", xn = ".datatable-row-checkbox", Xs = `.${bd}`, NT = `rowSelected${Xs}`, $l = `render${Xs}`, LT = `rowClicked${Xs}`, IT = `update${Xs}`, Dl = "valueChanged.mdb.select", kT = {
  bordered: "boolean",
  borderless: "boolean",
  borderColor: "(string|null)",
  clickableRows: "boolean",
  color: "(string|null)",
  defaultValue: "string",
  edit: "boolean",
  entries: "(number|string)",
  entriesOptions: "array",
  fullPagination: "boolean",
  hover: "boolean",
  loading: "boolean",
  loadingMessage: "string",
  maxWidth: "(null|number|string)",
  maxHeight: "(null|number|string)",
  multi: "boolean",
  noFoundMessage: "string",
  pagination: "boolean",
  selectable: "boolean",
  sm: "boolean",
  sortField: "(null|string)",
  sortOrder: "string",
  loaderClass: "string",
  fixedHeader: "boolean",
  striped: "boolean",
  rowsText: "string",
  ofText: "string",
  allText: "string",
  forceSort: "boolean"
}, MT = {
  label: "string",
  field: "string",
  fixed: "(boolean|string)",
  format: "(function|null)",
  width: "(number|null)",
  sort: "boolean",
  columnIndex: "number"
}, xT = {
  bordered: !1,
  borderless: !1,
  borderColor: null,
  clickableRows: !1,
  color: null,
  dark: !1,
  defaultValue: "-",
  edit: !1,
  entries: 10,
  entriesOptions: [10, 25, 50, 200],
  fixedHeader: !1,
  fullPagination: !1,
  hover: !1,
  loaderClass: "bg-primary",
  loading: !1,
  loadingMessage: "Loading results...",
  maxWidth: null,
  maxHeight: null,
  multi: !1,
  noFoundMessage: "No matching results found",
  pagination: !0,
  selectable: !1,
  sm: !1,
  sortField: null,
  sortOrder: "asc",
  striped: !1,
  rowsText: "Rows per page:",
  ofText: "of",
  allText: "All",
  forceSort: !1
}, RT = {
  label: "",
  field: "",
  fixed: !1,
  format: null,
  width: null,
  sort: !0,
  columnIndex: 0
};
class vd extends F {
  constructor(t, e = {}, s = {}) {
    super(t), this._options = this._getOptions(s), this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (this._perfectScrollbar = null, this._setup(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return mo;
  }
  get columns() {
    return this._columns.map((t, e) => {
      let s = {
        ...RT,
        field: `field_${e}`,
        columnIndex: e
      };
      return typeof t == "string" ? s.label = t : typeof t == "object" && (s = {
        ...s,
        ...t
      }), Y("column", s, MT), s;
    });
  }
  get rows() {
    return this._rows.map((t, e) => {
      const s = {
        rowIndex: e
      };
      return Array.isArray(t) ? this.columns.forEach((n, o) => {
        t[o] === 0 ? s[n.field] = t[o] : s[n.field] = t[o] || this._options.defaultValue;
      }) : typeof t == "object" && this.columns.forEach((n) => {
        t[n.field] === 0 ? s[n.field] = t[n.field] : s[n.field] = t[n.field] || this._options.defaultValue;
      }), s;
    });
  }
  get searchResult() {
    return WE(this.rows, this._search, this._searchColumn);
  }
  get computedRows() {
    let t = [...this.searchResult];
    return this._options.sortOrder && (t = VE({
      rows: t,
      field: this._options.sortField,
      order: this._options.sortOrder
    })), this._options.pagination && (this._options.entries === "All" ? t = _l({
      rows: t,
      entries: t.length,
      activePage: this._activePage
    }) : t = _l({
      rows: t,
      entries: this._options.entries,
      activePage: this._activePage
    })), t;
  }
  get pages() {
    return this._options.entries === "All" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);
  }
  get navigationText() {
    const t = this._activePage * this._options.entries;
    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === "All" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;
  }
  get classNames() {
    return [
      ET,
      this._options.color,
      this._options.borderColor && `border-${this._options.borderColor}`,
      this._options.dark && "datatable-dark",
      this._options.hover && "datatable-hover",
      this._options.bordered && "datatable-bordered",
      this._options.borderless && "datatable-borderless",
      this._options.sm && "datatable-sm",
      this._options.striped && "datatable-striped",
      this._options.loading && "datatable-loading",
      this._options.clickableRows && "datatable-clickable-rows"
    ].filter((t) => t);
  }
  get tableOptions() {
    return {
      columns: this.columns,
      rows: this.computedRows,
      noFoundMessage: this._options.noFoundMessage,
      edit: this._options.edit,
      loading: this._options.loading,
      loaderClass: this._options.loaderClass,
      loadingMessage: this._options.loadingMessage,
      selectable: this._options.selectable,
      multi: this._options.multi,
      pagination: {
        enable: this._options.pagination,
        text: this.navigationText,
        entries: this._options.entries,
        entriesOptions: this._options.entriesOptions,
        fullPagination: this._options.fullPagination,
        rowsText: this._options.rowsText,
        ofText: this._options.ofText,
        allText: this._options.allText
      },
      forceSort: this._options.forceSort
    };
  }
  // Public
  update(t, e = {}) {
    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();
  }
  dispose() {
    this._selectInstance && this._selectInstance.dispose(), this._removeEventListeners(), this._perfectScrollbar.destroy(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  search(t, e) {
    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());
  }
  sort(t, e = "asc") {
    this._options.sortOrder = e, typeof t == "string" ? this._options.sortField = this.columns.find((n) => n.label === t).field : this._options.sortField = t.field;
    const s = u.findOne(
      `i[data-mdb-sort="${this._options.sortField}"]`,
      this._element
    );
    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(s);
  }
  setActivePage(t) {
    t < this.pages && this._changeActivePage(t);
  }
  // Private
  _changeActivePage(t) {
    this._activePage = t, this._toggleDisableState(), this._renderRows();
  }
  _clearClassList(t) {
    this._options.color && t.color && a.removeClass(this._element, this._options.color), this._options.borderColor && t.borderColor && a.removeClass(this._element, `border-${this._options.borderColor}`), ["dark", "hover", "bordered", "borderless", "sm", "striped", "loading"].forEach((e) => {
      this._options[e] && !t[e] && a.removeClass(this._element, `datatable-${e}`);
    });
  }
  _emitSelectEvent() {
    h.trigger(this._element, NT, {
      selectedRows: this.rows.filter((t) => this._selected.indexOf(t.rowIndex) !== -1),
      selectedIndexes: this._selected,
      allSelected: this._selected.length === this.rows.length
    });
  }
  _getRows(t = []) {
    const e = u.findOne("tbody", this._element);
    return e ? [...u.find("tr", e).map((n) => u.find("td", n).map((o) => o.innerHTML)), ...t] : t;
  }
  _getColumns(t = []) {
    const e = u.findOne("thead", this._element);
    if (!e)
      return t;
    const s = u.findOne("tr", e);
    return [...u.find("th", s).map((o) => ({
      label: o.innerHTML,
      ...a.getDataAttributes(o)
    })), ...t];
  }
  _getCSSValue(t) {
    return typeof t == "string" ? t : `${t}px`;
  }
  _getOptions(t) {
    const e = {
      ...xT,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(mo, e, kT), e;
  }
  _setActiveRows() {
    u.find(fi, this._element).forEach((t) => {
      this._selected.includes(a.getDataAttribute(t, "index")) ? a.addClass(t, "active") : a.removeClass(t, "active");
    });
  }
  _setEntries(t) {
    this._options = this._getOptions({ ...this._options, entries: t.target.value }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();
  }
  _setSelected() {
    u.find(xn, this._element).forEach((t) => {
      const e = a.getDataAttribute(t, "rowIndex");
      t.checked = this._selected.includes(e);
    }), this._setActiveRows();
  }
  _setActiveSortIcon(t) {
    u.find(Mn, this._element).forEach((e) => {
      const s = this._options.sortOrder === "desc" && e === t ? 180 : 0;
      a.style(e, {
        transform: `rotate(${s}deg)`
      }), e === t && this._options.sortOrder ? a.addClass(e, "active") : a.removeClass(e, "active");
    });
  }
  _setClassNames() {
    this.classNames.forEach((t) => {
      a.addClass(this._element, t);
    });
  }
  _setup() {
    this._setClassNames(), this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();
  }
  _setupClickableRows() {
    u.find(fi, this._element).forEach((t) => {
      const e = a.getDataAttribute(t, "index");
      h.on(t, "click", (s) => {
        u.matches(s.target, xn) || h.trigger(this._element, LT, { index: e, row: this.rows[e] });
      });
    });
  }
  _setupEditable() {
    u.find(fi, this._element).forEach((t) => {
      const e = a.getDataAttribute(t, "index");
      u.find(kn, t).forEach((s) => {
        h.on(s, "input", (n) => this._updateRow(n, e));
      });
    });
  }
  _setupScroll() {
    const t = u.findOne(TT, this._element), e = {
      overflow: "auto",
      position: "relative"
    };
    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {
      const s = this._getCSSValue(this._options.maxWidth);
      e.maxWidth = s, a.style(this._element, { maxWidth: s });
    }
    if (a.style(t, e), this._options.fixedHeader) {
      let s = u.find(CT, this._element);
      this._options.selectable && (s = s.filter((n, o) => (a.addClass(n, Ol), this._options.color && a.addClass(n, this._options.color), o !== 0))), s.forEach((n, o) => {
        a.addClass(n, Ol), this.columns[o].fixed && a.addStyle(n, { zIndex: 4 }), this._options.color && a.addClass(n, this._options.color);
      });
    }
    this._perfectScrollbar = new Uh(t);
  }
  _setupSort() {
    u.find(Mn, this._element).forEach((t) => {
      const e = a.getDataAttribute(t, "sort"), [s] = u.parents(t, "th");
      a.style(s, { cursor: "pointer" }), e === this._options.sortField && this._setActiveSortIcon(t), h.on(s, "click", () => {
        this._options.sortField === e && this._options.sortOrder === "asc" ? this._options.sortOrder = "desc" : this._options.sortField === e && this._options.sortOrder === "desc" ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);
      });
    });
  }
  _performSort() {
    this._toggleDisableState(), this._renderRows();
  }
  _setupSelectable() {
    this._checkboxes = u.find(xn, this._element), this._headerCheckbox = u.findOne(yT, this._element), h.on(this._headerCheckbox, "input", (t) => this._toggleSelectAll(t)), this._checkboxes.forEach((t) => {
      const e = a.getDataAttribute(t, "rowIndex");
      h.on(t, "input", (s) => this._toggleSelectRow(s, e));
    });
  }
  _setupPagination() {
    this._paginationRight = u.findOne(AT, this._element), this._paginationLeft = u.findOne(ST, this._element), h.on(
      this._paginationRight,
      "click",
      () => this._changeActivePage(this._activePage + 1)
    ), h.on(
      this._paginationLeft,
      "click",
      () => this._changeActivePage(this._activePage - 1)
    ), this._options.fullPagination && (this._paginationStart = u.findOne(wT, this._element), this._paginationEnd = u.findOne(OT, this._element), h.on(this._paginationStart, "click", () => this._changeActivePage(0)), h.on(this._paginationEnd, "click", () => this._changeActivePage(this.pages - 1))), this._toggleDisableState(), this._setupPaginationSelect();
  }
  _setupPaginationSelect() {
    this._select = u.findOne(DT, this._element), this._selectInstance && this._selectInstance.dispose(), this._selectInstance = new Xo(this._select), h.on(this._select, Dl, (t) => this._setEntries(t));
  }
  _removeEventListeners() {
    this._options.pagination && (h.off(this._paginationRight, "click"), h.off(this._paginationLeft, "click"), h.off(this._select, Dl), this._options.fullPagination && (h.off(this._paginationStart, "click"), h.off(this._paginationEnd, "click"))), this._options.editable && u.find(kn, this._element).forEach((t) => {
      h.off(t, "input");
    }), this._options.clickableRows && u.find(fi, this._element).forEach((t) => {
      h.off(t, "click");
    }), u.find(Mn, this._element).forEach((t) => {
      const [e] = u.parents(t, "th");
      h.off(e, "click");
    }), this._options.selectable && (h.off(this._headerCheckbox, "input"), this._checkboxes.forEach((t) => {
      h.off(t, "input");
    }));
  }
  _renderTable() {
    this._element.innerHTML = pl(this.tableOptions).table, this._formatCells(), h.trigger(this._element, $l);
  }
  _renderRows() {
    const t = u.findOne("tbody", this._element);
    if (this._options.pagination) {
      const e = u.findOne($T, this._element);
      e.innerText = this.navigationText;
    }
    t.innerHTML = pl(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), h.trigger(this._element, $l);
  }
  _formatCells() {
    u.find(fi, this._element).forEach((e) => {
      const s = a.getDataAttribute(e, "index");
      u.find(kn, e).forEach((o) => {
        const r = a.getDataAttribute(o, "field"), l = this.columns.find((c) => c.field === r);
        l && l.format !== null && l.format(o, this.rows[s][r]);
      });
    });
  }
  _toggleDisableState() {
    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute("disabled", !0), this._options.fullPagination && this._paginationStart.setAttribute("disabled", !0)) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute("disabled", !0), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", !0)) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")));
  }
  _toggleSelectAll(t) {
    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();
  }
  _toggleSelectRow(t, e) {
    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((s) => {
      s !== t.target && (s.checked = !1);
    })) : this._selected = this._selected.filter((s) => s !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();
  }
  _updateRow(t, e) {
    const s = a.getDataAttribute(t.target, "field"), n = t.target.textContent, o = this._rows[e];
    if (Array.isArray(o)) {
      const l = this.columns.find((c) => c.field === s).columnIndex;
      o[l] = n;
    } else
      o[s] = n;
    h.trigger(this._element, IT, {
      rows: this._rows,
      columns: this._columns
    });
  }
  static jQueryInterface(t, e, s) {
    return this.each(function() {
      let n = P.getData(this, bd);
      const o = typeof t == "object" && t;
      if (!(!n && /dispose/.test(t)) && (n || (n = new vd(this, o, e)), typeof t == "string")) {
        if (typeof n[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        n[t](e, s);
      }
    });
  }
}
const U = "stepper", Ed = "mdb.stepper", Wt = `.${Ed}`, Xe = "horizontal", Ct = "vertical", gt = "mobile", PT = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number",
  animations: "boolean",
  stepperHeadClick: "boolean",
  stepperMobileNextBtn: "string",
  stepperMobileBackBtn: "string",
  stepperMobileStepTxt: "string",
  stepperMobileOfTxt: "string"
}, HT = {
  stepperType: Xe,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4,
  animations: !0,
  stepperHeadClick: !0,
  stepperMobileNextBtn: "NEXT",
  stepperMobileBackBtn: "BACK",
  stepperMobileStepTxt: "step",
  stepperMobileOfTxt: "of"
}, Rn = `mousedown${Wt}`, BT = `submit${Wt}`, Nl = `keydown${Wt}`, VT = `keyup${Wt}`, Ll = `resize${Wt}`, hs = `click${Wt}`, Il = "animationend", WT = `stepChange${Wt}`, YT = `stepChanged${Wt}`, kl = `stepInvalid${Wt}`, FT = `stepValid${Wt}`, pe = `${U}-step`, st = `${U}-head`, KT = `${U}-head-text`, mt = `${U}-content`, xe = `${U}-active`, Ml = `${U}-completed`, xl = `${U}-invalid`, Rl = `${U}-disabled`, Pn = `${U}-${Ct}`, Hn = `${U}-content-hide`, Pl = `${U}-${Xe}`, Hl = `${U}-${gt}`, go = `${U}-${gt}-head`, Os = `${U}-${gt}-footer`, Td = `${U}-${gt}-progress-bar`, zT = `${U}-${gt}-progress`, bo = `${U}-next-btn`, vo = `${U}-back-btn`, Eo = `${U}-active-step`, Cd = `${U}-all-steps`, XT = (i) => `
  <div class="${bo}">
    <button type="button" class="btn btn-link">
      ${i.stepperMobileNextBtn}
      <i class="fas fa-chevron-right"></i>
    </button>
  </div>
`, jT = (i) => `
  <div class="${vo}">
    <button type="button" class="btn btn-link">
      <i class="fas fa-chevron-left"></i>
      ${i.stepperMobileBackBtn}
    </button>
  </div>
`, UT = (i) => `
  <div class ="${go}">
    ${i.stepperMobileStepTxt} <span id="${Eo}"></span> ${i.stepperMobileOfTxt} <span id="${Cd}"></span>
  </div>
`, GT = `
  <div class="${zT} gray-500">
    <div class="${Td}"></div>
  </div>
`, qT = `
  <div class="${Os}"></div>
`;
class yd extends F {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this._elementHeight = 0, this._steps = u.find(`.${pe}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._element && (this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return U;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      h.off(t, Rn), h.off(t, Nl);
    }), h.off(window, Ll), this._unbindMouseDown(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  prevStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  resizeStepper() {
    this._currentView === Ct && this._setSingleStepHeight(this.activeStep), this._currentView === Xe && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
  }
  // Private
  _init() {
    const t = u.findOne(`.${xe}`, this._element);
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperActive)) : (this._toggleStepClass(this._activeStepIndex, "add", xe), this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperActive)), this._setOptional(), this._options.stepperHeadClick && this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case Ct:
        this._toggleVertical();
        break;
      case gt:
        this._toggleMobile();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._options.stepperLinear && this._setValidation(), this._bindResize();
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...HT,
      ...e,
      ...t
    }, Y(U, t, PT), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = u.findOne(`.${st}`, t);
      h.on(e, Rn, (s) => {
        const n = u.parents(s.target, `.${pe}`)[0], o = this._steps.indexOf(n);
        s.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _unbindMouseDown() {
    this._steps.forEach((t) => {
      const e = u.findOne(`.${st}`, t);
      h.off(e, Rn);
    });
  }
  _bindResize() {
    h.on(window, Ll, () => {
      this.resizeStepper();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, s = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== Xe && this._toggleHorizontal(), e && !s && this._currentView !== Ct && (this._steps.forEach((n) => {
      const o = u.findOne(`.${mt}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical()), s && this._currentView !== gt && this._toggleMobile();
  }
  _toggleStep(t) {
    const e = this._steps.length, s = this._validateStep(t), n = this._activeStepIndex;
    if (!s)
      return;
    if (this._options.stepperLinear && h.trigger(this.activeStep, FT, {
      currentStep: this._activeStepIndex,
      nextStep: t
    }), this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(u.findOne(`.${mt}`, this._steps[t])), this._toggleActive(t), (!this._options.stepperLinear || t > this._activeStepIndex) && this._toggleCompleted(this._activeStepIndex), this._currentView === Xe || this._currentView === gt ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      u.findOne(`.${st}`, this.activeStep),
      u.findOne(`.${st}`, this._steps[t])
    ), this._activeStepIndex = t, this._currentView === gt) {
      const l = u.findOne(`#${Eo}`, this._element);
      l.textContent = this._activeStepIndex + 1, e > this._options.stepperMobileBarBreakpoint && this._updateProgressBar();
    }
    const o = this.activeStep.querySelectorAll(".form-outline"), r = u.find(".form-notch", o[0]);
    o.length && r.length < 1 && o.forEach((l) => {
      new mdb.Input(l).init();
    }), h.trigger(this.activeStep, YT, {
      currentStep: this._activeStepIndex,
      prevStep: n
    });
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = u.findOne(`.${mt}`, t), s = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(s.paddingTop),
        paddingBottom: parseFloat(s.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = u.findOne(`.${mt}`, t), s = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    s ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _createMobileElements() {
    this._element.insertAdjacentHTML("beforeend", qT);
    const t = u.findOne(`.${Os}`, this._element);
    this._steps.length > this._options.stepperMobileBarBreakpoint && (this._element.classList.add("stepper-progress-bar"), t.insertAdjacentHTML("afterbegin", GT), this._updateProgressBar()), t.insertAdjacentHTML("afterbegin", jT(this._options)), t.insertAdjacentHTML("beforeend", XT(this._options)), this._element.insertAdjacentHTML("afterbegin", UT(this._options));
    const e = u.findOne(`#${Cd}`, this._element);
    e.textContent = this._steps.length;
    const s = u.findOne(`#${Eo}`, this._element);
    s.textContent = this._activeStepIndex + 1;
  }
  _toggleMobile() {
    this._currentView = gt, this._toggleStepperClass(Hl), this._createMobileElements(), this._bindMobileButtons(), this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleVertical() {
    this._currentView === gt && (this._deleteMobileElements(), this._unbindMobileButtons()), this._currentView = Ct, this._toggleStepperClass(Pn), this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView === gt && (this._deleteMobileElements(), this._unbindMobileButtons()), this._currentView = Xe, this._toggleStepperClass(Pl), this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass(t) {
    this._element.classList.remove(Pl, Hl, Pn), this._element.classList.add(t), t !== Pn && this._steps.forEach((e) => {
      u.findOne(`.${mt}`, e).classList.remove(Hn);
    });
  }
  _toggleStepClass(t, e, s) {
    s && this._steps[t].classList[e](s);
  }
  _deleteMobileElements() {
    const t = u.findOne(`.${Os}`, this._element), e = u.findOne(`.${go}`, this._element);
    t.remove(), e.remove();
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(!1, u.findOne(`.${st}`, this.activeStep)), this._steps.forEach((t) => {
      const e = u.findOne(`.${st}`, t);
      h.on(e, Nl, (s) => {
        const n = u.parents(s.currentTarget, `.${pe}`)[0], o = u.next(n, `.${pe}`)[0], r = u.prev(n, `.${pe}`)[0], l = u.findOne(`.${st}`, n), c = u.findOne(`.${st}`, this.activeStep);
        let d = null, p = null;
        if (o && (d = u.findOne(`.${st}`, o)), r && (p = u.findOne(`.${st}`, r)), s.keyCode === Ue && this._currentView !== Ct && (!B && p ? (this._toggleStepTabIndex(l, p), this._toggleOutlineStyles(l, p), p.focus()) : B && d && (this._toggleStepTabIndex(l, d), this._toggleOutlineStyles(l, d), d.focus())), s.keyCode === Ge && this._currentView !== Ct && (!B && d ? (this._toggleStepTabIndex(l, d), this._toggleOutlineStyles(l, d), d.focus()) : B && p && (this._toggleStepTabIndex(l, p), this._toggleOutlineStyles(l, p), p.focus())), s.keyCode === J && this._currentView === Ct && (s.preventDefault(), d && (this._toggleStepTabIndex(l, d), this._toggleOutlineStyles(l, d), d.focus())), s.keyCode === tt && this._currentView === Ct && (s.preventDefault(), p && (this._toggleStepTabIndex(l, p), this._toggleOutlineStyles(l, p), p.focus())), s.keyCode === ve) {
          const f = u.findOne(`.${st}`, this._steps[0]);
          this._toggleStepTabIndex(l, f), this._toggleOutlineStyles(l, f), f.focus();
        }
        if (s.keyCode === Ee) {
          const f = this._steps[this._steps.length - 1], m = u.findOne(`.${st}`, f);
          this._toggleStepTabIndex(l, m), this._toggleOutlineStyles(l, m), m.focus();
        }
        (s.keyCode === ot || s.keyCode === Es) && (s.preventDefault(), this.changeStep(this._steps.indexOf(n))), s.keyCode === Se && (this._toggleStepTabIndex(l, c), this._toggleOutlineStyles(l, !1), c.focus());
      }), h.on(e, VT, (s) => {
        const n = u.parents(s.currentTarget, `.${pe}`)[0], o = u.findOne(`.${st}`, n), r = u.findOne(`.${st}`, this.activeStep);
        s.keyCode === Se && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _bindMobileButtons() {
    const t = u.findOne(`.${vo}`, this._element), e = u.findOne(`.${bo}`, this._element);
    h.on(t, hs, () => this.prevStep()), h.on(e, hs, () => this.nextStep());
  }
  _unbindMobileButtons() {
    const t = u.findOne(`.${vo}`, this._element), e = u.findOne(`.${bo}`, this._element);
    h.off(t, hs, () => this.prevStep()), h.off(e, hs, () => this.nextStep());
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _validateActiveStepRequiredElements() {
    return u.find("[required]", this.activeStep).every((e) => e.checkValidity() === !0);
  }
  _validateStep(t) {
    const e = this._steps.length;
    let s = !0;
    t === this._activeStepIndex && (s = !1), (t >= e || t < 0) && (s = !1);
    const n = h.trigger(this.activeStep, WT, {
      currentStep: this._activeStepIndex,
      nextStep: t
    });
    if (this._options.stepperLinear) {
      const o = t - this.activeStepIndex - 1;
      if (t > this._activeStepIndex + 1) {
        let r = u.next(this.activeStep, "li")[0];
        for (let l = 0; l < o; l++)
          r.classList.contains("stepper-completed") || (r.classList.add("stepper-invalid"), s = !1), r = u.next(r, "li")[0];
      }
      t < this._activeStepIndex && (this._validateActiveStepRequiredElements() || this.activeStep.classList.remove("stepper-completed")), (t > this._activeStepIndex || t === e - 1) && (this.activeStep.classList.add("was-validated"), this._validateActiveStepRequiredElements() || (this._toggleInvalid(this._activeStepIndex), h.trigger(this.activeStep, kl, {
        currentStep: this._activeStepIndex,
        nextStep: t
      }), this._currentView !== Ct ? setTimeout(() => {
        this._setHeight(this.activeStep);
      }, 210) : setTimeout(() => {
        this._setSingleStepHeight(this.activeStep);
      }, 210), s = !1));
    }
    return t > this._activeStepIndex && n.defaultPrevented && (s = !1), this._options.stepperNoEditable && this._steps[t].classList.contains(Rl) && (s = !1), s;
  }
  _updateProgressBar() {
    const t = this._steps.length, e = u.findOne(`.${Td}`, this._element);
    e.style.width = `${(this._activeStepIndex + 1) / t * 100}%`;
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    this._toggleStepClass(this._activeStepIndex, "add", Rl), this._toggleStepClass(this._activeStepIndex, "add", this._options.stepperDisabled);
  }
  _toggleActive(t) {
    this._toggleStepClass(t, "add", xe), this._toggleStepClass(this._activeStepIndex, "remove", xe), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(this._activeStepIndex, "remove", this._options.stepperActive);
  }
  _toggleCompleted(t) {
    this._toggleStepClass(t, "add", Ml), this._toggleStepClass(t, "remove", xl), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _toggleInvalid(t) {
    this._toggleStepClass(t, "add", xl), this._toggleStepClass(t, "remove", Ml), this._toggleStepClass(t, "add", this._options.stepperInvalid), this._toggleStepClass(t, "remove", this._options.stepperCompleted);
  }
  _setOptional() {
    this._steps.forEach((t) => {
      a.getDataAttribute(t, "stepper-optional") && u.findOne(`.${KT}`, t).setAttribute("data-mdb-content", "Optional");
    });
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      t.classList.contains(xe) || this._hideElement(u.findOne(`.${mt}`, t));
    });
  }
  _setValidation() {
    const t = u.findOne(".needs-validation.stepper-form", this._element);
    h.on(
      t,
      BT,
      (e) => {
        t.checkValidity() || (e.preventDefault(), e.stopPropagation()), this._steps.forEach((s, n) => {
          this._validateStep(n) || (this._toggleInvalid(n), h.trigger(this.activeStep, kl));
        });
      },
      !1
    );
  }
  _setHeight(t) {
    const e = u.findOne(`.${mt}`, t), s = u.findOne(`.${Os}`, this._element), n = getComputedStyle(e), o = s ? getComputedStyle(s) : "";
    let r;
    this._currentView === gt ? r = u.findOne(`.${go}`, this._element) : r = u.findOne(`.${st}`, t);
    const l = getComputedStyle(r), c = e.offsetHeight + parseFloat(n.marginTop) + parseFloat(n.marginBottom), d = r.offsetHeight + parseFloat(l.marginTop) + parseFloat(l.marginBottom), p = o ? s.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom) : 0;
    this._element.style.height = `${d + c + p}px`;
  }
  _hideElement(t) {
    !u.parents(t, `.${pe}`)[0].classList.contains(
      xe
    ) && this._currentView !== Ct ? t.style.display = "none" : t.classList.add(Hn);
  }
  _showElement(t) {
    this._currentView === Ct ? t.classList.remove(Hn) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    if (!this._animations) {
      this._steps.forEach((l, c) => {
        const d = u.findOne(`.${mt}`, l);
        c !== t && this._hideElement(d);
      }), this._setHeight(this._steps[t]);
      return;
    }
    const e = t > this._activeStepIndex, s = u.findOne(`.${mt}`, this._steps[t]), n = u.findOne(`.${mt}`, this.activeStep);
    let o, r;
    this._steps.forEach((l, c) => {
      const d = u.findOne(`.${mt}`, l);
      this._clearStepAnimation(d), c !== t && c !== this._activeStepIndex && this._hideElement(d);
    }), e ? (r = "slide-out-left", o = "slide-in-right") : (r = "slide-out-right", o = "slide-in-left"), this._animations && (n.classList.add(r, "animation", "fast"), s.classList.add(o, "animation", "fast")), this._setHeight(this._steps[t]), h.one(n, Il, (l) => {
      this._clearStepAnimation(l.target), this._hideElement(l.target);
    }), h.one(s, Il, (l) => {
      this._clearStepAnimation(l.target);
    });
  }
  _animateVerticalStep(t) {
    const e = u.findOne(`.${mt}`, this._steps[t]), s = u.findOne(`.${mt}`, this.activeStep);
    this._hideElement(s), this._showElement(e);
  }
  _clearStepAnimation(t) {
    t.classList.remove(
      "slide-out-left",
      "slide-in-right",
      "slide-out-right",
      "slide-in-left",
      "animation",
      "fast"
    );
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Ed);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose|hide/.test(t)) && (s || (s = new yd(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const Bl = "sticky", Ad = "mdb.sticky", Vl = "animation", Sd = `.${Ad}`, QT = `activated${Sd}`, ZT = `deactivated${Sd}`, JT = {
  stickyActiveClass: "",
  stickyAnimationSticky: "",
  stickyAnimationUnsticky: "",
  stickyBoundary: !1,
  stickyDelay: 0,
  stickyDirection: "down",
  stickyMedia: 0,
  stickyOffset: 0,
  stickyPosition: "top"
}, tC = {
  stickyActiveClass: "string",
  stickyAnimationSticky: "string",
  stickyAnimationUnsticky: "string",
  stickyBoundary: "(boolean|string)",
  stickyDelay: "number",
  stickyDirection: "string",
  stickyMedia: "number",
  stickyOffset: "number",
  stickyPosition: "string"
};
class wd extends F {
  constructor(t, e) {
    super(t), this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = "", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = "", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return Bl;
  }
  // Public
  dispose() {
    const { stickyAnimationUnsticky: t } = this._options;
    let { animationDuration: e } = getComputedStyle(this._element);
    e = t !== "" ? parseFloat(e) * 1e3 : 0, this._disableSticky(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), setTimeout(() => {
      super.dispose();
    }, e);
  }
  activate() {
    this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1);
  }
  deactivate() {
    this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0);
  }
  // Private
  _init() {
    this._userActivityListener();
  }
  _userActivityListener() {
    h.on(window, "resize", () => {
      this._updateElementPosition(), this._updateElementOffset();
    }), h.on(window, "scroll", () => {
      if (!this._element || window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated)
        return;
      const t = document.documentElement, { stickyDirection: e } = this._options, s = window.pageYOffset || t.scrollTop;
      this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(s), this._clearInProgressAnimations();
      const n = [this._scrollDirection, "both"].includes(e), o = this._pushPoint <= s, r = o && !this._isSticked && n, l = (!o || !n) && this._isSticked;
      r && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), l && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({ styles: this._elementPositionStyles }), this._changeBoundaryPosition()), this._scrollTop = s <= 0 ? 0 : s;
    });
  }
  _updatePushPoint() {
    this._options.stickyPosition === "top" ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay;
  }
  _updateElementOffset() {
    this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0);
  }
  _updateElementPosition() {
    if (this._hiddenElement) {
      const { left: t } = this._hiddenElement.getBoundingClientRect();
      this._elementPositionStyles = {
        left: `${t}px`
      };
    } else
      this._elementPositionStyles = {};
    this._setStyle(this._element, this._elementPositionStyles);
  }
  _updateScrollDirection(t) {
    t > this._scrollTop ? this._scrollDirection = "down" : this._scrollDirection = "up";
  }
  _clearInProgressAnimations() {
    const t = this._scrollDirection === "up", e = this._element.classList.contains(
      this._options.stickyAnimationUnsticky
    ), s = window.scrollY <= this._elementOffsetTop - this._element.height;
    t && e && s && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement());
  }
  _enableSticky() {
    const {
      stickyActiveClass: t,
      stickyAnimationSticky: e,
      stickyAnimationUnsticky: s,
      stickyOffset: n,
      stickyPosition: o
    } = this._options, { height: r, left: l, width: c } = this._element.getBoundingClientRect();
    e !== "" && (a.addClass(this._element, Vl), this._toggleClass(e, s, this._element)), this._toggleClass(t, "", this._element), this._setStyle(this._element, {
      top: o === "top" && `${0 + n}px`,
      bottom: o === "bottom" && `${0 + n}px`,
      height: `${r}px`,
      width: `${c}px`,
      left: `${l}px`,
      zIndex: "100",
      position: "fixed"
    }), this._hiddenElement.hidden = !1, h.trigger(this._element, QT);
  }
  _changeBoundaryPosition() {
    const { stickyPosition: t, stickyBoundary: e, stickyOffset: s } = this._options, { height: n } = this._element.getBoundingClientRect(), o = {
      height: this._element.parentElement.getBoundingClientRect().height,
      ...this._getOffset(this._element.parentElement)
    };
    let r;
    const l = u.findOne(e);
    l ? r = this._getOffset(l).top - n - s : r = o.height + o[t] - n - s;
    const c = t === "top", d = t === "bottom", p = e, f = r < 0, m = r > o.height - n;
    let g;
    c && (f && p ? g = { top: `${s + r}px` } : g = { top: `${s + 0}px` }), d && (f && p ? g = { bottom: `${s + r}px` } : m && p ? g = { bottom: `${s + o.bottom}px` } : g = { bottom: `${s + 0}px` }), this._setStyle(this._element, g);
  }
  _disableSticky() {
    const { stickyActiveClass: t, stickyAnimationUnsticky: e, stickyAnimationSticky: s } = this._options;
    let { animationDuration: n } = getComputedStyle(this._element);
    n = e !== "" ? parseFloat(n) * 1e3 : 0, this._options.stickyAnimationUnsticky !== "" && (a.addClass(this._element, Vl), this._toggleClass(e, s, this._element)), setTimeout(() => {
      this._element.classList.contains(s) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass("", t, this._element), h.trigger(this._element, ZT));
    }, n);
  }
  _createHiddenElement() {
    this._hiddenElement || (this._hiddenElement = this._copyElement(this._element));
  }
  _removeHiddenElement() {
    this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null);
  }
  _removeUnstickyAnimation() {
    this._toggleClass("", this._options.stickyAnimationUnsticky, this._element);
  }
  _resetStyles() {
    this._setStyle(this._element, {
      top: null,
      bottom: null,
      position: null,
      left: null,
      zIndex: null,
      width: null,
      height: null
    });
  }
  _updatePosition({ styles: t }) {
    this._setStyle(this._element, t);
  }
  _toggleClass(t, e, s) {
    t && a.addClass(s, t), e && a.removeClass(s, e);
  }
  _getOffset(t) {
    const e = a.offset(t), s = t.getBoundingClientRect(), n = e.left === 0 && e.top === 0 ? 0 : window.innerHeight - s.bottom;
    return {
      ...e,
      bottom: n
    };
  }
  _copyElement(t) {
    const { height: e, width: s } = t.getBoundingClientRect(), n = t.cloneNode(!1);
    return n.hidden = !0, this._setStyle(n, {
      height: `${e}px`,
      width: `${s}px`,
      opacity: "0"
    }), t.parentElement.insertBefore(n, t), n;
  }
  _getConfig(t = {}) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...JT,
      ...e,
      ...t
    }, Y(Bl, t, tC), t;
  }
  _setStyle(t, e) {
    Object.keys(e).forEach((s) => {
      t.style[s] = e[s];
    });
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Ad);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose|hide/.test(t)) && (s || (s = new wd(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
class Ii {
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection({ x: t, y: e }) {
    return {
      x: {
        direction: t < 0 ? "left" : "right",
        value: Math.abs(t)
      },
      y: {
        direction: e < 0 ? "up" : "down",
        value: Math.abs(e)
      }
    };
  }
  _getOrigin({ x: t, y: e }, { x: s, y: n }) {
    return {
      x: t - s,
      y: e - n
    };
  }
  _getDistanceBetweenTwoPoints(t, e, s, n) {
    return Math.hypot(e - t, n - s);
  }
  _getMidPoint({ x1: t, x2: e, y1: s, y2: n }) {
    return {
      x: (t + e) / 2,
      y: (s + n) / 2
    };
  }
  _getVectorLength({ x1: t, x2: e, y1: s, y2: n }) {
    return Math.sqrt((e - t) ** 2 + (n - s) ** 2);
  }
  _getRightMostTouch(t) {
    let e = null;
    const s = Number.MIN_VALUE;
    return t.forEach((n) => {
      n.clientX > s && (e = n);
    }), e;
  }
  _getAngle(t, e, s, n) {
    return Math.atan2(n - e, s - t);
  }
  _getAngularDistance(t, e) {
    return e - t;
  }
  _getCenterXY({ x1: t, x2: e, y1: s, y2: n }) {
    return {
      x: t + (e - t) / 2,
      y: s + (n - s) / 2
    };
  }
  _getPinchTouchOrigin(t) {
    const [e, s] = t, n = {
      x1: e.clientX,
      x2: s.clientX,
      y1: e.clientY,
      y2: s.clientY
    };
    return [this._getVectorLength(n), this._getCenterXY(n)];
  }
  _getPosition({ x1: t, x2: e, y1: s, y2: n }) {
    return { x1: t, x2: e, y1: s, y2: n };
  }
}
const eC = {
  time: 250,
  pointers: 1
}, Wl = "press", iC = "pressup";
class sC extends Ii {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = {
      ...eC,
      ...e
    }, this._timer = null;
  }
  // Getters
  static get NAME() {
    return Wl;
  }
  handleTouchStart(t) {
    const { time: e, pointers: s } = this._options;
    t.touches.length === s && (this._timer = setTimeout(() => {
      h.trigger(this._element, Wl, { touch: t, time: e }), h.trigger(this._element, iC, { touch: t });
    }, e));
  }
  handleTouchEnd() {
    clearTimeout(this._timer);
  }
}
const nC = {
  threshold: 10,
  direction: "all"
};
class oC {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...nC,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), s = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(s);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      h.trigger(this._element, `swipe${r}`, { touch: t }), h.trigger(this._element, "swipe", { touch: t, direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (h.trigger(this._element, `swipe${n[o].direction}`, { touch: t }), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}
const rC = {
  threshold: 20,
  direction: "all",
  pointers: 1
}, ge = "pan", aC = `${ge}start`, lC = `${ge}end`, cC = `${ge}move`, hC = "left", dC = "right";
class uC extends Ii {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = {
      ...rC,
      ...e
    }, this._startTouch = null;
  }
  // Getters
  static get NAME() {
    return ge;
  }
  handleTouchStart(t) {
    this._startTouch = this._getCoordinates(t), this._movedTouch = t, h.trigger(this._element, aC, { touch: t });
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    const { threshold: e, direction: s } = this._options, n = this._getCoordinates(t), o = this._getCoordinates(this._movedTouch), r = this._getOrigin(n, this._startTouch), l = this._getOrigin(n, o), c = this._getDirection(r), d = this._getDirection(l), { x: p, y: f } = c;
    if (s === "all" && (f.value > e || p.value > e)) {
      const g = f.value > p.value ? f.direction : p.direction;
      h.trigger(this._element, `${ge}${g}`, { touch: t }), h.trigger(this._element, ge, { ...l, touch: t });
    }
    const m = s === hC || s === dC ? "x" : "y";
    d[m].direction === s && c[m].value > e && h.trigger(this._element, `${ge}${s}`, {
      touch: t,
      [m]: n[m] - o[m]
    }), this._movedTouch = t, h.trigger(this._element, cC, { touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._movedTouch = null, this._startTouch = null, h.trigger(this._element, lC, { touch: t });
  }
}
const pC = {
  pointers: 2,
  threshold: 10
}, Si = "pinch", _C = `${Si}end`, fC = `${Si}start`, mC = `${Si}move`;
class gC extends Ii {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = {
      ...pC,
      ...e
    }, this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null;
  }
  // Getters
  static get NAME() {
    return Si;
  }
  get isNumber() {
    return typeof this._startTouch == "number" && typeof this._touch == "number" && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._startTouch) && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._touch);
  }
  handleTouchStart(t) {
    if (t.touches.length !== this._options.pointers)
      return;
    t.type === "touchstart" && t.preventDefault();
    const [e, s] = this._getPinchTouchOrigin(t.touches);
    this._touch = e, this._origin = s, this._startTouch = this._touch, h.trigger(this._element, fC, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    });
  }
  handleTouchMove(t) {
    const { threshold: e, pointers: s } = this._options;
    t.touches.length === s && (t.type === "touchmove" && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, h.trigger(this._element, Si, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }), h.trigger(this._element, mC, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    })));
  }
  handleTouchEnd(t) {
    this.isNumber && (this._startTouch = null, h.trigger(this._element, _C, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }));
  }
}
const bC = {
  interval: 500,
  time: 250,
  taps: 1,
  pointers: 1
}, Yl = "tap";
class vC extends Ii {
  constructor(t, e) {
    super(), this._element = t, this._options = {
      ...bC,
      ...e
    }, this._timer = null, this._tapCount = 0;
  }
  // Getters
  static get NAME() {
    return Yl;
  }
  handleTouchStart(t) {
    const { x: e, y: s } = this._getCoordinates(t), { interval: n, taps: o, pointers: r } = this._options;
    return t.touches.length === r && (this._tapCount += 1, this._tapCount === 1 && (this._timer = setTimeout(() => {
      this._tapCount = 0;
    }, n)), this._tapCount === o && (clearTimeout(this._timer), this._tapCount = 0, h.trigger(this._element, Yl, {
      touch: t,
      origin: {
        x: e,
        y: s
      }
    }))), t;
  }
  handleTouchEnd() {
  }
  handleTouchMove() {
  }
}
const EC = {
  angle: 0,
  pointers: 2
}, Ms = "rotate", TC = `${Ms}end`, CC = `${Ms}start`;
class yC extends Ii {
  constructor(t, e) {
    super(), this._element = t, this._options = {
      ...EC,
      ...e
    }, this._origin = {};
  }
  // Getters
  static get NAME() {
    return Ms;
  }
  handleTouchStart(t) {
    t.type === "touchstart" && t.preventDefault(), !(t.touches.length < 2) && (this._startTouch = t, this._origin = {}, h.trigger(this._element, CC, { touch: t }));
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    let e, s;
    const n = t.touches;
    if (n.length === 1 && this._options.pointers === 1) {
      const { left: o, top: r, width: l, height: c } = this._element.getBoundingClientRect();
      e = {
        x: o + l / 2,
        y: r + c / 2
      }, s = n[0];
    } else if (t.touches.length === 2 && this._options.pointers === 2) {
      const [o, r] = t.touches, l = {
        x1: r.clientX,
        x2: o.clientX,
        y1: r.clientY,
        y2: o.clientY
      };
      e = this._getMidPoint(l), s = this._getRightMostTouch(t.touches);
    } else
      return;
    this.currentAngle = this._getAngle(e.x, e.y, s.clientX, s.clientY), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(this._origin.previousAngle, this.currentAngle), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {
      currentAngle: this.currentAngle,
      distance: this._origin.distance,
      change: this._origin.change
    }, h.trigger(this._element, Ms, { ...this.rotate, touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._origin = {}, h.trigger(this._element, TC, { touch: t });
  }
}
const AC = "touch", SC = "mdb.touch";
class Od extends F {
  constructor(t, e = "swipe", s = {}) {
    super(t), this._options = this._getConfig(s), this._event = this._options.event || e, this.swipe = this._event === "swipe" ? new oC(t, this._options) : null, this.press = this._event === "press" ? new sC(t, this._options) : null, this.pan = this._event === "pan" ? new uC(t, this._options) : null, this.pinch = this._event === "pinch" ? new gC(t, this._options) : null, this.tap = this._event === "tap" ? new vC(t, this._options) : null, this.rotate = this._event === "rotate" ? new yC(t, this._options) : null, this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this), this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return AC;
  }
  // Public
  dispose() {
    h.off(this._element, "touchstart", this._touchStartHandler), h.off(this._element, "touchmove", this._touchMoveHandler), h.off(this._element, "touchend", this._touchEndHandler), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  init() {
    h.on(this._element, "touchstart", this._touchStartHandler), h.on(this._element, "touchmove", this._touchMoveHandler), h.on(this._element, "touchend", this._touchEndHandler);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...a.getDataAttributes(this._element),
      ...t
    }, t;
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove && this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, SC);
      const s = typeof t == "object" && t;
      if (!(!e && /dispose/.test(t)) && (e || (e = new Od(this, s)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        return e[t];
      }
    });
  }
}
const To = "smoothScroll", $d = `mdb.${To}`, jo = `.${$d}`, wC = {
  container: "string",
  offset: "number",
  easing: "string",
  duration: "number"
}, OC = {
  container: "body",
  offset: 0,
  easing: "linear",
  duration: 500
}, $C = `scrollStart${jo}`, DC = `scrollEnd${jo}`, NC = `scrollCancel${jo}`;
class Dd extends F {
  constructor(t, e = {}) {
    super(t), this._options = this._getConfig(e), this._href = this._element.getAttribute("href"), this.isCancel = !1, this._element && (this._setup(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // getters
  static get NAME() {
    return To;
  }
  get isWindow() {
    return this._options.container === "body";
  }
  get containerToScroll() {
    return this.isWindow ? document.documentElement : u.findOne(this._options.container, document.documentElement);
  }
  get elFromHrefExist() {
    return !!u.findOne(this._href, this.containerToScroll);
  }
  get offsetFromEl() {
    const t = this.containerToScroll.scrollTop, e = u.findOne(this._href, this.containerToScroll);
    if (this.isWindow)
      return a.offset(e).top - this._options.offset + t;
    const s = e.getBoundingClientRect().y, n = this.containerToScroll.getBoundingClientRect().y;
    return s - n - this._options.offset + t;
  }
  get easingFunction() {
    const t = this._options.easing, e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;
    return this[e] ? this[e] : this._motionLinear;
  }
  // public
  dispose() {
    h.off(this._element, "click"), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  cancelScroll() {
    this.isCancel = !0;
  }
  // private
  _getConfig(t) {
    const e = {
      ...OC,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(To, e, wC), e;
  }
  _inViewport() {
    if (this.isWindow)
      return !0;
    const t = this.containerToScroll.getBoundingClientRect();
    return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight);
  }
  _setup() {
    const t = typeof this._href < "u", e = this._href.includes("#");
    t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll());
  }
  _scrollOnClickEvent() {
    h.on(this._element, "click", (t) => {
      this._handleClick(t);
    });
  }
  _handleClick(t) {
    t.preventDefault(), this.isCancel = !1, h.trigger(this._element, $C);
    const e = this.containerToScroll, s = this.containerToScroll.scrollTop, n = this.offsetFromEl, o = 0, r = 1 / this._options.duration, l = 4.25, c = this.easingFunction;
    this._inViewport() ? this._scrollOnNextTick(
      e,
      s,
      n,
      o,
      r,
      l,
      c
    ) : (this._scrollOnNextTick(
      document.documentElement,
      document.documentElement.scrollTop,
      this.containerToScroll.offsetTop,
      o,
      r,
      l,
      c
    ), setTimeout(() => {
      this._scrollOnNextTick(
        e,
        s,
        n,
        o,
        r,
        l,
        c
      ), this.isCancel = !1;
    }, this._options.duration));
  }
  _scrollOnNextTick(t, e, s, n, o, r, l) {
    const c = n < 0, d = n > 1, p = o <= 0;
    if (c || d || p || this.isCancel) {
      if (this.isCancel) {
        this.isInViewport && (this.isCancel = !1), h.trigger(this._element, NC);
        return;
      }
      h.trigger(this._element, DC), t.scrollTop = s;
      return;
    }
    t.scrollTo({
      top: e - (e - s) * l(n)
    }), n += o * r, setTimeout(() => {
      this._scrollOnNextTick(
        t,
        e,
        s,
        n,
        o,
        r,
        l
      );
    });
  }
  _preventDefault(t) {
    t.preventDefault();
  }
  _preventNativeScroll() {
    let t = !1;
    try {
      window.addEventListener(
        "test",
        null,
        Object.defineProperty({}, "passive", {
          get: () => t = !0
        })
      );
    } catch (n) {
      this._scrollError = n;
    }
    const e = t ? { passive: !1 } : !1, s = "onwheel" in O("div") ? "wheel" : "mousewheel";
    this.isWindow && (this._deleteScrollOnStart(e, s), this._addScrollOnEnd(e, s), this._addScrollOnCancel(e, s));
  }
  _deleteScrollOnStart(t, e) {
    h.on(this._element, "scrollStart.mdb.smoothScroll", () => {
      window.addEventListener(e, this._preventDefault, t), window.addEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnEnd(t, e) {
    h.on(this._element, "scrollEnd.mdb.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnCancel(t, e) {
    h.on(this._element, "scrollCancel.mdb.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  // Motions
  // Linear
  _motionLinear(t) {
    return t;
  }
  // Ease-In
  _motionEaseInQuad(t) {
    return t * t;
  }
  _motionEaseInCubic(t) {
    return t * t * t;
  }
  _motionEaseInQuart(t) {
    return t * t * t * t;
  }
  _motionEaseInQuint(t) {
    return t * t * t * t * t;
  }
  // Ease-In-Out
  _motionEaseInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  _motionEaseInOutCubic(t) {
    return t /= 0.5, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
  }
  _motionEaseInOutQuart(t) {
    return t /= 0.5, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -(t * t * t * t - 2) / 2);
  }
  _motionEaseInOutQuint(t) {
    return t /= 0.5, t < 1 ? t * t * t * t * t / 2 : (t -= 2, (t * t * t * t * t + 2) / 2);
  }
  // Ease-Out
  _motionEaseOutQuad(t) {
    return -t * (t - 2);
  }
  _motionEaseOutCubic(t) {
    return t--, t * t * t + 1;
  }
  _motionEaseOutQuart(t) {
    return t--, -(t * t * t * t - 1);
  }
  _motionEaseOutQuint(t) {
    return t--, t * t * t * t * t + 1;
  }
  // static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, $d);
      const s = typeof t == "object" && t;
      if (e || (e = new Dd(this, s)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Pt(i) {
  return getComputedStyle(i);
}
function pt(i, t) {
  for (var e in t) {
    var s = t[e];
    typeof s == "number" && (s = s + "px"), i.style[e] = s;
  }
  return i;
}
function ds(i) {
  var t = document.createElement("div");
  return t.className = i, t;
}
var Fl = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function ee(i, t) {
  if (!Fl)
    throw new Error("No element matching method supported");
  return Fl.call(i, t);
}
function je(i) {
  i.remove ? i.remove() : i.parentNode && i.parentNode.removeChild(i);
}
function Kl(i, t) {
  return Array.prototype.filter.call(
    i.children,
    function(e) {
      return ee(e, t);
    }
  );
}
var Z = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(i) {
      return "ps__thumb-" + i;
    },
    rail: function(i) {
      return "ps__rail-" + i;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(i) {
      return "ps--active-" + i;
    },
    scrolling: function(i) {
      return "ps--scrolling-" + i;
    }
  }
}, Nd = { x: null, y: null };
function Ld(i, t) {
  var e = i.element.classList, s = Z.state.scrolling(t);
  e.contains(s) ? clearTimeout(Nd[t]) : e.add(s);
}
function Id(i, t) {
  Nd[t] = setTimeout(
    function() {
      return i.isAlive && i.element.classList.remove(Z.state.scrolling(t));
    },
    i.settings.scrollingThreshold
  );
}
function LC(i, t) {
  Ld(i, t), Id(i, t);
}
var ki = function(t) {
  this.element = t, this.handlers = {};
}, kd = { isEmpty: { configurable: !0 } };
ki.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
ki.prototype.unbind = function(t, e) {
  var s = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (s.element.removeEventListener(t, n, !1), !1);
  });
};
ki.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
kd.isEmpty.get = function() {
  var i = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return i.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(ki.prototype, kd);
var ci = function() {
  this.eventElements = [];
};
ci.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(s) {
    return s.element === t;
  })[0];
  return e || (e = new ki(t), this.eventElements.push(e)), e;
};
ci.prototype.bind = function(t, e, s) {
  this.eventElement(t).bind(e, s);
};
ci.prototype.unbind = function(t, e, s) {
  var n = this.eventElement(t);
  n.unbind(e, s), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
ci.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
ci.prototype.once = function(t, e, s) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), s(r);
  };
  n.bind(e, o);
};
function us(i) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(i);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(i, !1, !1, void 0), t;
}
function xs(i, t, e, s, n) {
  s === void 0 && (s = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  IC(i, e, o, s, n);
}
function IC(i, t, e, s, n) {
  var o = e[0], r = e[1], l = e[2], c = e[3], d = e[4], p = e[5];
  s === void 0 && (s = !0), n === void 0 && (n = !1);
  var f = i.element;
  i.reach[c] = null, f[l] < 1 && (i.reach[c] = "start"), f[l] > i[o] - i[r] - 1 && (i.reach[c] = "end"), t && (f.dispatchEvent(us("ps-scroll-" + c)), t < 0 ? f.dispatchEvent(us("ps-scroll-" + d)) : t > 0 && f.dispatchEvent(us("ps-scroll-" + p)), s && LC(i, c)), i.reach[c] && (t || n) && f.dispatchEvent(us("ps-" + c + "-reach-" + i.reach[c]));
}
function z(i) {
  return parseInt(i, 10) || 0;
}
function kC(i) {
  return ee(i, "input,[contenteditable]") || ee(i, "select,[contenteditable]") || ee(i, "textarea,[contenteditable]") || ee(i, "button,[contenteditable]");
}
function MC(i) {
  var t = Pt(i);
  return z(t.width) + z(t.paddingLeft) + z(t.paddingRight) + z(t.borderLeftWidth) + z(t.borderRightWidth);
}
var Ye = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Ut(i) {
  var t = i.element, e = Math.floor(t.scrollTop), s = t.getBoundingClientRect();
  i.containerWidth = Math.round(s.width), i.containerHeight = Math.round(s.height), i.contentWidth = t.scrollWidth, i.contentHeight = t.scrollHeight, t.contains(i.scrollbarXRail) || (Kl(t, Z.element.rail("x")).forEach(
    function(n) {
      return je(n);
    }
  ), t.appendChild(i.scrollbarXRail)), t.contains(i.scrollbarYRail) || (Kl(t, Z.element.rail("y")).forEach(
    function(n) {
      return je(n);
    }
  ), t.appendChild(i.scrollbarYRail)), !i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth ? (i.scrollbarXActive = !0, i.railXWidth = i.containerWidth - i.railXMarginWidth, i.railXRatio = i.containerWidth / i.railXWidth, i.scrollbarXWidth = zl(
    i,
    z(i.railXWidth * i.containerWidth / i.contentWidth)
  ), i.scrollbarXLeft = z(
    (i.negativeScrollAdjustment + t.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
  )) : i.scrollbarXActive = !1, !i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight ? (i.scrollbarYActive = !0, i.railYHeight = i.containerHeight - i.railYMarginHeight, i.railYRatio = i.containerHeight / i.railYHeight, i.scrollbarYHeight = zl(
    i,
    z(i.railYHeight * i.containerHeight / i.contentHeight)
  ), i.scrollbarYTop = z(
    e * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
  )) : i.scrollbarYActive = !1, i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth && (i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth), i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight && (i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight), xC(t, i), i.scrollbarXActive ? t.classList.add(Z.state.active("x")) : (t.classList.remove(Z.state.active("x")), i.scrollbarXWidth = 0, i.scrollbarXLeft = 0, t.scrollLeft = i.isRtl === !0 ? i.contentWidth : 0), i.scrollbarYActive ? t.classList.add(Z.state.active("y")) : (t.classList.remove(Z.state.active("y")), i.scrollbarYHeight = 0, i.scrollbarYTop = 0, t.scrollTop = 0);
}
function zl(i, t) {
  return i.settings.minScrollbarLength && (t = Math.max(t, i.settings.minScrollbarLength)), i.settings.maxScrollbarLength && (t = Math.min(t, i.settings.maxScrollbarLength)), t;
}
function xC(i, t) {
  var e = { width: t.railXWidth }, s = Math.floor(i.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth - t.contentWidth : e.left = i.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - s : e.top = t.scrollbarXTop + s, pt(t.scrollbarXRail, e);
  var n = { top: s, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + i.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - i.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + i.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + i.scrollLeft, pt(t.scrollbarYRail, n), pt(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), pt(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function RC(i) {
  i.element, i.event.bind(i.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), i.event.bind(i.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top, s = e > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += s * i.containerHeight, Ut(i), t.stopPropagation();
  }), i.event.bind(i.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), i.event.bind(i.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left, s = e > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += s * i.containerWidth, Ut(i), t.stopPropagation();
  });
}
function PC(i) {
  Xl(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Xl(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Xl(i, t) {
  var e = t[0], s = t[1], n = t[2], o = t[3], r = t[4], l = t[5], c = t[6], d = t[7], p = t[8], f = i.element, m = null, g = null, _ = null;
  function b(T) {
    T.touches && T.touches[0] && (T[n] = T.touches[0].pageY), f[c] = m + _ * (T[n] - g), Ld(i, d), Ut(i), T.stopPropagation(), T.type.startsWith("touch") && T.changedTouches.length > 1 && T.preventDefault();
  }
  function C() {
    Id(i, d), i[p].classList.remove(Z.state.clicking), i.event.unbind(i.ownerDocument, "mousemove", b);
  }
  function v(T, E) {
    m = f[c], E && T.touches && (T[n] = T.touches[0].pageY), g = T[n], _ = (i[s] - i[e]) / (i[o] - i[l]), E ? i.event.bind(i.ownerDocument, "touchmove", b) : (i.event.bind(i.ownerDocument, "mousemove", b), i.event.once(i.ownerDocument, "mouseup", C), T.preventDefault()), i[p].classList.add(Z.state.clicking), T.stopPropagation();
  }
  i.event.bind(i[r], "mousedown", function(T) {
    v(T);
  }), i.event.bind(i[r], "touchstart", function(T) {
    v(T, !0);
  });
}
function HC(i) {
  var t = i.element, e = function() {
    return ee(t, ":hover");
  }, s = function() {
    return ee(i.scrollbarX, ":focus") || ee(i.scrollbarY, ":focus");
  };
  function n(o, r) {
    var l = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!i.scrollbarYActive)
        return !1;
      if (l === 0 && r > 0 || l >= i.contentHeight - i.containerHeight && r < 0)
        return !i.settings.wheelPropagation;
    }
    var c = t.scrollLeft;
    if (r === 0) {
      if (!i.scrollbarXActive)
        return !1;
      if (c === 0 && o < 0 || c >= i.contentWidth - i.containerWidth && o > 0)
        return !i.settings.wheelPropagation;
    }
    return !0;
  }
  i.event.bind(i.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !s())) {
      var r = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (kC(r))
          return;
      }
      var l = 0, c = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? l = -i.contentWidth : o.altKey ? l = -i.containerWidth : l = -30;
          break;
        case 38:
          o.metaKey ? c = i.contentHeight : o.altKey ? c = i.containerHeight : c = 30;
          break;
        case 39:
          o.metaKey ? l = i.contentWidth : o.altKey ? l = i.containerWidth : l = 30;
          break;
        case 40:
          o.metaKey ? c = -i.contentHeight : o.altKey ? c = -i.containerHeight : c = -30;
          break;
        case 32:
          o.shiftKey ? c = i.containerHeight : c = -i.containerHeight;
          break;
        case 33:
          c = i.containerHeight;
          break;
        case 34:
          c = -i.containerHeight;
          break;
        case 36:
          c = i.contentHeight;
          break;
        case 35:
          c = -i.contentHeight;
          break;
        default:
          return;
      }
      i.settings.suppressScrollX && l !== 0 || i.settings.suppressScrollY && c !== 0 || (t.scrollTop -= c, t.scrollLeft += l, Ut(i), n(l, c) && o.preventDefault());
    }
  });
}
function BC(i) {
  var t = i.element;
  function e(r, l) {
    var c = Math.floor(t.scrollTop), d = t.scrollTop === 0, p = c + t.offsetHeight === t.scrollHeight, f = t.scrollLeft === 0, m = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;
    return Math.abs(l) > Math.abs(r) ? g = d || p : g = f || m, g ? !i.settings.wheelPropagation : !0;
  }
  function s(r) {
    var l = r.deltaX, c = -1 * r.deltaY;
    return (typeof l > "u" || typeof c > "u") && (l = -1 * r.wheelDeltaX / 6, c = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (l *= 10, c *= 10), l !== l && c !== c && (l = 0, c = r.wheelDelta), r.shiftKey ? [-c, -l] : [l, c];
  }
  function n(r, l, c) {
    if (!Ye.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var d = r; d && d !== t; ) {
      if (d.classList.contains(Z.element.consuming))
        return !0;
      var p = Pt(d);
      if (c && p.overflowY.match(/(scroll|auto)/)) {
        var f = d.scrollHeight - d.clientHeight;
        if (f > 0 && (d.scrollTop > 0 && c < 0 || d.scrollTop < f && c > 0))
          return !0;
      }
      if (l && p.overflowX.match(/(scroll|auto)/)) {
        var m = d.scrollWidth - d.clientWidth;
        if (m > 0 && (d.scrollLeft > 0 && l < 0 || d.scrollLeft < m && l > 0))
          return !0;
      }
      d = d.parentNode;
    }
    return !1;
  }
  function o(r) {
    var l = s(r), c = l[0], d = l[1];
    if (!n(r.target, c, d)) {
      var p = !1;
      i.settings.useBothWheelAxes ? i.scrollbarYActive && !i.scrollbarXActive ? (d ? t.scrollTop -= d * i.settings.wheelSpeed : t.scrollTop += c * i.settings.wheelSpeed, p = !0) : i.scrollbarXActive && !i.scrollbarYActive && (c ? t.scrollLeft += c * i.settings.wheelSpeed : t.scrollLeft -= d * i.settings.wheelSpeed, p = !0) : (t.scrollTop -= d * i.settings.wheelSpeed, t.scrollLeft += c * i.settings.wheelSpeed), Ut(i), p = p || e(c, d), p && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? i.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && i.event.bind(t, "mousewheel", o);
}
function VC(i) {
  if (!Ye.supportsTouch && !Ye.supportsIePointer)
    return;
  var t = i.element;
  function e(_, b) {
    var C = Math.floor(t.scrollTop), v = t.scrollLeft, T = Math.abs(_), E = Math.abs(b);
    if (E > T) {
      if (b < 0 && C === i.contentHeight - i.containerHeight || b > 0 && C === 0)
        return window.scrollY === 0 && b > 0 && Ye.isChrome;
    } else if (T > E && (_ < 0 && v === i.contentWidth - i.containerWidth || _ > 0 && v === 0))
      return !0;
    return !0;
  }
  function s(_, b) {
    t.scrollTop -= b, t.scrollLeft -= _, Ut(i);
  }
  var n = {}, o = 0, r = {}, l = null;
  function c(_) {
    return _.targetTouches ? _.targetTouches[0] : _;
  }
  function d(_) {
    return _.pointerType && _.pointerType === "pen" && _.buttons === 0 ? !1 : !!(_.targetTouches && _.targetTouches.length === 1 || _.pointerType && _.pointerType !== "mouse" && _.pointerType !== _.MSPOINTER_TYPE_MOUSE);
  }
  function p(_) {
    if (d(_)) {
      var b = c(_);
      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), l !== null && clearInterval(l);
    }
  }
  function f(_, b, C) {
    if (!t.contains(_))
      return !1;
    for (var v = _; v && v !== t; ) {
      if (v.classList.contains(Z.element.consuming))
        return !0;
      var T = Pt(v);
      if (C && T.overflowY.match(/(scroll|auto)/)) {
        var E = v.scrollHeight - v.clientHeight;
        if (E > 0 && (v.scrollTop > 0 && C < 0 || v.scrollTop < E && C > 0))
          return !0;
      }
      if (b && T.overflowX.match(/(scroll|auto)/)) {
        var y = v.scrollWidth - v.clientWidth;
        if (y > 0 && (v.scrollLeft > 0 && b < 0 || v.scrollLeft < y && b > 0))
          return !0;
      }
      v = v.parentNode;
    }
    return !1;
  }
  function m(_) {
    if (d(_)) {
      var b = c(_), C = { pageX: b.pageX, pageY: b.pageY }, v = C.pageX - n.pageX, T = C.pageY - n.pageY;
      if (f(_.target, v, T))
        return;
      s(v, T), n = C;
      var E = (/* @__PURE__ */ new Date()).getTime(), y = E - o;
      y > 0 && (r.x = v / y, r.y = T / y, o = E), e(v, T) && _.preventDefault();
    }
  }
  function g() {
    i.settings.swipeEasing && (clearInterval(l), l = setInterval(function() {
      if (i.isInitialized) {
        clearInterval(l);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(l);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(l);
        return;
      }
      if (!i.element) {
        clearInterval(l);
        return;
      }
      s(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  Ye.supportsTouch ? (i.event.bind(t, "touchstart", p), i.event.bind(t, "touchmove", m), i.event.bind(t, "touchend", g)) : Ye.supportsIePointer && (window.PointerEvent ? (i.event.bind(t, "pointerdown", p), i.event.bind(t, "pointermove", m), i.event.bind(t, "pointerup", g)) : window.MSPointerEvent && (i.event.bind(t, "MSPointerDown", p), i.event.bind(t, "MSPointerMove", m), i.event.bind(t, "MSPointerUp", g)));
}
var WC = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, YC = {
  "click-rail": RC,
  "drag-thumb": PC,
  keyboard: HC,
  wheel: BC,
  touch: VC
}, Mi = function(t, e) {
  var s = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(Z.main), this.settings = WC();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(Z.state.focus);
  }, r = function() {
    return t.classList.remove(Z.state.focus);
  };
  this.isRtl = Pt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(Z.rtl), this.isNegativeScroll = function() {
    var d = t.scrollLeft, p = null;
    return t.scrollLeft = -1, p = t.scrollLeft < 0, t.scrollLeft = d, p;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new ci(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ds(Z.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ds(Z.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var l = Pt(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(l.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = z(l.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = z(l.borderLeftWidth) + z(l.borderRightWidth), pt(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = z(l.marginLeft) + z(l.marginRight), pt(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ds(Z.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ds(Z.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var c = Pt(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(c.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = z(c.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? MC(this.scrollbarY) : null, this.railBorderYWidth = z(c.borderTopWidth) + z(c.borderBottomWidth), pt(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = z(c.marginTop) + z(c.marginBottom), pt(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(d) {
    return YC[d](s);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(d) {
    return s.onScroll(d);
  }), Ut(this);
};
Mi.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, pt(this.scrollbarXRail, { display: "block" }), pt(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = z(Pt(this.scrollbarXRail).marginLeft) + z(Pt(this.scrollbarXRail).marginRight), this.railYMarginHeight = z(Pt(this.scrollbarYRail).marginTop) + z(Pt(this.scrollbarYRail).marginBottom), pt(this.scrollbarXRail, { display: "none" }), pt(this.scrollbarYRail, { display: "none" }), Ut(this), xs(this, "top", 0, !1, !0), xs(this, "left", 0, !1, !0), pt(this.scrollbarXRail, { display: "" }), pt(this.scrollbarYRail, { display: "" }));
};
Mi.prototype.onScroll = function(t) {
  this.isAlive && (Ut(this), xs(this, "top", this.element.scrollTop - this.lastScrollTop), xs(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Mi.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), je(this.scrollbarX), je(this.scrollbarY), je(this.scrollbarXRail), je(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Mi.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const jl = "perfectScrollbar", FC = "perfect-scrollbar", KC = "mdb.perfectScrollbar", kt = "mdb", Mt = "ps", Bn = [
  { mdb: `scrollX.${kt}.${Mt}`, ps: "ps-scroll-x" },
  { mdb: `scrollY.${kt}.${Mt}`, ps: "ps-scroll-y" },
  { mdb: `scrollUp.${kt}.${Mt}`, ps: "ps-scroll-up" },
  { mdb: `scrollDown.${kt}.${Mt}`, ps: "ps-scroll-down" },
  { mdb: `scrollLeft.${kt}.${Mt}`, ps: "ps-scroll-left" },
  { mdb: `scrollRight.${kt}.${Mt}`, ps: "ps-scroll-right" },
  { mdb: `scrollXEnd.${kt}.${Mt}`, ps: "ps-x-reach-end" },
  { mdb: `scrollYEnd.${kt}.${Mt}`, ps: "ps-y-reach-end" },
  { mdb: `scrollXStart.${kt}.${Mt}`, ps: "ps-x-reach-start" },
  { mdb: `scrollYStart.${kt}.${Mt}`, ps: "ps-y-reach-start" }
], zC = {
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  wheelSpeed: 1,
  wheelPropagation: !0,
  swipeEasing: !0,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  scrollingThreshold: 1e3,
  useBothWheelAxes: !1,
  suppressScrollX: !1,
  suppressScrollY: !1,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0
}, XC = {
  handlers: "(string|array)",
  wheelSpeed: "number",
  wheelPropagation: "boolean",
  swipeEasing: "boolean",
  minScrollbarLength: "(number|null)",
  maxScrollbarLength: "(number|null)",
  scrollingThreshold: "number",
  useBothWheelAxes: "boolean",
  suppressScrollX: "boolean",
  suppressScrollY: "boolean",
  scrollXMarginOffset: "number",
  scrollYMarginOffset: "number"
};
class Md extends F {
  constructor(t, e = {}) {
    super(t), this._options = this._getConfig(e), this.perfectScrollbar = null, this._element && a.addClass(this._element, FC), this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return jl;
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return e.handlers !== void 0 && (e.handlers = e.handlers.split(" ")), t = {
      ...zC,
      ...e,
      ...t
    }, Y(jl, t, XC), t;
  }
  // Public
  dispose() {
    this.removeEvent(Bn), this.perfectScrollbar.destroy(), this.perfectScrollbar = null, a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  init() {
    this.perfectScrollbar = new Mi(this._element, this._options), this._initEvents(Bn);
  }
  update() {
    return this.perfectScrollbar.update();
  }
  _initEvents(t = []) {
    t.forEach(
      ({ ps: e, mdb: s }) => h.on(this._element, e, (n) => h.trigger(this._element, s, { e: n }))
    );
  }
  removeEvent(t) {
    let e = [];
    typeof t == "string" && (e = Bn.filter(({ mdb: s }) => s === t)), e.forEach(({ ps: s, mdb: n }) => {
      h.off(this._element, s), h.off(this._element, n);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, KC);
      const s = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new Md(this, s)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
function jC({ backdropID: i, backdropOpacity: t, backdropColor: e }) {
  const s = O("div");
  return a.addClass(s, "loading-backdrop"), s.id = i, a.addStyle(s, { opacity: t, backgroundColor: e }), s;
}
const Ul = "loading", Gl = "loading-spinner", UC = "mdb.loading", GC = ".loading-icon", qC = ".loading-text", QC = "show.mdb.loading", ZC = {
  backdrop: "(null|boolean)",
  backdropColor: "string",
  backdropOpacity: "(number|string)",
  delay: "(null|number)",
  loader: "string",
  loadingIcon: "boolean",
  loadingText: "boolean",
  scroll: "boolean"
}, JC = {
  backdrop: !0,
  backdropColor: "rgba(0, 0, 0)",
  backdropOpacity: 0.4,
  backdropID: "",
  delay: null,
  loader: "",
  parentSelector: null,
  scroll: !0,
  loadingText: !0,
  loadingIcon: !0
};
class xd extends F {
  constructor(t, e = {}) {
    super(t), this._options = this._getConfig(e), this._backdropElement = null, this._parentElement = u.findOne(this._options.parentSelector), this._loadingIcon = u.findOne(GC, this._element), this._loadingText = u.findOne(qC, this._element), this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return Ul;
  }
  // Public
  init() {
    const t = this._loadingIcon.cloneNode(!0), e = this._loadingText.cloneNode(!0);
    this._removeElementsOnStart(), setTimeout(() => {
      a.addClass(this._element, Gl), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), h.trigger(this._element, QC);
    }, this._options.delay);
  }
  dispose() {
    a.removeClass(this._element, Gl);
    const t = this._options.delay;
    a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), setTimeout(() => {
      this._removeBackdrop(), setTimeout(() => {
        super.dispose();
      }, t);
    }, t);
  }
  // Private
  _setBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._backdropElement = jC(this._options), this._parentElement !== null ? (a.addClass(this._element, "position-absolute"), a.addClass(this._parentElement, "position-relative"), a.addClass(this._backdropElement, "position-absolute"), this._parentElement.appendChild(this._backdropElement)) : (a.addClass(this._element, "position-fixed"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)));
  }
  _removeBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._parentElement !== null ? (a.removeClass(this._element, "position-absolute"), a.removeClass(this._parentElement, "position-relative"), this._backdropElement.remove()) : (this._backdropElement.remove(), this._element.remove()));
  }
  _setLoadingIcon(t) {
    if (!this._options.loadingIcon) {
      t.remove();
      return;
    }
    this._element.appendChild(t), t.id = this._options.loader;
  }
  _setLoadingText(t) {
    if (!this._options.loadingText) {
      t.remove();
      return;
    }
    this._element.appendChild(t);
  }
  _removeElementsOnStart() {
    this._element !== null && (this._loadingIcon.remove(), this._loadingText.remove());
  }
  _setScrollOption() {
    if (this._options.scroll) {
      if (this._parentElement === null) {
        document.body.style.overflow = "";
        return;
      }
      a.addStyle(this._parentElement, { overflow: "" });
    } else {
      if (this._parentElement === null) {
        document.body.style.overflow = "hidden";
        return;
      }
      a.addStyle(this._parentElement, { overflow: "hidden" });
    }
  }
  _getConfig(t) {
    const e = {
      ...JC,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(Ul, e, ZC), e;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, UC);
      const s = typeof t == "object" && t;
      if (e || (e = new xd(this, s)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ty = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), ey = /^aria-[\w-]*$/i, iy = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi, sy = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, ny = (i, t) => {
  const e = i.nodeName.toLowerCase();
  if (t.includes(e))
    return ty.has(e) ? !!(i.nodeValue.match(iy) || i.nodeValue.match(sy)) : !0;
  const s = t.filter((n) => n instanceof RegExp);
  for (let n = 0, o = s.length; n < o; n++)
    if (s[n].test(e))
      return !0;
  return !1;
}, Rd = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ey],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function Pd(i, t, e) {
  if (!i.length)
    return i;
  if (e && typeof e == "function")
    return e(i);
  const n = new window.DOMParser().parseFromString(i, "text/html"), o = Object.keys(t), r = [].concat(...n.body.querySelectorAll("*"));
  for (let l = 0, c = r.length; l < c; l++) {
    const d = r[l], p = d.nodeName.toLowerCase();
    if (o.indexOf(p) === -1) {
      d.parentNode.removeChild(d);
      continue;
    }
    const f = [].concat(...d.attributes), m = [].concat(t["*"] || [], t[p] || []);
    f.forEach((g) => {
      ny(g, m) || d.removeAttribute(g.nodeName);
    });
  }
  return n.body.innerHTML;
}
const oy = "autocomplete-dropdown-container", ry = "autocomplete-dropdown", ay = "autocomplete-items-list", ly = "autocomplete-item", cy = "autocomplete-loader", hy = "spinner-border", dy = "autocomplete-item autocomplete-no-results";
function uy(i) {
  const { id: t, items: e, width: s, options: n } = i, o = O("div");
  a.addClass(o, oy), a.addStyle(o, { width: `${s}px` }), o.setAttribute("id", t);
  const r = O("div");
  a.addClass(r, ry);
  const l = O("ul"), c = n.listHeight;
  a.addClass(l, ay), a.addStyle(l, { maxHeight: `${c}px` }), l.setAttribute("role", "listbox");
  const d = Hd(e, n);
  return l.innerHTML = d, r.appendChild(l), o.appendChild(r), o;
}
function Hd(i = [], t) {
  const e = t.displayValue, s = t.itemContent;
  return `
    ${i.map((n, o) => {
    const r = typeof s == "function" ? Pd(s(n), Rd, null) : e(n);
    return `<li data-mdb-index="${o}" role="option" class="${ly}">${r}</li>`;
  }).join("")}
  `;
}
function py() {
  const i = O("div");
  a.addClass(i, cy), a.addClass(i, hy), i.setAttribute("role", "status");
  const t = '<span class="sr-only">Loading...</span>';
  return i.innerHTML = t, i;
}
function _y(i) {
  return `<li class="${dy}">${i}</li>`;
}
const fy = {
  autoSelect: !1,
  container: "body",
  customContent: "",
  debounce: 300,
  displayValue: (i) => i,
  filter: null,
  itemContent: null,
  listHeight: 190,
  noResults: "No results found",
  threshold: 0
}, my = {
  autoSelect: "boolean",
  container: "string",
  customContent: "string",
  debounce: "number",
  displayValue: "function",
  filter: "(null|function)",
  itemContent: "(null|function)",
  listHeight: "number",
  noResults: "string",
  threshold: "number"
}, ql = "autocomplete", Bd = "mdb.autocomplete", gy = "autocomplete-input", by = "autocomplete-label", ps = "active", Ql = "focused", Zl = "focusing", Jl = "open", vy = ".autocomplete-dropdown", Vn = ".autocomplete-items-list", tc = ".autocomplete-item", Ey = ".autocomplete-loader", Ty = ".form-control", Cy = ".form-label", yy = ".autocomplete-custom-content", js = `.${Bd}`, Ay = `close${js}`, Sy = `open${js}`, ec = `itemSelect${js}`, wy = `update${js}`, Oy = 300;
class Uo extends F {
  constructor(t, e) {
    super(t), this._options = this._getConfig(e), this._getContainer(), this._input = u.findOne(Ty, t), this._label = u.findOne(Cy, t), this._customContent = u.findOne(yy, t), this._loader = py(), this._popper = null, this._debounceTimeoutId = null, this._loaderTimeout = null, this._activeItemIndex = -1, this._activeItem = null, this._filteredResults = null, this._lastQueryValue = null, this._canOpenOnFocus = !0, this._isOpen = !1, this._outsideClickHandler = this._handleOutsideClick.bind(this), this._inputFocusHandler = this._handleInputFocus.bind(this), this._userInputHandler = this._handleUserInput.bind(this), this._keydownHandler = this._handleKeydown.bind(this), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  static get NAME() {
    return ql;
  }
  get filter() {
    return this._options.filter;
  }
  get dropdown() {
    return u.findOne(vy, this._dropdownContainer);
  }
  get items() {
    return u.find(tc, this._dropdownContainer);
  }
  get itemsList() {
    return u.findOne(Vn, this._dropdownContainer);
  }
  search(t) {
    this._filterResults(t);
  }
  _getContainer() {
    this._container = u.findOne(this._options.container);
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...fy,
      ...e,
      ...t
    }, Y(ql, t, my), t;
  }
  _init() {
    this._initDropdown(), this._setInputAndLabelClasses(), this._updateLabelPosition(), this._setInputAriaAttributes(), this._listenToInputFocus(), this._listenToUserInput(), this._listenToKeydown();
  }
  _initDropdown() {
    this._dropdownContainerId = this._element.id ? `autocomplete-dropdown-${this._element.id}` : Ot("autocomplete-dropdown-");
    const t = {
      id: this._dropdownContainerId,
      items: [],
      width: this._input.offsetWidth,
      options: this._options
    };
    if (this._dropdownContainer = uy(t), this._options.customContent !== "") {
      const e = this._options.customContent, s = Pd(e, Rd, null);
      this.dropdown.insertAdjacentHTML("beforeend", s);
    }
  }
  _setInputAndLabelClasses() {
    a.addClass(this._input, gy), this._label && a.addClass(this._label, by);
  }
  _setInputAriaAttributes() {
    this._input.setAttribute("role", "combobox"), this._input.setAttribute("aria-expanded", !1), this._input.setAttribute("aria-owns", this._dropdownContainerId), this._input.setAttribute("aria-haspopup", !0), this._input.setAttribute("autocomplete", "off");
  }
  _updateLabelPosition() {
    this._label && (this._input.value !== "" || this._isOpen ? a.addClass(this._label, ps) : a.removeClass(this._label, ps));
  }
  _listenToInputFocus() {
    h.on(this._input, "focus", this._inputFocusHandler);
  }
  _handleInputFocus(t) {
    const { value: e } = t.target, s = this._options.threshold;
    if (!this._canOpenOnFocus) {
      this._canOpenOnFocus = !0;
      return;
    }
    e.length < s || (this._lastQueryValue !== e ? this._filterResults(e) : this.open());
  }
  _listenToWindowResize() {
    h.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    a.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _listenToUserInput() {
    h.on(this._input, "input", this._userInputHandler);
  }
  _handleUserInput(t) {
    const { value: e } = t.target, s = this._options.threshold, n = this._options.debounce;
    if (this.filter) {
      if (e.length < s) {
        this._isOpen && this.close();
        return;
      }
      this._debounceFilter(e, n);
    }
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterResults(t);
    }, e);
  }
  _filterResults(t) {
    this._lastQueryValue = t;
    const e = this.filter(t);
    this._isPromise(e) ? this._asyncUpdateResults(e) : this._updateResults(e);
  }
  _isPromise(t) {
    return !!t && typeof t.then == "function";
  }
  _asyncUpdateResults(t) {
    this._resetActiveItem(), this._showLoader(), t.then((e) => {
      this._updateResults(e), this._loaderTimeout = setTimeout(() => {
        this._hideLoader(), this._loaderTimeout = null;
      }, Oy);
    });
  }
  _resetActiveItem() {
    const t = this._activeItem;
    t && (a.removeClass(t, "active"), this._activeItem = null, this._activeItemIndex = -1);
  }
  _showLoader() {
    this._element.appendChild(this._loader);
  }
  _hideLoader() {
    u.findOne(Ey, this._element) && this._element.removeChild(this._loader);
  }
  _updateResults(t) {
    this._resetActiveItem(), this._filteredResults = t, h.trigger(this._element, wy, { results: t });
    const e = u.findOne(".autocomplete-items-list", this._dropdownContainer), s = Hd(t, this._options), n = _y(this._options.noResults);
    t.length === 0 && this._options.noResults !== "" ? e.innerHTML = n : e.innerHTML = s, this._isOpen || this.open(), this._popper && this._popper.forceUpdate();
  }
  _listenToKeydown() {
    h.on(this._element, "keydown", this._keydownHandler);
  }
  _handleKeydown(t) {
    this._isOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode;
    if (e === Se && this._options.autoSelect && this._selectActiveItem(), e === Ae || e === tt && t.altKey) {
      this._input.value || a.addClass(this._input, Zl), this.close(), this._input.focus(), this._input.value || setTimeout(() => {
        a.removeClass(this._input, Zl);
      }, 10);
      return;
    }
    if (e === Ae || e === tt && t.altKey || e === Se) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case J:
        this._setActiveItem(this._activeItemIndex + 1), this._scrollToItem(this._activeItem);
        break;
      case tt:
        this._setActiveItem(this._activeItemIndex - 1), this._scrollToItem(this._activeItem);
        break;
      case ve:
        this._activeItemIndex > -1 ? (this._setActiveItem(0), this._scrollToItem(this._activeItem)) : this._input.setSelectionRange(0, 0);
        break;
      case Ee:
        if (this._activeItemIndex > -1)
          this._setActiveItem(this.items.length - 1), this._scrollToItem(this._activeItem);
        else {
          const n = this._input.value.length;
          this._input.setSelectionRange(n, n);
        }
        break;
      case ot:
        if (t.preventDefault(), this._activeItemIndex > -1) {
          const n = this._filteredResults[this._activeItemIndex];
          this._handleSelection(n);
        }
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _setActiveItem(t) {
    const e = this.items;
    e[t] && this._updateActiveItem(e[t], t);
  }
  _updateActiveItem(t, e) {
    const s = this._activeItem;
    s && a.removeClass(s, "active"), a.addClass(t, "active"), this._activeItemIndex = e, this._activeItem = t;
  }
  _scrollToItem(t) {
    if (!t)
      return;
    const e = this.itemsList, s = e.offsetHeight, n = this.items.indexOf(t), o = t.offsetHeight, r = e.scrollTop;
    if (n > -1) {
      const l = n * o, c = l + o > r + s;
      l < r ? e.scrollTop = l : c ? e.scrollTop = l - s + o : e.scrollTop = r;
    }
  }
  _handleClosedKeydown(t) {
    t.key === "Enter" && t.preventDefault();
    const e = t.keyCode;
    (e === ot || e === J || e === J) && this.open();
  }
  open() {
    this._lastQueryValue === null && this._filterResults("");
    const t = h.trigger(this._element, Sy);
    this._isOpen || t.defaultPrevented || (this._updateDropdownWidth(), this._listenToWindowResize(), this._popper = ae(this._element, this._dropdownContainer, {
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), this._listenToOutsideClick(), this._listenToItemsClick(), setTimeout(() => {
      a.addClass(this.dropdown, Jl), this._isOpen = !0, this._setInputActiveStyles(), this._updateLabelPosition();
    }, 0));
  }
  _listenToOutsideClick() {
    h.on(document, "click", this._outsideClickHandler);
  }
  _handleOutsideClick(t) {
    const e = this._input === t.target, s = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    !e && !s && !n && this.close();
  }
  _listenToItemsClick() {
    const t = u.findOne(Vn, this._dropdownContainer);
    h.on(t, "click", this._handleItemsClick.bind(this));
  }
  _handleItemsClick(t) {
    const e = u.closest(t.target, tc), s = a.getDataAttribute(e, "index"), n = this._filteredResults[s];
    this._handleSelection(n);
  }
  _selectActiveItem() {
    const t = this._filteredResults[this._activeItemIndex];
    if (!t)
      return;
    const e = this._options.displayValue(t);
    h.trigger(this._element, ec, { value: t }).defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateLabelPosition();
    }, 0);
  }
  _handleSelection(t) {
    const e = this._options.displayValue(t), s = h.trigger(this._element, ec, { value: t });
    t !== void 0 && (s.defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateLabelPosition(), this._input.focus(), this.close();
    }, 0));
  }
  _updateInputValue(t) {
    this._input.value = t;
  }
  _setInputActiveStyles() {
    a.addClass(this._input, Ql);
  }
  close() {
    const t = h.trigger(this._element, Ay);
    !this._isOpen || t.defaultPrevented || (this._resetActiveItem(), this._removeDropdownEvents(), a.removeClass(this.dropdown, Jl), h.on(this.dropdown, "transitionend", this._handleDropdownTransitionEnd.bind(this)), a.removeClass(this._input, Ql), a.removeClass(this._input, ps), !this._input.value && this._label && a.removeClass(this._label, ps));
  }
  _removeDropdownEvents() {
    const t = u.findOne(Vn, this._dropdownContainer);
    h.off(t, "click"), h.off(document, "click", this._outsideClickHandler), h.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleDropdownTransitionEnd(t) {
    this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), this._dropdownContainer && this._container.removeChild(this._dropdownContainer), this._isOpen = !1, h.off(this.dropdown, "transitionend"));
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndElementEvents(), this._dropdownContainer.remove(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  _removeInputAndElementEvents() {
    h.off(this._input, "focus", this._inputFocusHandler), h.off(this._input, "input", this._userInputHandler), h.off(this._element, "keydown", this._keydownHandler);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Bd);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new Uo(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
Nc(Uo);
const $y = "modal", Dy = "bs.modal", Dt = `.${Dy}`, Ny = "Escape", Ly = `hide${Dt}`, Iy = `hidePrevented${Dt}`, ky = `hidden${Dt}`, My = `show${Dt}`, xy = `shown${Dt}`, Ry = `resize${Dt}`, Py = `click.dismiss${Dt}`, Hy = `mousedown.dismiss${Dt}`, By = `keydown.dismiss${Dt}`, ic = "modal-open", Vy = "fade", sc = "show", Wn = "modal-static", Wy = ".modal-dialog", Yy = ".modal-body", Fy = {
  backdrop: !0,
  focus: !0,
  keyboard: !0
}, Ky = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
let zy = class Vd extends Nt {
  constructor(t, e) {
    super(t, e), this._dialog = M.findOne(Wy, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ze(), this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Fy;
  }
  static get DefaultType() {
    return Ky;
  }
  static get NAME() {
    return $y;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || A.trigger(this._element, My, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(ic), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)));
  }
  hide() {
    !this._isShown || this._isTransitioning || A.trigger(this._element, Ly).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(sc), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()));
  }
  dispose() {
    A.off(window, Dt), A.off(this._dialog, Dt), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new Zc({
      isVisible: !!this._config.backdrop && !this._config.modalNonInvasive,
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new Jc({
      trapElement: this._element
    });
  }
  _showElement(t) {
    document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
    const e = M.findOne(Yy, this._dialog);
    e && (e.scrollTop = 0), Oi(this._element), this._element.classList.add(sc);
    const s = () => {
      this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, A.trigger(this._element, xy, {
        relatedTarget: t
      });
    };
    this._queueCallback(s, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    A.on(this._element, By, (t) => {
      if (t.key === Ny) {
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      }
    }), A.on(window, Ry, () => {
      this._isShown && !this._isTransitioning && this._adjustDialog();
    }), A.on(this._element, Hy, (t) => {
      A.one(this._element, Py, (e) => {
        if (!(this._element !== t.target || this._element !== e.target)) {
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          this._config.backdrop && this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
      document.body.classList.remove(ic), this._resetAdjustments(), this._scrollBar.reset(), A.trigger(this._element, ky);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(Vy);
  }
  _triggerBackdropTransition() {
    if (A.trigger(this._element, Iy).defaultPrevented)
      return;
    const e = this._element.scrollHeight > document.documentElement.clientHeight, s = this._element.style.overflowY;
    s === "hidden" || this._element.classList.contains(Wn) || (e || (this._element.style.overflowY = "hidden"), this._element.classList.add(Wn), this._queueCallback(() => {
      this._element.classList.remove(Wn), this._queueCallback(() => {
        this._element.style.overflowY = s;
      }, this._dialog);
    }, this._dialog), this._element.focus());
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0;
    if (s && !t) {
      const n = St() ? "paddingLeft" : "paddingRight";
      this._element.style[n] = `${e}px`;
    }
    if (!s && t) {
      const n = St() ? "paddingRight" : "paddingLeft";
      this._element.style[n] = `${e}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const s = Vd.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
};
const Xy = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", jy = ".sticky-top", Uy = () => {
  _s("body", "overflow"), _s("body", "paddingRight"), _s(Xy, "paddingRight"), _s(jy, "marginRight");
}, _s = (i, t) => {
  u.find(i).forEach((e) => {
    const s = a.getDataAttribute(e, t);
    typeof s > "u" ? e.style.removeProperty(t) : (a.removeDataAttribute(e, t), e.style[t] = s);
  });
}, Yn = "modal", Co = "bs.modal", Go = `.${Co}`, Gy = 992, Fn = "modal-non-invasive-open", Kn = "modal-non-invasive-show", qy = "show", Qy = "modal", Zy = "modal-open", Jy = "modal-content", tA = "modal-bottom", eA = "modal-bottom-right", iA = "modal-bottom-left", sA = "modal-top-right", nA = "modal-top-left", oA = "modal-dialog-scrollable", rA = "modal-dialog", nc = `.${Jy}`, aA = `.${tA}`, lA = `.${eA}`, cA = `.${iA}`, hA = `.${sA}`, dA = `.${nA}`, uA = `.${oA}`, pA = `.${rA}`, oc = `show${Go}`, rc = `shown${Go}`, ac = `hidden${Go}`, _A = "hide.bs.modal", fA = "hidePrevented.bs.modal", mA = [
  { name: "show", parametersToCopy: ["relatedTarget"] },
  { name: "shown", parametersToCopy: ["relatedTarget"] },
  { name: "hide" },
  { name: "hidePrevented" },
  { name: "hidden" }
], lc = {
  backdrop: !0,
  keyboard: !0,
  focus: !0,
  show: !0,
  modalNonInvasive: !1
}, gA = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean",
  show: "boolean",
  modalNonInvasive: "boolean"
};
class Wd extends zy {
  constructor(t, e) {
    super(t, e), this._config = this._getConfig(e), this._modalContentRect = "", this._modalContentComputedStyles = "", this._isNonInvasive = this._config.modalNonInvasive, this._isScrollable = "", this._isBottomRight = "", this._isBottomLeft = "", this._isTopRight = "", this._isTopLeft = "", this._isSideTopModal = "", this._isSideBottomModal = "", this._isSideModal = "", this._isModalBottom = "", this._isNonInvasive && (this._config.backdrop = !1, this._config.focus = !1, this._isBodyOverflowing = !0, this._onModalShow(), this._onModalShown(), this._onModalHidden(), this._listenToWindowResize()), P.setData(t, Co, this), this._bindMdbEvents(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return Yn;
  }
  // Public
  dispose() {
    h.off(this._element, oc), h.off(this._element, rc), h.off(this._element, _A), h.off(this._element, ac), h.off(this._element, fA), this._modalContentRect = null, this._modalContentComputedStyles = null, this._isNonInvasive = null, this._isScrollable = null, this._isBottomRight = null, this._isBottomLeft = null, this._isTopRight = null, this._isTopLeft = null, this._isSideTopModal = null, this._isSideBottomModal = null, this._isSideModal = null, this._isModalBottom = null, a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _onModalShow() {
    h.on(this._element, oc, () => {
      this._addNonInvasiveClass();
    });
  }
  _onModalShown() {
    h.on(this._element, rc, () => {
      const t = u.findOne(nc, this._element);
      this._isScrollable = u.findOne(uA, this._element), this._isBottomRight = u.findOne(lA, this._element), this._isBottomLeft = u.findOne(cA, this._element), this._isTopRight = u.findOne(hA, this._element), this._isTopLeft = u.findOne(dA, this._element), this._isSideTopModal = this._isTopLeft || this._isTopRight, this._isSideBottomModal = this._isBottomLeft || this._isBottomRight, this._isSideModal = this._isSideTopModal || this._isSideBottomModal, this._isModalBottom = u.findOne(aA, this._element), this._modalContentRect = t.getBoundingClientRect(), this._modalContentComputedStyles = window.getComputedStyle(t), this._modalDialogComputedStyles = window.getComputedStyle(
        u.findOne(pA, this._element)
      ), this._topOffset = parseInt(this._modalDialogComputedStyles.top, 0), this._leftOffset = parseInt(this._modalDialogComputedStyles.left, 0), this._rightOffset = parseInt(this._modalDialogComputedStyles.right, 0), this._bottomOffset = parseInt(this._modalDialogComputedStyles.bottom, 0), this._addOpenClass(), this._setStyles();
    });
  }
  _listenToWindowResize() {
    h.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    const t = u.findOne(nc, this._element);
    if (this._resetStyles(), this._modalContentRect = t.getBoundingClientRect(), this._modalContentComputedStyles = window.getComputedStyle(t), this._isSideTopModal || this._isSideBottomModal) {
      let e = 0, s = 0;
      (this._isBottomRight || this._isBottomLeft) && (s = -this._bottomOffset), (this._isBottomRight || this._isTopRight) && (e = -this._rightOffset), (this._isBottomLeft || this._isTopLeft) && (e = this._leftOffset), this._setStyles(e, s);
      return;
    }
    this._setStyles();
  }
  _showBackdrop(t) {
    this._isNonInvasive ? typeof t == "function" && t() : super._showBackdrop(t);
  }
  _adjustDialog() {
    super._adjustDialog();
    const t = document.body.classList.contains(Fn);
    (this._isNonInvasive || t) && (this._isBodyOverflowing = !1), this._isNonInvasive && (this._resetAdjustments(), Uy());
  }
  _onModalHidden() {
    h.on(this._element, ac, (t) => {
      t.stopImmediatePropagation(), this._removeOpenClass(), this._resetStyles(), this._removeNonInvasiveClass();
    });
  }
  _addOpenClass() {
    this._element.classList.add(Kn);
  }
  _removeOpenClass() {
    this._element.classList.remove(Kn);
  }
  _addNonInvasiveClass() {
    document.body.classList.add(Fn);
  }
  _removeNonInvasiveClass() {
    u.findOne(
      `.${Qy}.${qy}.${Kn}`,
      document.body
    ) ? document.body.classList.add(Zy) : document.body.classList.remove(Fn);
  }
  _setStyles(t = 0, e = 0) {
    const s = window.innerWidth >= Gy;
    this._element.style.left = `${this._modalContentRect.left + t}px`, this._element.style.width = this._modalContentComputedStyles.width, this._isScrollable || (this._element.style.height = this._modalContentComputedStyles.height, this._element.style.display = ""), s && ((this._isSideBottomModal || this._isModalBottom) && (this._element.style.top = `${this._modalContentRect.top + e}px`), this._isSideModal && (this._element.style.overflowX = "auto")), s || (this._element.style.height = "");
  }
  _resetStyles() {
    this._element.style.left = "", this._element.style.top = "", this._element.style.height = "", this._element.style.width = "", this._isScrollable || (this._element.style.display = ""), this._isSideModal && (this._element.style.overflowX = "");
  }
  _getConfig(t) {
    let e;
    this._element && (e = Te(this._element));
    const s = {
      ...lc,
      ...a.getDataAttributes(this._element),
      ...a.getDataAttributes(e),
      ...t
    };
    return Y(Yn, s, gA), s;
  }
  // Private
  _bindMdbEvents() {
    h.extend(this._element, mA, Yn);
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Co);
      const n = {
        ...lc,
        ...a.getDataAttributes(this),
        // eslint-disable-next-line no-extra-parens
        ...typeof t == "object" && t ? t : {}
      };
      if (s || (s = new Wd(this, n)), typeof t == "string") {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      } else
        n.show && s.show(e);
    });
  }
}
const cc = "clipboard", Yd = "mdb.clipboard", bA = `.${Yd}`, vA = {
  clipboardTarget: null
}, EA = {
  clipboardTarget: "null|string"
}, TA = `copied${bA}`;
class Fd extends F {
  constructor(t, e = {}) {
    super(t), this._options = e, this._element && (this._initCopy = this._initCopy.bind(this), this._setup(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor));
  }
  // Getters
  static get NAME() {
    return cc;
  }
  get options() {
    const t = {
      ...vA,
      ...a.getDataAttributes(this._element),
      ...this._options
    };
    return Y(cc, t, EA), t;
  }
  get clipboardTarget() {
    return u.findOne(this.options.clipboardTarget);
  }
  get copyText() {
    const t = this.clipboardTarget.hasAttribute("data-mdb-clipboard-text"), e = this.clipboardTarget.value, s = this.clipboardTarget.textContent;
    return t ? this.clipboardTarget.getAttribute("data-mdb-clipboard-text") : e || s;
  }
  // Public
  dispose() {
    h.off(this._element, "click", this._initCopy), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _setup() {
    h.on(this._element, "click", this._initCopy);
  }
  _initCopy() {
    const t = this._createNewInput();
    document.body.appendChild(t), this._selectInput(t), h.trigger(this._element, TA, { copyText: this.copyText }), t.remove();
  }
  _createNewInput() {
    const t = this.clipboardTarget.tagName === "TEXTAREA" ? "textarea" : "input", e = O(t);
    return e.value = this.copyText, a.style(e, { left: "-9999px", position: "absolute" }), e;
  }
  _selectInput(t) {
    t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand("copy");
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, Yd);
      const s = typeof t == "object" && t;
      if (e || (e = new Fd(this, s)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const CA = ({ inputID: i, labelText: t }) => `<div class="form-outline chips-input-wrapper">
      <input type="text" id="${i}" class="form-control chips-input" />
      <label class="form-label" for="${i}">
        ${t}
      </label>

      <div class="form-notch">
        <div class="form-notch-leading" style="width: 9px;"></div>
        <div class="form-notch-middle" style="width: 87.2px;"></div>
        <div class="form-notch-trailing"></div>
      </div>
    </div>`, yA = ({ text: i }) => `<div class="chip btn"><span class="text-chip">${i}</span> <i class="close fas fa-times"></i></div>`, yo = "chip", hc = `mdb.${yo}`, zn = ".close", AA = "delete.mdb.chips", SA = "select.mdb.chip", wA = { text: "string", closeIcon: "boolean", img: "object" }, OA = { text: "", closeIcon: !1, img: { path: "", alt: "" } };
class me extends F {
  constructor(t, e = {}) {
    super(t, e), this._options = this._getConfig(e), this._element && P.setData(t, hc, this), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return yo;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    h.off(this._element, "click"), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  appendChip() {
    const { text: t, closeIcon: e } = this._options;
    return yA({ text: t, closeIcon: e });
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(u.find(zn, this._element).length > 0) && this._options.closeIcon) {
      const e = O("i");
      e.classList = "close fas fa-times", t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    h.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, s = {};
      s.tag = e.trim(), h.trigger(SA, { event: t, obj: s });
    });
  }
  _handleDelete() {
    u.find(zn, this._element).length !== 0 && h.on(this._element, "click", zn, () => {
      h.trigger(this._element, AA), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ...OA,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(yo, e, wA), e;
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, hc);
      const s = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new me(this, s)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const oe = "chips", $A = `mdb.${oe}`, yt = "active", dc = `${oe}-initial`, uc = `${oe}-placeholder`, DA = "close-opacity", pc = "chip-opacity", Re = `${oe}-padding`, _c = `${oe}-transition`, NA = `${oe}-input-wrapper`, Ao = ".chip", LA = `${Ao}.${yt}`, IA = ".close", kA = "add.mdb.chips", MA = "added.mdb.chips", xA = "arrowDown.mdb.chips", RA = "arrowLeft.mdb.chips", PA = "arrowRight.mdb.chips", HA = "arrowUp.mdb.chips", fc = "delete.mdb.chips", mc = "select.mdb.chips", BA = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string"
}, VA = {
  inputID: "",
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label"
};
class Kd extends me {
  constructor(t, e = {}) {
    super(t, e), this._options = this._getConfig(e), this.numberClicks = 0, this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return oe;
  }
  get activeChip() {
    return u.findOne(LA, this._element);
  }
  get input() {
    return u.findOne("input", this._element);
  }
  get allChips() {
    return u.find(Ao, this._element);
  }
  get chipsInputWrapper() {
    return u.findOne(`.${NA}`, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(uc), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips();
  }
  dispose() {
    a.removeClass(this._element, "chips"), this.allChips.forEach((t) => {
      const e = me.getInstance(t);
      e && (t.remove(), h.off(t, "dblclick"), e.dispose());
    }), this.chipsInputWrapper.remove(), h.off(this._element, "click"), h.off(this._element, "keyup"), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _setChipsClass() {
    a.addClass(this._element, "chips");
  }
  _handleDeleteEvents(t) {
    const [e] = this.allChips.slice(-1);
    if (this.activeChip === null)
      e.remove(), this._handleEvents(t, fc);
    else {
      const s = this.allChips.findIndex((r) => r === this.activeChip), n = this._handleActiveChipAfterRemove(s), o = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(t, fc), this.numberClicks = s, a.addClass(n, yt), this.allChips.forEach((r) => {
        a.hasClass(r, yt) && (o.push(r), o.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(t) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(t, PA), this._handleEvents(t, HA);
  }
  _handleDownEvents(t) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(t, RA), this._handleEvents(t, xA);
  }
  _keyboardEvents(t) {
    const { target: e, keyCode: s, ctrlKey: n } = t;
    e.value.length > 0 || this.allChips.length === 0 || (s === yb || s === Ab ? this._handleDeleteEvents(t) : s === Ge || s === tt ? this._handleUpEvents(t) : s === Ue || s === J ? this._handleDownEvents(t) : s === 65 && n && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    h.on(this.input, "keydown", (t) => this._keyboardEvents(t));
  }
  _handleEditable() {
    const { editable: t } = this._options;
    t && this.allChips.forEach((e) => {
      h.on(e, "dblclick", (s) => {
        const n = u.findOne(".close", e);
        e.contentEditable = !0, e.focus(), setTimeout(() => {
          a.addStyle(n, { display: "none" });
        }, 200), a.addClass(n, "close-opacity"), s.target.textContent, h.trigger(e, mc, { event: s, allChips: this.allChips });
      }), h.on(document, "click", ({ target: s }) => {
        const n = u.findOne(".close", e), o = u.findOne(".text-chip", e), r = s === e, l = e && e.contains(s);
        !r && !l && (e.contentEditable = !1, o.textContent !== "" && setTimeout(() => {
          a.addStyle(n, { display: "block" }), a.removeClass(n, "close-opacity");
        }, 160)), o.textContent === "" && (setTimeout(() => {
          a.addClass(e, pc);
        }, 200), setTimeout(() => {
          e.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((t) => a.removeClass(t, yt));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((t) => a.addClass(t, yt));
  }
  _handleRightKeyboardArrow(t) {
    this._handleRemoveActiveClass(), t === 0 && (t = 1), this._handleAddActiveClassWithKeyboard(t);
  }
  _handleLeftKeyboardArrow(t) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKeyboard(t);
  }
  _handleActiveChipAfterRemove(t) {
    const e = t === 0 ? 1 : t - 1;
    return this.allChips[e];
  }
  _handleClicksOnChips() {
    h.on(this._element, "click", () => {
      this.allChips.length === 0 && (a.removeClass(this.chipsInputWrapper, Re), a.removeClass(this.input, yt));
    });
  }
  _handleTextContent() {
    const t = [];
    return this.allChips.forEach((e) => t.push({ tag: e.textContent.trim() })), t;
  }
  _handleEvents(t, e) {
    const s = this._handleTextContent(), n = this.allChips.filter(
      (o) => a.hasClass(o, yt) && o
    );
    h.trigger(this._element, e, {
      event: t,
      allChips: this.allChips,
      arrOfObjects: s,
      active: n,
      activeObj: {
        tag: n.length <= 0 ? "" : n[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    h.on(this._element, "click", ({ target: { classList: t } }) => {
      t.contains("chip") || t.contains("close") || t.contains("text-chip") || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement(dc), a.hasClass(this._element, dc)) {
      const { initialValues: t } = this._options;
      t.forEach(({ tag: e }) => this._handleCreateChip(this.input, e)), a.addClass(this.input, yt);
    }
    this.allChips.length > 0 && (a.addClass(this.chipsInputWrapper, Re), a.addClass(this.chipsInputWrapper, _c));
  }
  _handleKeysInputToElement(t) {
    const { keyCode: e, target: s } = t;
    if (a.hasClass(s, "chip")) {
      const n = u.findOne(IA, s);
      e === ot && (s.contentEditable = !1, s.textContent !== "" ? setTimeout(() => {
        a.addStyle(n, { display: "block" }), a.removeClass(n, DA);
      }, 160) : s.textContent === "" && (setTimeout(() => {
        a.addClass(s, pc);
      }, 200), setTimeout(() => {
        s.remove();
      }, 300)));
      return;
    }
    if (e === ot) {
      if (s.value === "")
        return;
      this._handleCreateChip(s, s.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1;
    }
    this.allChips.length > 0 ? (a.addClass(this.chipsInputWrapper, Re), a.addClass(this.chipsInputWrapper, _c)) : a.removeClass(this.chipsInputWrapper, Re);
  }
  _handleBlurInput(t) {
    const { target: e } = t;
    e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (a.addClass(e, yt), a.addClass(this.chipsInputWrapper, Re)) : (a.removeClass(e, yt), a.removeClass(this.chipsInputWrapper, Re)), this.allChips.forEach((s) => a.removeClass(s, yt));
  }
  _handleInputText() {
    const t = u.findOne(uc, this._element);
    h.on(this._element, "keyup", t, (e) => this._handleKeysInputToElement(e)), h.on(this.input, "blur", (e) => this._handleBlurInput(e));
  }
  _appendInputToElement(t) {
    if (!a.hasClass(this._element, t))
      return;
    const e = CA(this._options);
    this._element.insertAdjacentHTML("beforeend", e);
  }
  _handleCreateChip(t, e) {
    if (h.trigger(this._element, kA, { value: e }).defaultPrevented)
      return;
    const n = O("div"), o = new me(n, { text: e });
    let r;
    if (this._options.parentSelector !== "") {
      const l = document.querySelector(this._options.parentSelector);
      l.insertAdjacentHTML("beforeend", o.appendChip()), r = l;
    } else
      t.insertAdjacentHTML("beforebegin", o.appendChip()), r = t.parentNode;
    t.value = "", u.find(Ao, r).forEach((l) => {
      let c = me.getInstance(l);
      c || (c = new me(l), c.init());
    }), this._handleEditable(), h.trigger(this._element, MA, { value: e });
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((t) => {
      h.on(this._element, "click", (e) => {
        h.trigger(t, mc, { event: e, allChips: this.allChips });
      });
    });
  }
  _handleAddActiveClassWithKeyboard(t) {
    let e;
    this.allChips[t - 1] === void 0 ? e = this.allChips[t - 2] : e = this.allChips[t - 1], a.addClass(e, yt);
  }
  _getConfig(t) {
    const e = {
      ...VA,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(oe, e, BA), e;
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = P.getData(this, $A);
      const s = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new Kd(this, s)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const WA = () => `<div class="multi-range-slider-connects">
<div class="multi-range-slider-connect"></div>
</div>`, YA = () => `<div class="multi-range-slider-hand">
  <div class="multi-range-slider-handle"></div>
</div>`, FA = (i) => `
  <span class="multi-range-slider-tooltip">
    <span class="multi-range-slider-tooltip-value">${i}</span>
  </span>
  `, xt = (i) => i.type === "touchmove" ? i.touches[0].clientX : i.clientX, So = "multiRangeSlider", zd = `mdb.${So}`, KA = "multi-range-slider", Xd = `.${zd}`, gc = `valueChanged${Xd}`, zA = `start${Xd}`, Xn = ".multi-range-slider-hand", XA = ".multi-range-slider-connect", jA = ".multi-range-slider-tooltip", mi = "active", UA = "multi-range-slider-horizontal", GA = "multi-range-slider-vertical", qA = {
  direction: "string",
  margin: "(string||number||null)",
  max: "number",
  min: "number",
  numberOfRanges: "number",
  orientation: "string",
  padding: "(string||number||null)",
  startValues: "array",
  step: "(string||null||number)",
  tooltips: "boolean"
}, QA = {
  direction: "",
  margin: null,
  max: 100,
  min: 0,
  numberOfRanges: 2,
  orientation: "horizontal",
  padding: null,
  startValues: [0, 100],
  step: null,
  tooltips: !1
};
class jd extends F {
  constructor(t, e = {}) {
    super(t), this._options = this._getConfig(e), this._mousemove = !1, this.init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return So;
  }
  get hands() {
    return u.find(Xn, this._element);
  }
  get connect() {
    return u.findOne(XA, this._element);
  }
  get leftConnectRect() {
    return this.connect.getBoundingClientRect().left;
  }
  get handsNoActive() {
    return this.hands.filter((t) => !a.hasClass(t, "active"));
  }
  get handActive() {
    return u.findOne(`${Xn}.active`);
  }
  get activeTooltip() {
    return u.findOne(jA);
  }
  get activeTooltipValue() {
    return u.findOne(`${Xn}.active`).children[1].children[0];
  }
  // Public
  init() {
    this._setClassHorizontalOrVertical(), this._setRangeConnectsElement(), this._setRangeHandleElements(), this._setTransofrmationOnStart(), this._handleClickEventOnHand(), this._handleEndMoveEventDocument(), this._handleClickOnRange(), this._setValueEventOnMouseDown(), this._setTooltipToHand();
  }
  dispose() {
    a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  // Private
  _setTransofrmationOnStart() {
    const { startValues: t, max: e, min: s } = this._options;
    t.length === 0 ? this.hands.forEach((n) => {
      const o = -n.offsetWidth;
      a.setDataAttribute(n, "translation", Math.round(o)), a.addStyle(n, {
        transform: `translate(${o}px,-25%)`
      });
    }) : this.hands.forEach((n, o) => {
      if (t[o] > e || t[o] < s)
        return;
      const l = (t[o] - s) / (e - s) * this.connect.offsetWidth - n.offsetWidth / 2;
      a.setDataAttribute(n, "translation", Math.round(l)), a.addStyle(n, {
        transform: `translate(${l}px,-25%)`
      });
    });
  }
  _handleClickEventOnHand() {
    const { max: t, min: e } = this._options;
    this.hands.forEach((s, n) => {
      ut.on(s, "mousedown touchstart", (o) => {
        this._mousemove = !0;
        const r = xt(o) - this.leftConnectRect - s.offsetWidth / 2, l = (xt(o) - this.leftConnectRect) / (this.connect.offsetWidth / (t - e)) % (t - e);
        a.addStyle(s, {
          transform: `translate(${r}px,-25%)`
        }), a.setDataAttribute(s, "translation", r), a.addClass(s, mi), this._options.tooltip && (a.addClass(s.children[1], "active"), this.activeTooltipValue.innerText = Math.round(l)), this._handleMoveEvent(s, n), this._handleEndMoveEvent(s, o);
      });
    });
  }
  _setValueEventOnMouseDown() {
    ut.on(this.connect, "mousedown touchstart", (t) => {
      const { max: e, min: s, numberOfRanges: n } = this._options;
      if (n < 2) {
        const o = Math.round(
          (xt(t) - this.leftConnectRect) / (t.target.offsetWidth / (e - s))
        ) % (e - s);
        h.trigger(this._element, zA, {
          values: { value: o + s, rounded: Math.round(o + s) }
        });
      }
    });
  }
  _setClassHorizontalOrVertical() {
    a.addClass(this._element, KA), this._options.orientation === "horizontal" ? a.addClass(this._element, UA) : a.addClass(this._element, GA);
  }
  _setRangeConnectsElement() {
    this._element.insertAdjacentHTML("afterbegin", WA());
  }
  _setRangeHandleElements() {
    for (let t = 0; t < this._options.numberOfRanges; t++)
      this._element.insertAdjacentHTML("beforeend", YA());
    this.hands.forEach((t, e) => {
      t.setAttribute("aria-orientation", this._options.orientation), t.setAttribute("role", "slider"), a.setDataAttribute(t, "handle", e);
    });
  }
  _setTooltipToHand() {
    this._options.tooltip && this.hands.forEach((t) => t.insertAdjacentHTML("beforeend", FA()));
  }
  _handleMoveEvent(t) {
    const { tooltip: e, step: s } = this._options;
    ut.on(document, "mousemove touchmove", (n) => {
      n.type === "mousemove" && n.preventDefault();
      const { max: o, min: r, numberOfRanges: l } = this._options;
      if (a.hasClass(t, mi)) {
        const c = (xt(n) - this.leftConnectRect) / this.connect.offsetWidth * o;
        let d = (xt(n) - this.leftConnectRect) / (this.connect.offsetWidth / (o - r)) % (o - r) + r, p = xt(n) - this.leftConnectRect - t.offsetWidth / 2;
        const f = a.getDataAttribute(this.handActive, "handle"), m = a.getDataAttribute(this.handActive, "translation");
        if (d < r)
          p = r - t.offsetWidth / 2, d = r;
        else if (c >= o)
          return;
        const g = this.handsNoActive.map(
          (b) => a.getDataAttribute(b, "handle")
        ), _ = this.handsNoActive.map(
          (b) => a.getDataAttribute(b, "translation")
        );
        f < g && m <= _ ? Math.round(d) % s === 0 && s !== null ? (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d))) : s === null && (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d))) : f > g && m >= _ && (Math.round(d) % s === 0 && s !== null ? (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d))) : s === null && (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d)))), l < 2 && (Math.round(d) % s === 0 && s !== null ? (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d))) : s === null && (a.addStyle(t, {
          transform: `translate(${p}px,-25%)`
        }), e && (this.activeTooltipValue.innerText = Math.round(d)))), a.setDataAttribute(t, "translation", p), l < 2 ? h.trigger(this._element, gc, {
          values: { value: d + r, rounded: Math.round(d + r) }
        }) : this._handleMultiValuesOnRange();
      }
    });
  }
  _handleMultiValuesOnRange() {
    const { max: t, min: e } = this._options, s = [];
    this.hands.forEach((n) => {
      const o = n.getBoundingClientRect().left - this.leftConnectRect + n.offsetWidth / 2;
      let r = o / (this.connect.offsetWidth / (t - e)) % (t - e);
      o === this.connect.offsetWidth ? r = t : r += e, a.setDataAttribute(n, "value", Math.round(r * 10) / 10), s.push({ value: r });
    }), h.trigger(this._element, gc, {
      values: {
        value: s.map(({ value: n }) => n),
        rounded: s.map(({ value: n }) => Math.round(n))
      }
    });
  }
  _handleEndMoveEventDocument() {
    ut.on(document, "mouseup touchend", () => {
      this._mousemove && (this.hands.forEach((t) => {
        h.off(t, "mousemove"), a.removeClass(t, mi), this._options.tooltip && a.removeClass(t.children[1], "active");
      }), this._mousemove = !1);
    });
  }
  _handleEndMoveEvent(t) {
    ut.on(t, "mouseup touchend", () => {
      h.off(t, "mousemove"), a.removeClass(t, mi), this._options.tooltip && a.removeClass(t.children[1], "active"), this._mousemove = !1;
    });
  }
  _handleClickOnRange() {
    ut.on(this.connect, "mousedown touchstart", (t) => {
      this.hands.forEach((e) => {
        a.addClass(e, mi), this._mousemove = !0, this._options.numberOfRanges < 2 ? a.addStyle(e, {
          transform: `translate(${xt(t) - this.leftConnectRect - e.offsetWidth / 2}px,-25%)`
        }) : a.addStyle(this.hands[0], {
          transform: `translate(${xt(t) - this.leftConnectRect - e.offsetWidth / 2}px,-25%)`
        });
      });
    });
  }
  _handlePadding() {
    ut.on(this.connect, "mousedown touchstart", (t) => {
      const { padding: e, numberOfRanges: s } = this._options;
      let n;
      return s < 2 && (n = Math.round(
        (xt(t) - this.leftConnectRect) / (t.target.offsetWidth / e)
      ) % e), n;
    });
  }
  _setMovingTooltipEvent() {
    ut.on(this.connect, "mousemove", (t) => {
      const e = (xt(t) - this.leftConnectRect) / t.target.offsetWidth, s = `${Math.round(e * 100)}%`;
      h.trigger(this._element, "movetooltip", {
        percents: { value: e, percent: s }
      });
    });
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, zd);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose|hide/.test(t)) && (s || (s = new jd(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
  _getConfig(t) {
    const e = {
      ...QA,
      ...a.getDataAttributes(this._element),
      ...t
    };
    return Y(So, e, qA), e;
  }
}
const ZA = (i) => {
  const t = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, e = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
  return i.match(t) || i.match(e);
}, JA = (i) => i && Object.prototype.toString.call(i) === "[object Date]" && !isNaN(i), tS = (i) => i.getMonth(), eS = (i) => i.getFullYear(), iS = (i) => i.match(/[^(dmy)]{1,}/g), sS = (i, t, e, s) => {
  let n;
  e[0] !== e[1] ? n = e[0] + e[1] : n = e[0];
  const o = new RegExp(`[${n}]`), r = i.split(o), l = t.split(o), c = t.indexOf("mmm") !== -1, d = [];
  for (let b = 0; b < l.length; b++)
    l[b].indexOf("yy") !== -1 && (d[0] = { value: r[b], format: l[b] }), l[b].indexOf("m") !== -1 && (d[1] = { value: r[b], format: l[b] }), l[b].indexOf("d") !== -1 && l[b].length <= 2 && (d[2] = { value: r[b], format: l[b] });
  let p;
  t.indexOf("mmmm") !== -1 ? p = s.monthsFull : p = s.monthsShort;
  const f = Number(d[0].value), m = c ? nS(d[1].value, p) : Number(d[1].value) - 1, g = Number(d[2].value);
  return $t(f, m, g);
}, nS = (i, t) => t.findIndex((e) => e === i), oS = `
  <button type="button" class="datepicker-button-toggle"  data-mdb-toggle="datepicker">
    <i class="far fa-calendar datepicker-toggle-icon"></i>
  </button>
  <button type="button" class="timepicker-button-toggle" data-mdb-toggle="timepicker">
    <i class="far fa-clock fa-sm timepicker-icon"></i>
  </button>
`, rS = `
  <button type="button" class="datetimepicker-toggle-button" data-mdb-toggle="datetimepicker">
    <i class="far fa-calendar datepicker-toggle-icon"></i>
  </button>
`, wi = "datetimepicker", Ud = `mdb.${wi}`, wo = "datepicker", Ei = "timepicker", aS = `${wi}-toggle-button`, Gd = "invalid-feedback", bc = "is-invalid", _e = `.${Ei}`, vc = `.${wo}`, lS = `[data-mdb-toggle="${wi}"]`, cS = `.${aS}`, Ec = `.${Gd}`, qo = `.${Ud}`, hS = `open${qo}`, dS = `close${qo}`, uS = `valueChanged${qo}`, Tc = "close.mdb.datepicker", Cc = "valueChanged.mdb.timepicker", fs = O("div"), yc = {
  appendValidationInfo: !0,
  inline: !1,
  toggleButton: !0,
  container: "body",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  defaultTime: "",
  defaultDate: "",
  timepicker: {},
  datepicker: {},
  invalidLabel: "Invalid Date or Time Format",
  showFormat: !1
}, pS = {
  appendValidationInfo: "boolean",
  inline: "boolean",
  toggleButton: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  defaultTime: "(string|date|number)",
  defaultDate: "(string|date|number)",
  timepicker: "object",
  datepicker: "object",
  invalidLabel: "string",
  showFormat: "boolean"
};
class qd extends F {
  constructor(t, e) {
    super(t), this._input = u.findOne("input", this._element), this._options = this._getConfig(e), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate ? this._options.defaultDate : "", this._timeValue = this._options.defaultTime ? this._options.defaultTime : "", this._isInvalidTimeFormat = !1, this._validationInfo = null, this._format = this._options.datepicker.format ? this._options.datepicker.format : "dd/mm/yyyy", this._cancel = !1, this._scrollBar = new Ze(), this._init(), a.setDataAttribute(this._element, `${this.constructor.NAME}-initialized`, !0), R(this.constructor);
  }
  // Getters
  static get NAME() {
    return wi;
  }
  get toggleButton() {
    return u.findOne(cS, this._element);
  }
  dispose() {
    h.off(this._element, "click", this._openDatePicker), h.off(this._input, "input", this._handleInput), h.off(this._element, "click"), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton && this.toggleButton.remove(), a.removeDataAttribute(this._element, `${this.constructor.NAME}-initialized`), super.dispose();
  }
  update(t = {}) {
    const e = this._getConfig({ ...this._options, ...t });
    h.off(this._element, "click", this._openDatePicker), h.off(this._input, "input", this._handleInput), h.off(this._element, "click"), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton && this.toggleButton.remove(), this._options = yc, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null, this._validationInfo = null, this._options = e, this._init();
  }
  // Private
  _init() {
    this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._appendValidationInfo(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture();
  }
  _removeDatepicker() {
    const t = this._element.querySelector(".datepicker");
    t && t.remove();
  }
  _addDatepicker() {
    const t = O("div");
    t.id = this._element.id ? `datepicker-${this._element.id}` : Ot("datepicker-");
    const e = '<input type="text" class="form-control">';
    t.innerHTML = e, a.addClass(t, wo), this._element.appendChild(t), a.style(t, { display: "none" });
    let s = {
      ...this._options.datepicker,
      container: this._options.container,
      disablePast: this._options.disablePast,
      disableFuture: this._options.disableFuture
    };
    (this._options.inline || this._options.datepicker.inline) && (s = { ...s, inline: !0 }), this._datepicker = new zo(t, s), this._datepicker._input.value = this._dateValue;
  }
  _removeTimePicker() {
    const t = this._element.querySelector(".timepicker");
    t && (t.remove(), this._scrollBar.reset());
  }
  _addTimePicker() {
    const t = O("div");
    t.id = this._element.id ? `timepicker-${this._element.id}` : Ot("timepicker-");
    const e = '<input type="text" class="form-control">';
    t.innerHTML = e, a.addClass(t, Ei), this._element.appendChild(t), a.style(t, { display: "none" });
    let s = {
      ...this._options.timepicker,
      container: this._options.container
    };
    (this._options.inline || this._options.timepicker.inline) && (s = { timepickerOptions: s, inline: !0 }), this._timepicker = new Ko(t, s), this._timepicker.input.value = this._timeValue;
  }
  _addIconButtons() {
    if (a.addClass(fs, "buttons-container"), fs.innerHTML = oS, !(this._options.inline || this._options.datepicker.inline)) {
      if (this._scrollBar.hide(), this._datepicker._isOpen)
        u.findOne(`${vc}-header`, document.body).appendChild(fs);
      else if (this._timepicker._modal && !this._options.timepicker.inline) {
        const t = u.findOne(`${_e}-elements`, document.body), e = u.findOne(
          `${_e}-clock-wrapper`,
          document.body
        );
        t.insertBefore(fs, e);
      }
    }
  }
  _enableOrDisableToggleButton() {
    this._options.disabled ? (this.toggleButton.disabled = !0, this.toggleButton.style.pointerEvents = "none") : (this.toggleButton.disabled = !1, this.toggleButton.style.pointerEvents = "pointer");
  }
  _appendToggleButton() {
    this._options.toggleButton && (this._element.insertAdjacentHTML("beforeend", rS), this._enableOrDisableToggleButton());
  }
  _appendValidationInfo() {
    const { invalidLabel: t, appendValidationInfo: e } = this._options;
    e && (this._validationInfo = O("div"), a.addClass(this._validationInfo, Gd), this._validationInfo.innerHTML = t, a.addStyle(this._input, { marginBottom: 0 }), a.addStyle(this._validationInfo, { bottom: "-23px" }));
  }
  _applyFormatPlaceholder() {
    this._options.showFormat && (this._input.placeholder = this._format);
  }
  _listenToCancelClick() {
    const t = u.findOne(
      `${vc}-cancel-btn`,
      document.body
    );
    h.one(t, "mousedown", () => {
      this._cancel = !0, this._scrollBar.reset(), h.off(t, "mousedown");
    });
  }
  _listenToToggleClick() {
    h.on(this._element, "click", lS, (t) => {
      t.preventDefault(), this._openDatePicker();
    });
  }
  _listenToUserInput() {
    h.on(this._input, "input", (t) => {
      this._handleInput(t.target.value);
    });
  }
  _disableInput() {
    this._options.disabled && (this._input.disabled = "true");
  }
  _getConfig(t) {
    const e = a.getDataAttributes(this._element);
    return t = {
      ...yc,
      ...e,
      ...t
    }, Y(wi, t, pS), t;
  }
  _handleInput(t) {
    const e = t.split(", "), s = iS(this._format), n = e[0], o = e[1] || "", r = sS(
      n,
      this._format,
      s,
      this._datepicker._options
    );
    n ? e.length === 2 ? JA(r) && ZA(o) ? (this._dateValue = n, this._timeValue = o, this._removeInvalidClass(this._input), this._datepicker._input.value = this._dateValue, this._datepicker._activeDate = this._dateValue, this._datepicker._selectedYear = eS(r), this._datepicker._selectedMonth = tS(r), this._datepicker._headerDate = r, this._timepicker.input.value = this._timeValue, this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = /* @__PURE__ */ new Date(), this._datepicker._selectedDate = null, this._datepicker._selectedMonth = null, this._datepicker._selectedYear = null, this._datepicker._headerDate = null, this._datepicker._headerMonth = null, this._datepicker._headerYear = null, this._timepicker._isInvalidTimeFormat = !0, this._addInvalidClass(this._input, this._validationInfo)) : this._addInvalidClass(this._input, this._validationInfo) : this._removeInvalidClass(this._input);
  }
  _addInvalidClass() {
    const { appendValidationInfo: t } = this._options;
    t && (a.addClass(this._input, bc), u.findOne(Ec) || this._input.parentNode.insertBefore(this._validationInfo, this._input.nextSibling));
  }
  _removeInvalidClass(t) {
    a.removeClass(t, bc), this._isInvalidTimeFormat = !1;
    const e = u.findOne(Ec);
    e !== null && e.remove();
  }
  _openDatePicker() {
    if (h.trigger(this._element, hS).defaultPrevented)
      return;
    this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && (this.toggleButton.style.pointerEvents = "none"), h.one(this._datepicker._element, Tc, () => {
      if (this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel) {
        this._cancel = !1;
        return;
      }
      h.on(this._datepicker.container, "click", (s) => {
        !this._datepicker._selectedDate && s.target.classList.contains("datepicker-ok-btn") || this._openTimePicker();
      }), setTimeout(() => {
        u.findOne(`${_e}-wrapper`, document.body) || this._scrollBar.reset();
      }, 10), this._options.inline && (this.toggleButton.style.pointerEvents = "auto");
    });
    const e = u.findOne(`${_e}-button-toggle`, document.body);
    h.on(e, "click", () => {
      this._datepicker.close(), this._scrollBar.hide(), h.trigger(this._datepicker._element, Tc);
    });
  }
  _handleTimepickerDisablePast() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), h.on(this._datepicker._element, "dateChange.mdb.datepicker", () => {
      this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disablePast: !0 }) : this._timepicker.update({ disablePast: !1 });
    });
  }
  _handleTimepickerDisableFuture() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), h.on(this._datepicker._element, "dateChange.mdb.datepicker", () => {
      this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disableFuture: !0 }) : this._timepicker.update({ disableFuture: !1 });
    });
  }
  _handleEscapeKey() {
    h.one(document.body, "keyup", () => {
      setTimeout(() => {
        u.findOne(`${_e}-wrapper`, document.body) || this._scrollBar.reset();
      }, 250);
    });
  }
  _handleCancelButton() {
    const t = u.findOne(`${_e}-cancel`, document.body);
    h.one(t, "mousedown", () => {
      this._scrollBar.reset();
    });
  }
  _openDropdownDate() {
    const t = this._datepicker._popper;
    t.state.elements.reference = this._input, this._scrollBar.reset();
  }
  _openTimePicker() {
    h.trigger(this._timepicker.elementToggle, "click"), setTimeout(() => {
      if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {
        const t = u.findOne(`${_e}-cancel`, document.body);
        this._handleEscapeKey(), this._handleCancelButton(), h.on(this._timepicker._modal, "click", (e) => {
          (e.target.classList.contains(`${Ei}-wrapper`) || e.target.classList.contains(`${Ei}-submit`)) && setTimeout(() => {
            this._scrollBar.reset();
          }, 200), e.target.classList.contains(`${Ei}-clear`) && h.trigger(this._timepicker._element, Cc), e.target.classList.contains(`${wo}-button-toggle`) && (h.trigger(t, "click"), setTimeout(() => {
            this._openDatePicker(), this._scrollBar.hide();
          }, 200));
        });
      }
    }), h.one(this._timepicker._element, Cc, () => {
      this._timeValue = this._timepicker.input.value, this._updateInputValue(), h.trigger(this._element, dS);
    });
  }
  _openDropdownTime() {
    const t = this._timepicker._popper;
    t.state.elements.reference = this._input, t.update(), this._scrollBar.reset();
  }
  _setInitialDefaultInput() {
    (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue();
  }
  _updateInputValue() {
    this._timeValue && this._dateValue && (this._input.value = `${this._dateValue}, ${this._timeValue}`, this._removeInvalidClass(this._input), h.trigger(this._element, uS).defaultPrevented) || h.trigger(this._input, "focus");
  }
  // static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let s = P.getData(this, Ud);
      const n = typeof t == "object" && t;
      if (!(!s && /dispose/.test(t)) && (s || (s = new qd(this, n)), typeof t == "string")) {
        if (typeof s[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        s[t](e);
      }
    });
  }
}
const _S = (i, t) => {
  const e = i;
  we(e, "close"), u.find(t).forEach((s) => e.getOrCreateInstance(s));
}, fS = (i, t) => {
  const e = i, s = `click.bs.${i.name}.data-api`;
  h.on(document, s, t, (n) => {
    n.preventDefault();
    const o = n.target.closest(t);
    e.getOrCreateInstance(o).toggle();
  }), u.find(t).forEach((n) => e.getOrCreateInstance(n));
}, mS = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = "[data-mdb-slide], [data-mdb-slide-to]", n = "carousel", o = i, r = `load.bs.${i.name}.data-api`, l = t;
  h.on(document, e, s, function(c) {
    const d = Te(this);
    if (!d || !d.classList.contains(n))
      return;
    c.preventDefault();
    const p = o.getOrCreateInstance(d), f = this.getAttribute("data-mdb-slide-to");
    if (f) {
      p.to(f), p._maybeEnableCycle();
      return;
    }
    if (a.getDataAttribute(this, "slide") === "next") {
      p.next(), p._maybeEnableCycle();
      return;
    }
    p.prev(), p._maybeEnableCycle();
  }), h.on(window, r, () => {
    u.find(l).forEach((d) => {
      o.getOrCreateInstance(d);
    });
  });
}, gS = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = t, n = i;
  h.on(document, e, s, function(o) {
    (o.target.tagName === "A" || o.delegateTarget && o.delegateTarget.tagName === "A") && o.preventDefault();
    const r = $s(this);
    u.find(r).forEach((c) => {
      n.getOrCreateInstance(c, { toggle: !1 }).toggle();
    });
  }), u.find(s).forEach((o) => {
    const r = $s(o);
    u.find(r).forEach((c) => {
      n.getOrCreateInstance(c, { toggle: !1 });
    });
  });
}, bS = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = `keydown.bs.${i.name}.data-api`, n = `keyup.bs.${i.name}.data-api`, o = ".dropdown-menu", r = `[data-mdb-${i.NAME}-initialized]`, l = i;
  h.on(
    document,
    s,
    r,
    l.dataApiKeydownHandler
  ), h.on(document, s, o, l.dataApiKeydownHandler), h.on(document, e, l.clearMenus), h.on(document, n, l.clearMenus), h.on(document, e, r, function(c) {
    c.preventDefault(), l.getOrCreateInstance(this).toggle();
  }), u.find(t).forEach((c) => {
    l.getOrCreateInstance(c);
  });
}, vS = (i, t) => {
  const e = t, s = `${e} input`, n = `${e} textarea`, o = i;
  h.on(document, "focus", s, o.activate(new o())), h.on(document, "input", s, o.activate(new o())), h.on(document, "blur", s, o.deactivate(new o())), h.on(document, "focus", n, o.activate(new o())), h.on(document, "input", n, o.activate(new o())), h.on(document, "blur", n, o.deactivate(new o())), h.on(window, "shown.bs.modal", (r) => {
    u.find(s, r.target).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.update();
    }), u.find(n, r.target).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.update();
    });
  }), h.on(window, "shown.bs.dropdown", (r) => {
    const l = r.target.parentNode.querySelector(".dropdown-menu");
    l && (u.find(s, l).forEach((c) => {
      const d = o.getInstance(c.parentNode);
      d && d.update();
    }), u.find(n, l).forEach((c) => {
      const d = o.getInstance(c.parentNode);
      d && d.update();
    }));
  }), h.on(window, "shown.bs.tab", (r) => {
    let l;
    r.target.href ? l = r.target.href.split("#")[1] : l = a.getDataAttribute(r.target, "target").split("#")[1];
    const c = u.findOne(`#${l}`);
    u.find(s, c).forEach((d) => {
      const p = o.getInstance(d.parentNode);
      p && p.update();
    }), u.find(n, c).forEach((d) => {
      const p = o.getInstance(d.parentNode);
      p && p.update();
    });
  }), u.find(e).map((r) => new o(r)), h.on(window, "reset", (r) => {
    u.find(s, r.target).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.forceInactive();
    }), u.find(n, r.target).forEach((l) => {
      const c = o.getInstance(l.parentNode);
      c && c.forceInactive();
    });
  }), h.on(window, "onautocomplete", (r) => {
    const l = o.getInstance(r.target.parentNode);
    !l || !r.cancelable || l.forceActive();
  });
}, ES = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".modal.show", n = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  h.on(document, e, t, function(l) {
    const c = Te(this);
    ["A", "AREA"].includes(this.tagName) && l.preventDefault(), h.one(c, o, (f) => {
      f.defaultPrevented || h.one(c, r, () => {
        Kt(this) && this.focus();
      });
    }), u.find(s).forEach((f) => {
      f.classList.contains("modal-non-invasive-show") || n.getInstance(f).hide();
    }), n.getOrCreateInstance(c).toggle(this);
  }), we(n), u.find(t).forEach((l) => {
    const c = $s(l), d = u.findOne(c);
    n.getOrCreateInstance(d);
  });
}, TS = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".offcanvas.show", n = i, o = `hidden.bs.${i.name}`, r = `load.bs.${i.name}.data-api`, l = `resize.bs.${i.name}`;
  h.on(document, e, t, function(c) {
    const d = Te(this);
    if (["A", "AREA"].includes(this.tagName) && c.preventDefault(), Oc(this))
      return;
    h.one(d, o, () => {
      Kt(this) && this.focus();
    });
    const p = u.findOne(s);
    p && p !== d && n.getInstance(p).hide(), n.getOrCreateInstance(d).toggle(this);
  }), h.on(window, r, () => {
    u.find(s).forEach((c) => {
      n.getOrCreateInstance(c).show();
    });
  }), h.on(window, l, () => {
    u.find("[aria-modal][class*=show][class*=offcanvas-]").forEach((c) => {
      getComputedStyle(c).position !== "fixed" && n.getOrCreateInstance(c).hide();
    });
  }), we(n);
}, CS = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, s = i;
  h.on(window, e, () => {
    u.find(t).forEach((n) => {
      s.getOrCreateInstance(n);
    });
  });
}, yS = (i, t) => {
  const e = `load.bs.${i.name}.data-api`, s = `click.bs.${i.name}.data-api`, n = "active", o = `.${n}[data-mdb-tab-init], .${n}[data-mdb-pill-init], .${n}[data-mdb-toggle="list"]`, r = i;
  h.on(document, s, t, function(l) {
    ["A", "AREA"].includes(this.tagName) && l.preventDefault(), !Oc(this) && r.getOrCreateInstance(this).show();
  }), h.on(window, e, () => {
    u.find(o).forEach((l) => {
      r.getOrCreateInstance(l);
    });
  });
}, AS = (i, t) => {
  const e = i;
  we(e), u.find(t).forEach((s) => e.getOrCreateInstance(s));
}, Ac = (i, t) => {
  const e = i;
  h.one(document, "mousedown", t, e.autoInitial(new e()));
}, SS = (i, t) => {
  const e = i;
  we(e, "close"), u.find(t).forEach((s) => e.getOrCreateInstance(s));
}, wS = (i, t) => {
  const e = `click.mdb.${i.name}.data-api`, s = t, n = `${s} img:not(.lightbox-disabled)`, o = i;
  u.find(s).forEach((r) => new o(r)), h.on(document, e, n, o.toggle());
}, OS = (i, t) => {
  const e = `click.bs.${i.name}.data-api`, s = ".modal.show", n = i, o = `show.bs.${i.name}`, r = `hidden.bs.${i.name}`;
  h.on(document, e, t, function(l) {
    const c = Te(this);
    ["A", "AREA"].includes(this.tagName) && l.preventDefault(), h.one(c, o, (f) => {
      f.defaultPrevented || h.one(c, r, () => {
        Kt(this) && this.focus();
      });
    }), u.find(s).forEach((f) => {
      f.classList.contains("modal-non-invasive-show") || n.getInstance(f).hide();
    }), n.getOrCreateInstance(c).toggle(this);
  }), we(n), u.find(t).forEach((l) => {
    const c = $s(l), d = u.findOne(c);
    n.getOrCreateInstance(d);
  });
}, $S = (i, t) => {
  const e = t, s = '[data-mdb-toggle="sidenav"]', n = i;
  h.on(document, "click", s, n.toggleSidenav()), u.find(e).forEach((o) => n.getOrCreateInstance(o));
}, DS = (i, t) => {
  const e = t, s = i;
  we(s), u.find(e).forEach((n) => s.getOrCreateInstance(n));
}, NS = {
  // Bootstrap Components
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: _S
  },
  button: {
    name: "Button",
    selector: "[data-mdb-button-init]",
    isToggler: !0,
    callback: fS
  },
  carousel: {
    name: "Carousel",
    selector: "[data-mdb-carousel-init]",
    isToggler: !0,
    callback: mS
  },
  collapse: {
    name: "Collapse",
    selector: "[data-mdb-collapse-init]",
    isToggler: !0,
    callback: gS
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-mdb-dropdown-init]",
    isToggler: !0,
    callback: bS
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: ES
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-mdb-offcanvas-init]",
    isToggler: !0,
    callback: TS
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-mdb-scrollspy-init]",
    isToggler: !0,
    callback: CS
  },
  tab: {
    name: "Tab",
    selector: "[data-mdb-tab-init], [data-mdb-pill-init], [data-mdb-list-init]",
    isToggler: !0,
    callback: yS
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: AS
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-mdb-tooltip-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-mdb-input-init]",
    isToggler: !0,
    callback: vS
  },
  range: {
    name: "Range",
    selector: "[data-mdb-range-init]",
    isToggler: !1
  },
  ripple: {
    name: "Ripple",
    selector: "[data-mdb-ripple-init]",
    isToggler: !0,
    callback: Ac
  },
  popover: {
    name: "Popover",
    selector: "[data-mdb-popover-init]",
    isToggler: !1,
    callback: Ac
  }
}, Qt = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, LS = {
  line: {
    options: {
      ...Qt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Qt,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Qt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Qt,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Qt,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Qt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Qt,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Qt,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
}, IS = (i, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", s = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((l) => {
      if (l.match(/dataset.*/)) {
        const c = l.slice(7, 8).toLowerCase().concat(l.slice(8));
        r[c] = s(o[l]);
      }
    }), r;
  };
  u.find(t).forEach((o) => {
    if (!i.getInstance(o) && a.getDataAttribute(o, "chart") !== "bubble" && a.getDataAttribute(o, "chart") !== "scatter") {
      const r = a.getDataAttributes(o), l = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (l.type = r.chart), r.labels && (l.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new i(o, {
        ...l,
        ...LS[l.type]
      });
    }
    return null;
  });
}, kS = {
  ...NS,
  chart: {
    name: "Chart",
    selector: "[data-mdb-chart-init]",
    isToggler: !1,
    advanced: IS
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-mdb-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-mdb-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datatable: {
    name: "Datatable",
    selector: "[data-mdb-datatable-init]",
    isToggler: !1
  },
  datetimepicker: {
    name: "Datetimepicker",
    selector: "[data-mdb-datetimepicker-init]",
    isToggler: !1
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-mdb-datepicker-init]",
    isToggler: !1
  },
  loading: {
    name: "Loading",
    selector: "[data-mdb-loading-init]",
    isToggler: !1
  },
  multiRangeSlider: {
    name: "MultiRangeSlider",
    selector: "[data-mdb-multi-range-slider-init]",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-mdb-select-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-mdb-timepicker-init]",
    isToggler: !1
  },
  touch: {
    name: "Touch",
    selector: "[data-mdb-touch-init]",
    isToggler: !1
  },
  alert: {
    name: "Alert",
    selector: "[data-mdb-alert-init]",
    isToggler: !0,
    callback: SS
  },
  animation: {
    name: "Animate",
    selector: "[data-mdb-animation-init]",
    isToggler: !1,
    onInit: "init"
  },
  clipboard: {
    name: "Clipboard",
    selector: "[data-mdb-clipboard-init]",
    isToggler: !1
  },
  infiniteScroll: {
    name: "InfiniteScroll",
    selector: "[data-mdb-infinite-scroll-init]",
    isToggler: !1
  },
  lazyLoad: {
    name: "LazyLoad",
    selector: "[data-mdb-lazy-load-init]",
    isToggler: !1
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-mdb-lightbox-init]",
    isToggler: !0,
    callback: wS
  },
  modal: {
    name: "Modal",
    selector: "[data-mdb-modal-init]",
    isToggler: !0,
    callback: OS
  },
  navbar: {
    name: "Navbar",
    selector: "[data-mdb-navbar-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-mdb-perfect-scrollbar-init]",
    isToggler: !1
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-mdb-popconfirm-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-mdb-rating-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-mdb-sidenav-init]",
    isToggler: !0,
    callback: $S
  },
  smoothScroll: {
    name: "SmoothScroll",
    selector: "[data-mdb-smooth-scroll-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-mdb-stepper-init]",
    isToggler: !1
  },
  sticky: {
    name: "Sticky",
    selector: "[data-mdb-sticky-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-mdb-toast-init]",
    isToggler: !0,
    callback: DS
  }
}, MS = new ku(kS), qS = MS.initMDB;
export {
  lo as Alert,
  Yo as Animate,
  Uo as Autocomplete,
  qc as Button,
  HS as Carousel,
  me as Chip,
  Kd as ChipsInput,
  Fd as Clipboard,
  YS as Collapse,
  vd as Datatable,
  zo as Datepicker,
  qd as Datetimepicker,
  FS as Dropdown,
  nd as InfiniteScroll,
  Wo as Input,
  ho as LazyLoad,
  vs as Lightbox,
  xd as Loading,
  Wd as Modal,
  jd as MultiRangeSlider,
  GS as Navbar,
  th as Offcanvas,
  Md as PerfectScrollbar,
  ud as Popconfirm,
  BS as Popover,
  Fh as Range,
  ao as Rating,
  ks as Ripple,
  VS as ScrollSpy,
  Xo as Select,
  Ts as Sidenav,
  Dd as SmoothScroll,
  yd as Stepper,
  wd as Sticky,
  WS as Tab,
  Ko as Timepicker,
  vi as Toast,
  fm as Tooltip,
  Od as Touch,
  qS as initMDB
};
//# sourceMappingURL=mdb.es.min.js.map
